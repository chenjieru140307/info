
### 第 10 章

##### 10.1引言

信号是软件中断。很多比较重要的应用程序都需处理信号。信号提供了一种处理异步事件的 方法，例如，终端用户键入中断键，会通过信号机制停止一个程序，或及早终止管道中的下一个 程序。

UNIX系统的早期版本就已经提供信号机制，但是送些系统（如 V7）所提供的信号模型并不 可靠。信号可能丢失，而且在执行临界区代码时，进程很难关闭所选择的信号。4.3BSD和 SVR3 对信号模型都做了更改，增加了可靠信号机制。但是 Berkeley 和 AT&T所做的更改之间井不兼容。

幸运的是，POSDC1对可靠信号例程进行了标准化，这正是本章所要说明的。

本章先对信号机制进行综述，并说明每种信号的一般用法。然后分析早期实现的问题。在分 析存在的问题之后再说明解决这些问题的方法，这种安排有助于加深对改进机制的理解。本章也 包含了很多并非完全正确的实例，这样做的目的是为了对其不足之处进行讨论。

###### 10.2信号概念

首先，每个信号都有一个名字。这些名字都以 3 个字符 SIG 开头。例如，SIGABRT是夭折 信号，当进程调用 abort 函数时产生这种信号。SIGALRM是闹钟信号，由 alarm 函数设置的定 时器超时后将产生此信号。V7有 15 种不同的信号，SVR4和 4.4BSD均有 31 种不同的信号。 FreeBSD 8.0 支持 32 种信号，Mac OS X 10.6.8 以及 Linux 3.2.0 都支持 31 种信号，而 Solaris 10 UK] 支持 40 种信号。但是，FreeBSD、Linux和 Solaris 作为实时扩展都支持另外的应用程序定义的信 号。虽然本书不包括 POSIX 实时扩展（有关信息请参阅 Gallmeister[1995]），但是 SUSv4 已经把 实时信号接口移至基础规范说明中。

在头文件＜3191^1上＞中，信号名都被定义为正整数常量（信号编号）。

实际上，实现将各信号定义在另一个头文件中，但是该头文件又包括在＜3^!131上＞中。内核包

括对用户级应用程序有意义的头文件，这被认为是一种不好的形式，所以如若应用程序和内核两者都 需使用同一定义，那么就将有关信息放置在内核头文件中，然后用户级头文件再包括该内核头文件。

j于是，FreeBSD8.0和 MacOSX 10.6.8将信号定义在＜sys/signal.h＞中，Linux3.2.0将信号定义在 I ＜bits/si_gnum.h＞中，Solaris 10将信号定义在〈sys/iso/signal-iso.h〉1^

不存在编号为 0 的信号。在 10.9节中将会看到，kill函数对信号编号 0 有特殊的应用。

POSIX.1将此种信号编号值称为空信号。

很多条件可以产生信号。

•当用户按某些终端键时，引发终端产生的信号。在终端上按 Delete 键（或者很多系统中 的 Ctrl+C键）通常产生中断信号（SIGINT）。这是停止一个已失去控制程序的方法。（第 18章将说明此信号可被映射为终端上的任一字符。）

•硬件异常产生信号：除数为 0、无效的内存引用等。这些条件通常由硬件检测到，并通知 内核。然后内核为该条件发生时正在运行的进程产生适当的信号。例如，对执行一个无 效内存引用的进程产生 SIGSEGV 信号。

•进程调用 kill（2）函数可将任意信号发送给另一个进程或进程组。自然，对此有所限制： 接收信号进程和发送信号进程的所有者必须相同，或发送信号进程的所有者必须是超级 用户。

•用户可用 kill（l）命令将信号发送给其他进程。此命令只是 kill 函数的接口。常用此命 令终止一个失控的后台进程。

•当检测到某种软件条件已经发生，并应将其通知有关进程时也产生信号。这里指的不是 硬件产生条件（如除以 0），而是软件条件。例如 SIGURG （在网络连接上传来带外的数 据）、SIGPIPE （在管道的读进程已终止后，一个进程写此管道）以及 SIGALRM （进程 所设置的定时器已经超时）。

信号是异步事件的经典实例。产生信号的事件对进程而言是随机出现的。进程不能简单地测 试一个变量（如 errno）来判断是否发生了一个信号，而是必须告诉内核“在此信号发生时，请

[314]执行下列操作\

在某个信号出现时，可以告诉内核按下列 3 种方式之一进行处理，我们称之为信号的处理或 与信号相关的动作，

（1）    忽略此信号。大多数信号都可使用这种方式进行处理，但有两种信号却决不能被忽略。 它们是 SIGKILL 和 SIGSTOP。这两种信号不能被忽略的原因是：它们向内核和超级用户提供了 使进程终止或停止的可靠方法。另外，如果忽略某些由硬件异常产生的信号（如非法内存引用或 除以 0），则进程的运行行为是未定义的。

（2）    捕捉信号。为了做到这一点，要通知内核在某种信号发生时，调用一个用户函数。在用 户函数中，可执行用户希望对这种事件进行的处理。例如，若正在编写一个命令解释器，它将用 户的输入解释为命令并执行之，当用户用键盘产生中斷信号时，很可能希望该命令解释器返回到 主循环，终止正在为该用户执行的命令。如果捕捉到 SIGCHLD 信号，则表示一个子进程已经终 止，所以此信号的捕捉函数可以调用 waitpid 以取得该子进程的进程 ID 以及它的终止状态。又 例如，如果进程创建了临时文件，那么可能要为 SIGTERM 信号编写一个信号捕捉函数以清除临 时文件（SIGTERM是终止信号，kill命令传送的系统默认信号是终止信号〉。注意，不能捕捉 SIGKILL 和 SIGSTOP 信号=

（3）    执行系统默认动作。图 10-1给出了对每一种信号的系统默认动作。注意，对大多数信号 的系统默认动作是终止该进程。

图 10-1列出了所有信号的名字，说明了哪咎系统支持此信号以及对于这些信号的系统默认动 作。在 SUS 列中，表示此种信号定义为基本 POSIX.1规范部分，“XSI”表示该信号定义在 XSI扩展部分。

在系统默认动作列，“终止+cOre”表示在进程当前工作目录的 core 文件中复制了该进程的内

存映像(该文件名为 core，由此可以看出这种功能很久之前就是 UNIX 的一部分)。大多数 UNIX 系统调试程序都使用 core 文件检査进程终止时的状态。

| 名字       | 说明                    | ISOC SUS | FreeBSD8.0 | Linux3.2.0 | Mac OS X 10.6.8 | Solaris10 | 默认动作     |
| ---------- | ----------------------- | -------- | ---------- | ---------- | --------------- | --------- | ------------ |
| SIGABRT    | 异常终止(abort)         |          |            |            |                 |           | 终止+core    |
| SIGRLRM    | 定时器超时(alarm)       |          |            |            |                 |           | 终止         |
| SIGBUS     | 硬件故障                |          |            |            |                 |           | 终止+core    |
| SIGCANCEL  | 线程库内部使用          |          |            |            |                 |           | 忽略         |
| SIGCHLD    | 子进程状态改变          |          |            |            |                 |           | 忽略         |
| SIGCONT    | 使暂停进程继续          |          |            |            |                 |           | 继续/忽略    |
| SIGEMT     | 硬件故障                |          |            |            |                 |           | 络止+core    |
| SIGFPE     | 算术异常                | • •      |            |            |                 |           | 终止+core    |
| SIGFREEZE  | 检査点冻结              |          |            |            |                 |           | 忽略         |
| SIGHUP     | 连接断开                |          |            |            |                 |           | 终止         |
| SIGILL     | 非法硬件指令            | • •      |            |            |                 |           | 终止+core    |
| SIGINFO    | 键盘状态请求            |          |            |            |                 |           | 忽略         |
| SIGINT     | 终端中断符              | • •      |            |            |                 |           | 终止         |
| SIGIO      | 异步 I/O                 |          |            |            |                 |           | 终止/忽略    |
| SIGIOT     | 硬件故障                |          |            |            |                 |           | 缕止+core    |
| SIGJVM1    | Java虚拟机内部使用      |          |            |            |                 |           | 忽略         |
| SIGJVM2    | Java虚拟机内部使用      |          |            |            |                 |           | 忽略         |
| SIGKILL    | 终止                    | •        |            |            |                 |           | 终止         |
| SIGLOST    | 资源丢失                |          |            |            |                 |           | 终止         |
| SIGLWP     | 线程库内部使用          | •        |            |            |                 |           | 终止/忽略    |
| SIGPIPE    | 写至无读进程的管道      | •        |            |            |                 |           | 终止         |
| SIGPOLL    | 可轮询事件(poll)        |          |            |            |                 |           | 终止         |
| SIGPROF    | 梗概时间超时 Csetitimer) |          |            |            |                 |           | 终止         |
| SIGPWR     | 电源失效/重启动         |          |            |            |                 |           | 终止/忽略    |
| SIGQUIT    | 终端退出符              | •        |            |            |                 |           | 终止+core    |
| SIGSEGV    | 无效内存引用            | • •      |            |            |                 |           | 终止+core    |
| SIGSTKFLT  | 协处理器找故障          |          |            |            |                 |           | 终止         |
| SXGSTOP    | 停止                    | •        |            |            |                 |           | 停止进程     |
| SIGSYS     | 无效系统调用            | XSI      |            |            |                 |           | 终止+core    |
| SIGTERM    | 终止                    | • •      |            |            |                 |           | 终止         |
| SIGTHAW    | 检査点解冻              |          |            |            |                 |           | 忽略         |
| SIGTHR     | 线程库内部使用          |          |            |            |                 |           | 忽略         |
| SIGTRAP    | 硬件故障                | XSI      |            |            |                 |           | 终止+core    |
| SIGTSTP    | 终端停止符              |          |            |            |                 |           | 停止进程     |
| SIGTTIN    | 后台读控制 tty           |          |            |            |                 |           | 停止进程     |
| SIGTTOU    | 后台写向控制 tty         |          |            |            |                 |           | 停止进程     |
| SIGURG     | 紧急情况(套接字〕       |          |            |            |                 |           | 忽略         |
| SIGUSR1    | 用户定义信号            |          |            |            |                 |           | 终止         |
| SIGUSR2    | 用户定义信号            |          |            |            |                 |           | 终止         |
| SIGVTALRM  | 虚拟时间闹钟(setitimer) | XSI      |            |            |                 |           | 终止         |
| SIGWAITING | 线程库内部使用          |          |            |            |                 |           | 忽略         |
| SIGWINCH   | 终端窗口大小改变        |          |            |            |                 |           | 忽略         |
| SIGXCPU    | 超过 CPU 限制(setrlimit) | XSI      |            |            |                 |           | 终■止+COTC   |
| SIGXFSZ    | 超过文細麵制(setrlimit) | XSI      |            |            |                 |           | 终止■止+core |
| SIGXRES    | 超过资源控制            |          |            |            |                 |           | 忽略         |

图 10-1 UNIX系统信号

产生 core 文件是大多数 UNIX 系统的实现功能。虽然该功能不是 POSIX.1的组成部分，但在 'Single UNIX Specification XSI的扩展部分中，这一功能作为一个潜在的特定实现的动作被提及。

1 在不同的实现中，core文件的名字可能不同。例如，在 FreeBSD 8.0中，core丈件名为

cmtZname.core，其中 c/m/nome是接收到信号的进程所执■行的命令名。在 Mac OS X 10.6.8中，core 文件名是 core.pid，其中，pirf是接收到信号的进程的 ID。（这些系统允许经 sysctl 参教 S&置 core

_,    ，文件名 0 在 Linux 3.2.0 中，core 文件名通过/proc/sys/kernel/core_pattern 进行配置 0）

315

?    大多数实现在相应进程的工作目录中包含 core 文件项；但 Mac OS X将所有 core 文件都放置

316    在/cores目录中。

在下列条件下不产生 core 文件：（a）进程是设置用户 ID 的，而且当前用户并非程序文件的 所有者：（b）进程是设置组 ID 的，而且当前用户并非读程序文件的组所有者：（c）用户没有写当 前工作目录的权限；（d）文件已存在，而且用户对该文件设有写权限；（e）文件太大（回忆 7.11节中 的 RLIMIT_CORE限制）core文件的权限（假定该文件在此之前并不存在）通常是用户读/写， 但 Mac OS X只设置为用户读。

在图 10^1说明中的“硬件故障”对应于实现定义的硬件故障。这些名字中有很多取自 UNIX 系统 早先在 PDP-11上的实现。请查看你所使用系统的手册，以确切地弄清楚这整信号对应于哪些错误类型。

下面较详细地逐一说明这些信号。

SIGABRT 调用 abort 函数时（见 10.17节）产生此信号。进程异常终止。

SIGALRM 当用 alarm 函数设置的定时器超时时，产生此信号。详细情况见 10.10节。 若由 Setitimer（2）函数设置的间隔时间已经超时时，也产生此信号。

SIGBUS 指示一个实现定义的硬件故障。当出现某些类型的内存故障时（如 14.8节中 说明的），实现常常产生此种信号。

SIGCANCEL这是 Solaris 线程库内部使用的信号。它不适用于一般应用。

SIGCHLD    在一个进程终止或停止时，SIGCHLD信号被送给其父进程。按系统默认，将忽

略此信号。如果父进程希望被告知其子进程的这种状态改变，则应捕捉此信号。 信号捕捉函数中通常要调用-•种 wait 函数以取得子进程 ID 和其终止状态。 System V的早期版本有一个名为 SIGCLD （无 H）的类似信号。这一信号具有 与其他信号不同的语义，SVR2的手册页警告在新的程序中尽量不要使用这种 信号。（令人奇怪的是，在 SVR3 和 SVR4 版的手册页中，该警告消失了。〉应 用程序应当使用标准的 SIGCHLD 信号，但应了解，为了向后兼容，很多系统 定义了与 SIGCHLD 等同的 SIGCLD。如果有使用 SIGCLD 的软件，需要查阅 系统手册，了解它具体的语义。10.7节将讨论这两个信号。

SIGCONT    此作业控制信号发送给需要继续运行，但当前处于停止状态的进程。如果接

收到此信号的进程处于停止状态，则系统默认动作是使该进程继续运行；否 则默认动作是忽略此信号。例如，全屏编辑程序在捕捉到此信号后，使用信

岡    号处理程序发出重新绘制终端屏幕的通知。关于进一步的情况见 10.21节。

SIGEMT 指示一个实现定义的硬件故障。

; EMT这一名宇来自 PDP-11的仿真器陷入（emulatortrap）指令。并非所有平台都支持此 :'信号。例如，Linux只对 SPARC、MIPS和 PA_R1SC等系统结构支持 SIGEMT。

SIGFPE    此信号表示一个算术运算异常，如除以 0、浮点溢出等。

SIGFREEZE此信号仅由 Solaris 定义。它用于通知进程在冻结系统状态之前需要采取特定 动作，例如当系统进入休眠或挂起状态时可能需要做这种处理。

SIGHUP    如果终端接口检测到一个连接断开，则将此信号送给与该终端相关的控制进程

（会话首进程）。见图 9-13，此信号被送给 session 结构中 pleader 字段所 指向的进程，仅当终端的 CLOCAL 标志没有设置时，在上述条件下才产生此信 号。（如果所连接的终端是本地的，则设置该终端的 CLOCAL 标志。它告诉终端 驱动程序忽略所有调制解调器的状态行。第 18 章将说明如何设置此标志。）

注意，接到此信号的会话首进程可能在后台，作为一个例子，请参见图 9-7。

这医别于由终端正常产生的几个信号（中断、退出和挂起），这些信号总是传 递给前台进程组。

如果会话首进程终止，也产生此信号。在这种情况，此信号送给前台进程组 中的每一个进程。

通常用此信号通知守护进程（见第 13 章）再次读取它们的配置文件。选用 SIGHUP 的理由是，守护进程不会有控制终端，通常决不会接收到这种信号。

SIGILL    此信号表示进程已执行一条非法硬件指令。

1 4.3BSD的 abort 函数产生此信号。现在该函数产生 SIGABRT 信号。

SIGINFO    这是一种 BSD 信号，当用户按状态键（一般采用 Ctrl+T）时，终端驱动程序

产生此信号并发送至前台进程组中的每一个进程（见图 9-9）„此信号通常造 成在终端上显示前台进程组中各进程的状态信息。

1 虽然 Alpha 平台将 SIGINFO 定义为与 SIGPWR 具有相同值，但是 Linux 并不支持 SIGINFO !信号。这更多是因为需要对 OSF/1开发的软件提供某种往度的兼容。    [3181

SIGINT    当用户按中断键（一般采用 Delete 或 Ctrl4€）时，终端驱动程序产生此信号

并发送至前台进程组中的每一个进程（见图 9-9〉，当一个进程在运行时失控， 特别是它正在屏幕上产生大量不需要的输出时，常用此信号终止它。

SIGIO    此信号指示一个异步 I/O事件。在 14.5.2节中将对此进行讨论。

| 在困 10-1中，对 SIGIO 的系统默认动作是终止或忽略。遣憾的是，这依赖于系统。在 :System V中，SIGIO与 SIGPOLL 相同，其默认动作是终止此进程。在 BSD 中，其默认动 1作是忽略此信号。

Linux 3.2.0和 Solaris 10将 SIGIO 定义为与 SIGPOLL 具有相同值，所以默认行为是终 !止该进程。在 FreeBSD 8.0和 Mac OS X 10.6.8中，默认行为是忽略该信号。

SIGIOT    这指示一个实现定义的硬件故障。

1OT这个名字来自于 PDP-11，它是 PDP-11计算机“输入/榆出 TRAP”（ input/ouiput TRAP）指

令的缩写。System V的早期版本，由 abort 函数产生此信号。该函数现在产生 SIGABRT 信号。 FreeBSD 8.0、Linux 3.2,0、Mac OS X 10.6.8 和 Solaris 10 将 SIGIOT 定义为与 SIGABRT

具相同值。

SIGJVM1 Solaris上为 Java 虚报机预留的一个信号。

SIGJVM2    Solaris上为 Java 虚拟机预留的另一个信号。

SIGKILL    这是两个不能被捕捉或忽略信号中的一个。它向系统管理员提供了一种可以

杀死任一进程的可靠方法。

SIGLOST 运行在 Solaris NFSV4客户端系统中的进程，恢复阶段不能重新获得锁，此时 将由这个信号通知该进程。

SIGLWP    此信号由 Solaris 线程库内部使用，并不做一般使用。在 FreeBSD 中，SIGLWP

是 SIGTHR 的别名。

SIGPIPE    如果在管道的读进程已终止时写管道，则产生此信号。15.2节将说明管道。当

类型为 SOCK_STREAM的套接字已不再连接时，进程写该套接字也产生此信 号。我们将在第 16 章说明套接字。

SIGPOLL    这个信号在 SUSv4 中已被标记为弃用，将来的标准可能会将此信号移除。当

在一个可轮询设备上发生一个特定事件时产生此信号。14.4.2节将说明 poll 函数和此信号，它起源于 SVR3，与 BSD 的 SIGIO 和 SIGURG 信号接近。

； 在 Linux 和 Solaris 中，SIGPOLL定义为与 SIGIO 具有相同值。

SIGPROF    这个信号在 SUSV4 中已被标记为弃用，将来的标准可能会将此信号移除。当

setitimer（2）函数设置的梗概统计间隔定时器（profiling interval timer）已经 超时时产生此信号。

SIGPWR    这是一种依赖于系统的信号。它主要用于具有不间断电源（UPS）的系统。如

果电源失效，则 UPS 起作用，而且通常软件会接到通知。在这种情况下，系 统依靠蓄电池电源继续运行，所以无须做任何处理，但是如果蓄电池也将不 能支持工作，则软件通常会再次接到通知，此时，系统必项使其各部分都停 止运行。这时应当发送 SIGPWR 信号》在大多数系统中，接到蓄电池电压过 低信息的进程将信号 SIGPWR 发送给 init 进程，然后由 init 处理停机操作。 j Solaris 10和有些 Linux 版本在 inittab 文件中有两个记录项用于此种目的：powerfail

；以及 powerwait （或 powerokwait ）0

在图 10~1中，我们将 SIGPWR 的跃认动作标记为“终止或忽略”。遣螝的是，这种默认动 j作依赖于系统。Linux对此的默认动作是终止相关进程，而 Solaris 的默认动作是忽略该信号。

SIGQUIT    当用户在终端上按退出键（一般采用 Ctri+U时，中断驱动程序产生此信号，

并发送给前台进程组中的所有进程（见图 9-9）。此信号不仅终止前台进程组 （如 SIGINT 所做的那样），同时产生一个 core 文件。

SIGSEGV    指示进程进行了一次无效的内存引用（通常说明程序有错，比如访问了一个

未经初始化的指针）。

名字 SEGV 代表“段违例”（segmentation violation ）。

SIGSTKFLT此信号仅由 Linux 定义。它出现在 Linux 的早期版本，企图用于数学协处理器 的栈故障。该信号并非由内核产生，但仍保留以向后兼容。

SIGSTOP    这是一个作业控制信号，它停止一个进程。它类似于交互停止信号（SIGTSTP），

但是 SIGSTOP 不能被捕捉或忽略-

SIGSYS



该信号指示一个无效的系统调用。由于某种未知原因，进程执行了一条机器

指令，内核认为这是一条系统调用，但该指令指示系统调用类型的参数却是 无效的。这种情况是可能发生的，例如。若用户编写了一道使用新系统调用 的程序，然后运行该程序的二进制可执行代码，而所用的操作系统却是不支 持该系统调用的较早版本，于是就出现上述情况 D    [320]

SIGTERM 这是由命令发送的系统默认终止信号。由于该信号是由应用程序捕获 的，使用 SIGTERM 也让程序有机会在退出之前做好清理工作，从而优雅地终 止（相对于 SIGKILL 而言。SIGKILL不能被捕捉或者忽略）。

SIGTHAW    此信号仅由 Solaris 定义。在被挂起的系统恢复时，该信号用于通知相关进程，

它们需要采取特定的动作。

SIGTHR    FreeBSD线程库预留的信号，它的值定义或与 SIGLWP 相同。

SIGTRAP    指示一个实现定义的硬件故障。

1    此信号名来自于 PDP-11的 TRAP 指令。当执行断点指令时，实现常用此信号将控制转

I移至调试程序。

SIGTSTP 交互停止信号，当用户在终端上按挂起键（一般采用 Ctrl+Z）时，终端驱动 程序产生此信号。该信号发送至前台进程组中的所有进程（参见图 9-9），

j    遣憾的是，停止具有不同的含义。当讨论作业控制和信号时，我们谈及停止和继续作业。

；但是，终端驱动程序一直使用术语“停止”表示用 Ctrt+S字符终止终端输出，为了继续启动

该终端输出，则用 Ctrl+Q字符。为此，终端驱动程序称产生交互停止信号的字符为挂起字符，

而非停止字符。

SIGTTIN    当一个后台进程组进程试图读其控制终端时，终端驱动程序产生此信号（见

9.8节中对此问题的讨论）。在下列例外情形下不产生此信号：（a）读进程忽略 或阻塞此信号；（b）读进程所属的进程组是孤儿进程组，此时读操作返回出 错，errno设置为 EI0。

SIGTTOU



SIGURG

SIGUSR1

SIGUSR2

SIGVTALRM

SIGWAITING



当一个后台进程组进程试图写其控制终端时，终端驱动程序产生此信号（见 9.8节对此问题的讨论）。与上面所述的 SIGTTIN 信号不同，一个进程可以选 择允许后台进程写控制终端。第 18 章将讨论如何更改此选项。

如果不允许后台进程写，则与 SIGTTIN 相似，也有两种特殊情况：（a）写进 程忽略或阻塞此信号；（b）写进程所属进程组是孤儿进程组。在第 2 种情况下 不产生此信号，写操作返回出错，errno设置为 EI0。

不论是否允许后台进程写，一些除写以外的下列终端操作也能产生 SIGTTOU 信号，如 tcsetattr、tcsendbreak-. tcdrain、tcflush、tcf low 以 及 tcsetpgrp。第 18 章将说明这些终端操作。

此信号通知进程已经发生一个紧急情况。在网络连接上接到带外的数据时， 可选择地产生此信号。

这是一个用户定义的信号，可用于应用程序。

这是另一个用户定义的信号，与 SIGUSR1 相似，可用于应用程序。

当一个由 Setitimer（2）函数设置的虚拟间隔时间已经超时时，产生此信号。 此信号由 Solaris 线程库内部使用，不做他用。

SIGWINCH    内核维持与每个终端或伪终端相关联窗口的大小。进程可以用 ioctl 函数（见

18.12节）得到或设置窗口的大小。如果进程用 ioctl 的设置窗口大小命令 更改了窗口大小，则内核将 SIGWINCH 信号发送至前台进程组。

SIGXCPU Single UNIX Specification的 XSI 扩展支持资源限制的概念（见 7.11节）。如果 进程超过了其软 CPU 时间限制，则产生此信号。

； 在图 10-1中，对于 SIGXCPU 的默认动作说明为“终止或终止+core”。该默认动作依赖 于操作系统。Linux 3.2.0和 Solaris 10支持的默认动作是终止并劍建 core 文件；FreeBSD 8.0

:和 Mac OS X 10.6.8支持的默认动作是终止且不产生 core 文件。Single UNIX Specification要 求该默认动作是，异常终止该进程，是否刽建 core 文件则留给实现决定。

SIGXFSZ    如果进程超过了其软文件长度限制（见 7.11节），则产生此信号。

如同 SIGXCPU 一样，针对 SIGXFSZ 的默认动作依赖于操作系统。Linux3.2.0 Solaris

■ 10对此信号的默认动作是终止并创建 core 文件。FreeBSD 8.0和 Mac OS X 10.6.8支持的默 认动作是终止且不产生 core 文件 d Sii^le UNIX Specification要求该默认动作是弃常终止该进 程，是否创建 core 文件则留给实现决定。

SIGXRES 此信号仅由 Solaris 定义。可选择地使用此信号以通知进程超过了预配置的资源值。

Solaris资源限制机制是一种通用设施，用于接制在独立应用集之间共享资源的使用。

##### 10.3 函数 signal

UNIX系统信号机制最简单的接口是 signal 函数。

\#include <signal.h>

void （*signal （int signo, void    （int））） lint），-

返囲值：若成功，返回以前的信号处理配置：若出错，返回 SIG ERR

signal函数由 ISO C定义。因为 ISO C不涉及多进桎、进程组以及终端 I/O等，所以它对 I信号的定义非常含糊，以致于对 UNIX 系統而言几乎毫无用处。

（ 从 UNIX System V派生的实现支持 signal 函数，但该函数提供旧的不可靠信号语义（10.4 !节将说明这些旧的语义）。提供此函数主要是为了向后兼容要求此旧语义的应用程序，新应用程序 ；不应使用这些不可靠信号。

, 4.4BSD也提供 signal 函数，但它是按照 sigaction 函数定义的（10.14节将说明 j sigaction函数），所以在 4.4BSD之下使用它提供新的可靠信号语义。目前大多数系统遵摘这 f种策略，但 Solaris 10沿用 System V signal函數的语义。

]    因为 signal 的语义与实现有关，所以最好使用 sigaction 函数代替 signal &教。在 10.14

节讨论 sigaction 函教时，提供了使用该函数的 signal 的一个实现。本书中的所有实例均使

'用图]0-18中给出的 signal 函数，这样不管使用何种平台都可以有一致的语义。

signo参数是图 10-1中的信号名。June的值是常量 SIG_IGN>常量 SIG.DFL或当接到此信 号后要调用的函数的地址，如果指定 SIG_IGN，则向内核表示忽略此信号（记住有两个信号 SIGKILL 和 SIGSTOP 不能忽略）。如果指定 SIG_DFL，则表示接到此信号后的动作是系统默认动作（见图 10-1

中的最后一列)。当指定函数地址时，则在信号发生时，调用该函数，我们称这种处理为捕捉该信号， 称此函数为信号处理租序(signal handler)或信号捕捉函数(signal-catching function)o

signal函数原型说明此函数要求两个参数，返回一个函数指针，而该指针所指向的函数无 返回值(void)。第一个参数 signo 是一个整型数，第二个参数是函数指针，它所指向的函数需 要一个整型参数，无返回值。signal的返回值是一个函数地址，该函数有一个整型参数(即最 后的(int))。用自然语言来描述也就是要向信号处理程序传送一个整型参数，而它却无返回值。 当调用 signal 设置信号处理程序时，第二个参数是指向该函数(也就是信号处理程序)的指针。 signal的返回值则是指向在此之前的信号处理程序的指针。

'    很多系统用附加的依赖于实现的参教来谓用信号处理程序。10.14节将对此做进一步说明。

本节开头所示的 signal 函数原型太复杂了，如果使用下面的 typedef[Plauger 1992]，则 可使其简单一些。

typedef void Sigfunc(int);

然后，可将 signal 函数原型写成：

Sigfunc *signal(int, Sigfunc *);

我们已将此 typedef 包括在 apue.h文件中(见附录 B)，并随本章中的函数一起使用。

如果査看系统的头文件<3191^1』>，则很可能会找到下列形式的声明：

\#define SIG_ERR (void (”<))-1 tdefine SIG_DFL (void (”<))0 #define SIG_IGN (void (”⑴1

这些常量可用于表示“指向函数的指针，该函数要求一个整型参数，而且无返回值”。signal的 第二个参数及其返回值就可用它们表示。这些常量所使用的 3 个值不一定是-1、0和 1，但它们 必须是 3 个值而决不能是任一函数的地址。大多数 UNIX 系统使用上面所示的值。

獨■实例

图 10-2给出了一个简单的信号处理程序，它捕捉两个用户定义的信号并打印信号编号。10.10 节将说明 pause 函数，它使调用进程在接到一信号前挂起。

\#include "apue.h"

static void sig_usr(int); Z* one handler for both signals */

int

main(void)

{

if (signal(SIGUSR1, sig_usr) == SIG_ERR) err_sys("can't catch SIGUSR1""

if (signal{SIGUSR2, sig_usr) == SIG_ERR) err_sys("can't catch SIGUSR2");

for (;;) pause {);

static void sig_usr(int signo)



/* argument is signal number */

if (signo == SIGUSR1)

printf("received SIGUSRl\n");

else if (signo == SIGUSR2)

printf("received SIGUSR2\n");

else

err_dump("received signal %d\n", signo);

13241    图 10-2捕捉 SIGUSR1 和 SIGUSR2 的简单程序

我们使该程序在后台运行，并且用 kill(l)命令将信号发送给它。注意，在 UNIX 系统中，

杀死(kill)这个术语是不恰当的。kill(l)命令和 kill(2)函数只是将一个信号发送给一个进程 或进程组。该信号是否终止进程则取决于该信号的类型，以及进程是否安排了捕捉该信号。

$ ./a.out &

[1]    7216

$ kill -USR1 7216 received SIGUSR1 $ kill -USR2 7216 received SIGUSR2 $ kill 7216



在后台启动进程

作业控制 shell 打印作业编号和进程 ID 向该进程发送 SIGUSR1

向该进程发送 SIGUSR2

向该进程发送 SIGTERM

[1] + Terminated ./a.out

因为执行图 10-2程序的进程不捕捉 SIGTERM 信号，而对该信号的系统默认动作是终止，所 以当向该进程发送 SIGTERM 信号后，该进程就终止。    •

1.程序启动

当执行一个程序时，所有信号的状态都是系统默认或忽略，通常所有信号都被设置为它们的默 认动作，除非调用 exec 的进程忽略该信号。确切地讲，exec函数将原先设置为要捕捉的信号都 更改为默认动作，其他信号的状态则不变(一个进程原先要捕捉的信号，当其执行一个新程序后， 就不能再捕捉了，因为信号捕捉函数的地址很可能在所执行的新程序文件中已无意义)-

一个具体例子是一个交互 shell 如何处理针对后台进程的中断和退出信号。对于一个非作业控 制 shell，当在后台执行一个进程时，例如：

cc main.c &

shell自动将后台进程对中断和退出信号的处理方式设置为忽略，于是，当按下中断字符时就不会 影响至 U 后台进程。如果没有做这样的处理，那么当按下中断字符时，它不但终止前台进程，也终 止所有后台进程，

很多捕捉这两个信号的交互程序具有下列形式的代码：

void sig_int(int), sig_quit(int); if (signal(SIGINT, SIG_IGN) != SIG_IGN)

signal(SIGINT, sig_int); if (signal(SIGQOIT, SIGJCGN) != SIG_IGN)

signal(SIGQUIT, sig_quit);

[325]这样处理后，仅当 SIGINT 和 SIGQUIT 当前未被忽略时，进程才会捕捉它们。

从 signal 的这两个调用中也可以看到这种函数的限制，不改变信号的处理方式就不能确定

信号的当前处理方式。我们将在本章的稍后部分说明使用 sigaction 函数可以确定一个信号的 处理方式，而无需改变它。

2.进程创建

当一个进程调用 fork 时，其子进程继承父进程的信号处理方式。因为子进程在开始时复制 了父进程内存映像，所以信号捕捉函数的地址在子进程中是有意义的。

10-4不可靠的信号

在早期的 UNIX 版本中(如 V7)，信号是不可靠的。不可靠在这里指的是，信号可能会丢失：

一个信号发生了，但进程却可能一直不知道这一点。同时，进程对信号的控制能力也很差，它能 捕捉信号或忽略它。有时用户希望通知内核阻塞某个信号：不要忽略该信号，在其发生时记住它，

然后在进程做好了准备时再通知它。这种阻塞信号的能力当时并不具备。

4.2BSD对信号机制进行了更改，提供了被称为可靠信号的机制。然后，SVR3也修改了信号 '机制，提供了 System V可靠信号机制。POSIX.1选择了 BSD模型作为其标准化的基础。

早期版本中的一个向题是在进程每次接到信号对其进行处理时，随即将该信号动作重置为默 认值(在前面运行图 10-2程序时，每种信号只捕捉一次，从而回避了这一点)。在描述这些早期 系统的编程书籍中，有一个经典实例，它与如何处理中断信号相关，其代碍与下面所示的相似：

int sig_int();    /* my signal handling function */

signal(SIGINT, sig_int); Z* establish handler */

sig^int (J

{

signal(SIGINT, sig_int);    /* reestablish handler for next time */

:    /* process the signal ... */

I

C由于早期的 C 语言版本不支持 ISO C的 void 数据类型，所以将信号处理程序声明为 int 类型。)

这段代码的一个问题是：在信号发生之后到信号处理程序调用 signal 函数之间有一个时间 r—,

窗口。在此段时间中，可能发生另一次中断信号。第二个信号会造成执行默认动作，而对中断信 I* 号的默认动作是终止该进程。这种类型的程序段在大多数情况下会正常工作，使得我们认为它们 是正确无误的，而实际上却并非如此。

这些早期版本的另一个问题是：在进程不希望某种信号发生时，它不能关闭该信号。进程能 做的一切就是忽略该信号。有时希望通知系统“阻止下列信号发生，如果它们确实产生了，请记 住它们。”能够显现这种缺陷的的一个经典实例是下列程序段，它捕捉一个信号，然后设置一个 表示该信号已发生的标志：

int sig^int();    /* my signal handling function */

int sig_int_flag;    /* set nonzero when signal occurs */

main ()

signal(SIGINT, sig_int);    /* establish handler */

while (sig_int_flag == 0)

pause(》；    /* go to sleep, waiting for signal */

}

sig_int ()

signal(SIGINT, sig_int); sig_int_flag = 1;



/* reestablish handler for next time */ /* set flag for main loop to examine */

其中，进程调用 pause 函数使自己休眠，直到捕捉到一个信号。当捕捉到信号时，信号处理程 序将标志 sig_int_fiag设置为非 0 值。从信号处理程序返回后，内核自动将该进程唤醒，它 检测到该标志为非 0，然后执行它所需做的，但是这里有一个时间窗口，在此窗口中操作可能失误。 如果在测试 sig_int_flag之后、调用 pause 之前发生信号，则此进程在调用 pause 时可能 将永久体眠（假定此信号不会再次产生），于是，这次发生的信号也就丢失了。这是另一个例子， 某段代码并不正确，但是大多数时间却能正常工作。要査找并排除送种类型的问题很困难。

10.5中断的系统调用

早期 UNIX 系统的一个特性是：如果进程在执行一个低速系统调用而阻塞期间捕捉到一个信 号，则该系统调用就被中断不再继续执行。该系统调用返回出错，其 errno 设置为 EINTR。这 样处理是因为一个信号发生了，进程捕捉到它，这意味着已经发生了某种事情，所以是个好机会 应当唤醒阻塞的系统调用。

[327]    在这里，我们必须区分系统调用和函也当捕捉到某个信号时，枝中断的是内核中执行的系统调用。

为了支持这种特性，将系统调用分成两类：低速系统调用和其他系统调用，低速系统调用是 可能会使迸程永远阻塞的-类系统调用，包括：

•如果某些类型文件（如读管道、终端设备和网络设备）的数据不存在，则读操作可能会 使调用者永远阻塞；

•如果这些数据不能被相同的类型文件立即接受，则写操作可能会使调用者永远阻塞：

•在某种条件发生之前打开某些类型文件，可能会发生阻塞（例如要打开一个终端设备， 需要先等待与之连接的调制解调器应答）；

• pause函数（按照定义，它使调用进程休眠直至捕捉到一个信号）和 wait 函数；

•某些 ioctl 操作；

•某些进程间通信函数（见第 15 章）。

在这些低速系统调用中，一个值得注意的例外是与磁盘 I/O有关的系统调用。虽然读、写一 个磁盘文件可能暂时阻塞调用者（在磁盘驱动程序将请求排入队列，然后在适当时间执行请求期 间），但是除非发生硬件错误，I/O操作总会很快返回，并使调用者不再处于阻塞状态。

可以用中断系统调用这种方法来处理的一个例子是：一个进程启动了读终端操作，而使用该 终端设备的用户却离开该终端很长时间。在这种情况下，进程可能处于阻塞状态几个小时甚至数 天，除非系统停机，否则一直如此。

； 对于中断的 read、write系统调用，POSIX.1的语义在该标准的 2001 版有所改变。对于如 何处理已 read、write部分数据責的相应系统调用，早期版本允许实现自行选择。如若 read 系统调用已接收并传送数据至应用程序缓冲区，但尚未接收到应用程序请求的全部数据，此时被

:中断，操作系统可以认为该系统调用失败，并将 errno 设置为 EINTR；另一种处理方式是允许 :该系统调用成功返回，返回值是已接收到的数据量。与此类似，如若 write 巳传输了应用程序缓

冲区中的部分数据，然后被中断，操作系统可以认为该系统调用失败，并将 errno 设置为 EINTR;

；另一种处理方式是允许该系统调用成功返回，返回值是已写部分的数据量。历史上，从 SystemV 派生的实政将这种系统调用视为失败，而 BSD 派生的实现则处理为部分成功返回。2001版 POSDC1 标准采用 BSD 风格的语义。

与被中断的系统调用相关的问题是必须显式地处理出错返回。典型的代码序列(假定进行一 个读操作，它被中断，我们希望重新启动它)如下：

again:

if ((n = read(fd, buf, BUFFSIZE)) < 0) { if (errno == EINTR)

goto again； /* just an interrupted system call */

/* handle other errors */

}    画

为了帮助应用程序使其不必处理被中断的系统调用，4.2BSD引进了某些被中断系统调用的自

动重启动。自动重启动的系统调用包括：ioctl、read、readv、write、writev、wait和 waitpid。如前所述，其中前 5 个函数只有对低速设备进行操作时才会被信号中断。而 wait 和 waitpid在捕捉到信号时总是被中断。因为这种自动重启动的处理方式也会带来问题，某些应用 程序并不希望这些函数被中断后重启动。为此 4.3BSD允许进程基于每个信号禁用此功能。

POS1X.1要求只有中断信号的 SA_RESTART标志有效时，实現才重启动系统调用。在 10.14

\节将看到，sigaction函數使用这个标志允许应用程序请求重启动被中断的系就讶用。

历史上，使用 signal 函数建立信号处理程序时，对于如何处理被中断的系洗调用，各种实

i现的做法各不相同。SystemV的默认工作方式是从不重启动系统调用。而 BSD 则重启动枝信号中 :断的系统调用。FreeBSD 8.0、Linux 3.2.0和 Mac OS X 10.6.8中，当信号处理程序是用 signal :函数时，被中断的系统调用会重启动。但 Solaris 10的默认方式是出错返回，将 errno 设置为

E工 NTR。使用用户自己实现的 signal 函教(见图 10-18)可以避免必须处理这些差异的麻烦。

4.2BSD引入自动重启动功能的一个理由是：有时用户并不知道所使用的输入、输出设备是否 是低速设备。如果我们编写的程序可以用交互方式运行，则它可能读、写终端低速设备。如果在 程序中捕捉信号，而且系统并不提供重启动功能，则对每次读、写系统调用就要进行是否出错返 回的测试，如果是被中断的，则再调用读、写系统调用。

图 10-3列出了几种实现所提供的与信号有关的函数及它们的语义。

| 函数                                     | 系统                                                     | 信号处理程 序仍被安装 | 阻塞信号 的能力 | 被中断用 的自动重启动？ |
| ---------------------------------------- | -------------------------------------------------------- | --------------------- | --------------- | ----------------------- |
| signal                                   | ISOC、POSIX.1                                            | 未说明                | 未说明          | 未说明                  |
| V7、SVR2、SVR3                           |                                                          |                       | 从不            |                         |
| SVR4、Solaris                            |                                                          |                       | 从不            |                         |
| 4.2BSD                                   | •                                                        | •                     | 总是            |                         |
| 4.3BSD' 4.4BSD、FreeBSD, Linux. Mac OS X | •                                                        | •                     | 默认            |                         |
| sigaction                                | POSK.l、4+4BSD、SVR4、FreeBSD、Linux、 Mac OS X、Solaris | -                     | •               | 可选                    |

图 10-3几种信号实现所提供的功能

应当了解，其他厂商提供的 UNIX 系统可能不同于图 10-3中所示的情况，例如，SunOS 4.1.2 中的 sigaction 默认方式是重启动被中断的系统调用，这与列在图 10-3中的各平台不同。

在图 10-18中，提供了我们自己的 signal 函数版本，它自动地尝试重启动被中断的系统调 用（除 SIGALRM 信号外）。在图 10-19中则提供了另一个函数 Signal_intr，它不进行重启动。

在 14.4节说明 select 和 poll 函数时，还将更多涉及被中断的系统调用。


10.6可重入函数

进程捕捉到信号并对其进行处理时，进程正在执行的正常指令序列就被信号处理程序临时中 断，它首先执行该信号处理程序中的指令。如果从信号处理程序返回（例如没有调用 exit 或 longjmp），则继续执行在捕捉到信号时进程正在执行的正常指令序列（这类似于发生硬件中断 时所做的）。但在信号处理程序中，不能判断捕捉到信号时进程执行到何处。如果进程正在执行 malloc，在其堆中分配另外的存储空间，而此时由于捕捉到信号而插入执行该信号处理程序， 其中又调用 malloc，这时会发生什么？又例如，若进程正在执行 getpwnam （见 6.2节）这种 将其结果存放在静态存储单元中的函数，其间插入执行信号处理程序，它又调用这样的函数，这 时又会发生什么呢？在 malloc 例子中，可能会对进程造成破坏，因为 malloc 通常为它所分配 的存储区维护一个链表，而插入执行信号处理程序时，进程可能正在更改此链表。在 getpwnam 的例子中，返回给正常调用者的信息可能会被返回给信号处理程序的信息覆盖。

Single UNIX Specification说明了在信号处理程序中保证调用安全的函数。这些函数是可重入 的并被称为是异步信号安全的（async-signalsafe）。除了可重入以外，在信号处理操作期间，它会 阻塞任何会引起不一致的信号发送 a 图 1（M列出了这些异步信号安全的函数。没有列入图 10-4中

| abort         | faccessat   | linkat            | select      | socketpair       |
| ------------- | ----------- | ----------------- | ----------- | ---------------- |
| accept        | fchmod      | listen            | sem_post    | stat             |
| access        | fchraodat   | Iseek             | send        | symlink          |
| aio_error     | fchown      | lstat             | sendmsg     | symlinkat        |
| aio_return    | fchownat    | mkdir             | sendto      | tcdrain          |
| aio_suspend   | fcntl       | mkdirat           | setgid      | tcflow           |
| alarm         | fdatasync   | mkfifo            | setpgid     | tcflush          |
| bind          | fexecve     | mkfifoat          | setsid      | tcgetattr        |
| cfgetispeed   | fork        | mknod             | setsockopt  | tcgetpgrp        |
| cfgetospeed   | fstat       | mknodat           | setuid      | tcsendbreak      |
| cfsetispeed   | fstatat     | open              | shutdown    | tcsetattr        |
| cfsetospeed   | fsync       | openat            | sigaction   | tcsetpgrp        |
| chdir         | ftruncate   | pause             | sigaddset   | time             |
| chmod         | futimens    | pipe              | sigdelset   | timer_getoverrun |
| chown         | getegid     | poll              | sigemptyset | timer_gettime    |
| clock_gettime | geteuid     | posix_trace_event | sigfillset  | timer_settime    |
| close         | getgid      | pselect           | sigismember | times            |
| connect       | getgroups   | raise             | signal      | umask            |
| creat         | getpeername | read              | sigpause    | uname            |
| dup           | getpgrp     | readlink          | sigpending  | unlink           |
| dup2          | getpid      | readlinkat        | sigprocmask | ulinkat          |
| execl         | getppid     | recv              | sigqueue    | utime            |
| execle        | getsockname | recvfrom          | sigset      | utimensat        |
| execv         | getsockopt  | recvmsg           | sigsuspend  | utimes           |
| execve        | getuid      | rename            | sleep       | wait             |
| Exit          | kill        | renameat          | socketmark  | waitpid          |
| exit          | link        | rmdir             | socket      | write            |

图 104 信号处理程序可以调用的可重入函数

的大多数函数是不可重入的，因为（a）已知它们使用静态数据结构；（b）它们调用 malloc 或 free； （c）它们是标准 I/O函数。标准 I/O库的很多实现都以不可重入方式使用全局数据结构。

注意，虽然在本书的某些实例中，信号处理程序也调用了 printf函数，但这并不保证产生所期 望的结果，信号处理程序可能中断主程序中的 printf 函数调用》

应当了解，即使信号处理程序调用的是图 l（b4中的函数，但是由于每个线程只有一个 errno 变量（回忆 1.7节对 errno 和线程的讨论），所以信号处理程序可能会修改其原先值。考虑一个 信号处理程序，它恰好在 main 刚设置 errno 之后被调用。如果该信号处理程序调用 read 这类 p 函数，则它可能更改 errno 的值，从而取代了刚由 main 设置的值。因此，作为一个通用的规则， 当在信号处理程序中调用图 104 中的函数时，应当在调用前保存 errno，在调用后恢复 errno。1~1 （应当了解，经常被捕捉到的信号是 SIGCHLD，其信号处理程序通常要调用一种 wait 函数，而 各种 wait 函数都能改变 errno。）

注意，图 1（M没有包括 longjmp （7.10节）和 siglongjmp （10,15节\这是因为主例程 以非可重入方式正在更新一个数据结构时可能产生信号。如果不是从信号处理程序返回而是调用 siglongjmp，那么该数据结构可能是部分更新的。如果应用程序将要做更新全局数据结构这样 的事情，而同时要捕捉某些信号，而这些信号的处理程序又会引起执行 siglongjmp，则在更新 这种数据结构时要阻塞此类信号。

、实例

图 1〜5给出了一段程序，这段程序从信号处理程序 myjlarm 调用非可重入函数 getpwnam，

而 my_alarm每抄钟被调用一?欠。10.10节中将说明 alarm 函数。在该程序中调用 alarm 函数 使得每抄产生一次 SIGALRM 信号。    [3Ti~|

\#include "apue.h"

\#include <pwd.h>

static void

my_alarm（int signo）

i

struct passwd *rootptr;

printf("in signal handler\n")；

if Urootptr * getpwnainC'root")) == NULL) err_sys("getpwnam(root) error");

alarm (1);

int

main (void)

{

struct passwd *ptr;

signal(SIGALRM, my_alarm); alarm ⑴； for ( ; ; ) {

if { {ptr = getpwnam("sar")) =- NULL) err_sys("getpwnam error");

if (strcmp(ptr->pw_name, "sar") != 0)

printf("return value corrupted!, pw_name = %s\n", ptr->pw_name)，-

图 10-5在信号处理程序中调用不可再入函数

运行该程序时，其结果具有随机性。通常，在信号处理程序经多次迭代返回时，该程序 将由 SIGSEGV 信号终止。检査 core 文件，从中可以看到 main 函数己调用 getpwnam，但 当 getpwnam 调用 free 时，信号处理程序中断了它的运行，并调用 getpwnam，进而再次调 用 free。在信号处理程序调用 free 而主程序也在调用 free 时，malloc和 free 维护的数 据结构就出现了损坏，偶然，此程序会运行若干秒，然后因产生 SIGSEGV 信号而终止。在捕捉 到信号后，若 main 函数仍正确运行，其返回值却有时错误，有时正确。

从此实例中可以看出，如果在信号处理程序中调用一个非可重入函数，则其结果是不可预 知的。    •

10.7 SXGCLD 语义

SIGCLD和 SIGCHLD 这两个信号很容易被混淆。SIGCLD （没有 H）是 System V的一个信号 名，其语义与名为 SIGCHLD 的 BSD 信号不同。POSIX.1采用 BSD 的 SIGCHLD 信号。

画    BSD的 SIGCHLD 信号语义与其他信号的语义相类似。子进程状态改变后产生此信号，父进

程需要调用一个 wait 函数以检测发生了什么。

System V处理 SIGCLD 信号的方式不同于其他信号。如果用 signal 或 sigset （早期设置 信号配置的，与 SRV3 兼容的函数）设置信号配置，则基于 SVR4 的系统继承了这一具有问题色 彩的传统（即兼容性限制）。对于 SIGCLD 的早期处理方式是：

（1）如果进程明确地将该信号的配置设置为 SIG„IGN，则调用进程的子进程将不产生僵死进 程。注意，这与其默认动作（SIG_DFL） “忽略”（见图 10-1）不同。子进程在终止时，将其状态 丢弃。如果调用进程随后调用一个 wait 函数，那么它将阻塞直到所有子进程都终止，然后该 wait 会返回-1，并将其 errno 设置为 ECHILD。（此信号的默认配置是忽略，但这不会使上述语义起 作用。必须将其配置明确指定为 SIG_IGN才可以。）

I POSIX.I并未说明在 SIGCHLD 被忽略时应产生的后果，所以这种行为是允许的。Single UNIX ）Specification的 XSI 扩展选项要求对于 SIGCHLD 支持这种行为。

' 如果 SIGCHLD 被忽略，4.4BSD总是产生僵死进程。如果要避免僵死进程，则必须等待子进 。程。在 SVR4 中，如果调用 signal 或 sigset 将 SIGCHLD 的配置设置为忽略，则决不会产生 ，僵死进程。本书讨论的 4 种平台在此方面都追随 SVR4 的行为。

使用 sigaction 可设置 SA_NOCLDWAIT标志（见图 10-6 ）以避免进程僵死。本书讨论的 4 :种平台都支持这一点。

（2）如果将 SIGCLD 的配置设置为捕捉，则内核立即检査是否有子进程淮备好被等待，如果 是这样，则调用 SIGCLD 处理程序。

第 2 种方式改变了为此信号编写处理程序的方法，这一点可在下面的实例中看到。

、实例

10.4节曾提到，进入信号处理程序后，首先要调用 signal 函数以重新设置此信号处理程序 （在信号被重置为其默认值时，它可能会丢失，立即重新设置可以减少此窗口时间）。图 10-6展示 了这一点。但此程序不能在某些传统的 System V平台上正常工作。程序一行行地不断重复输出 “SIGCLD received"，最后进程用完其桟空间并异常终止

\#include

tinclude

static void



"apue.h"

<sys/wait.h>

sig_cld{int);



int

main ()

{

pid_t pid;

if (signal(SIGCLD, sig_cld) == SIG_ERR) perror{"signal error"H

if ((pid = fork⑴ < 0)[ perror("fork error");

} else if (pid == 0) {    /* child */

sleep(2);

_exit (0);

}

pause (); /* parent */ exit (0};

static void

sig_cld(int signo) /* interrupts pause() */

f

pid_t    pid;

int    status;

printf {"SIGCLD received\n")

if (signal(SIGCLD, sig_cld) = SIG_ERR) /* reestablish handler */ perror("signal error");

if ((pid = wait(Sstatus)) < 0)    /* fetch child status */

perror{"wait error");

printf("pid = %d\n", pid);

图 10-6不能正常工作的 System V SIGCLD处理程序

因为基于 BSD 的系统通常并不支持早期 System V的 SIGCLD 语义，所以 FreeBSD 8.0和 Mac OS X 10.6.8并没有出现此问题。Linux 3.2.0也没有出现此问题，其原因是，虽然 SIGCLD 和 SIGCHLD定义为相同的值，但当一个进程要排捕捉 SIGCHLD，并且已经有进粒灌备好由其父进

，程等待时，该系统并不调用 SIGCHLD 信号的处理程序。Solaris 10在此种情况时确实调用读信号 j处理程序，但在内核中增加了避免此问题的代码。

I 虽然本书说明的所有 4 种平台都解决了这一问题，但是应当意识到没有解决这一问题的平台 [334]    U如 A1X）依然存在。

此程序的问题是：在信号处理程序的开始处调用 signal，按照上述第 2 种方式，内核 检查是否有需要等待的子进程（因为我们正在处理一个 SIGCLD 信号，所以确实有这种子进 程），所以它产生另一个对信号处理程序的调用。信号处理程序调用 signal，整个过程再 次重复，

为了解决这一问题，应当在调用 wait 取到子进程的终止状态后再调用 signal。此时仅当 其他子进程终止，内核才会再次产生此种信号。

;    如果为 SIGCHLD 建立了一个信号处理租序，又存在一个已终止但父进程尚未等待它的进程，

:则是否会产生信号？ POS1X.1对此没有做说明。这就允许前面所述的工作方式。但是，POS1X.1 ，在信号发生时并没有将信号处理重置为其默认值（假定正调用 POSIX.1的 sigaction 函數设置 '其釔置），于是在 SIGCHLD 处理程序中也就不必再为该信号指定一个信号处理租序。    •」

务必了解你所用的系统实现中 SIGCHLD 信号的语义。也应了解在某些系统 S工 GCHLD 为 SIGCLD 或反之。更改这种信号的名字使你可以编译为另一个系统编写的程序，但是 如果这一程序使用该信号的另一种语义，程序有可能不会正常工作。

在本书说明的 4 种平台上，只有 Linux 3.2.0和 Solaris 10定义了 SIGCLD, SIGCLD等同于 SIGCHLDo

10.8可靠信号术语和语义

我们需要先定义一些在讨论信号时会用到的术语。首先，当造成信号的事件发生时，为进程 产生一个信号（或向一个进程发送一个信号）。事件可以是硬件异常（如除以 0）、软件条件（如 alarm定时器超时）、终端产生的信号或调用 kill 函数。当一个信号产生时，内核通常在进程 表中以某种形式设置一个标志。

当对信号采取了这种动作时，我们说向进程递送了一个信号。在信号产生（generation）和递 送（delivery）之间的时间间隔内，称信号是未决的（pending）。

进程可以选用“阻塞信号递送”。如果为进程产生了一个阻塞的信号，而且对该信号的动作 是系统默认动作或捕捉该信号，则为该进程将此信号保持为未决状态，直到垓进程对此信号解除 了阻塞，或者将对此信号的动作更改为忽略。内核在递送一个原来被阻塞的信号给进程时（而不 是在产生该信号时），才决定对它的处理方式。于是进程在信号递送给它之前仍可改变対该信号

[335]的动作。进程调用 sigpending 函数（见 10.13节）来判定哪些信号是设置为阻塞并处于未决状 态的。

如果在进程解除对某个信号的阻塞之前，这种信号发生了多次，那么将如何呢？ POSIX.1允 许系统递送该信号一次或多次。如果递送该信号多次，则称这些信号进行了排队。但是除非支持 POSIX.1实时扩展，否则大多数 UNIX 并不对信号排队，而是只递送这种信号一次。

| SUSv4中，实时信号功能已经移至基础規范的实时扩展部分。随着时间的推移，更多的系统 即使不支持实时扩展，也会支持信号排队。我们将在 10.20节中进一步讨论排队信号。

1 SVR2的手册页称，在进程执行 SIGCLD 信号处理程序期间，该信号是用排队方式处理的，

虽然在概念层次这可能是真的，但实际并非如此。内核是按照 10.7节中所述方式产生此信号。SVR3

'的手册页对此做了修改，它指明在进程执行 SIGCLD 信号处理程序期间，忽略 SIGCLD 信号。SVR4 J手册页删除了有关部分。

1    AT&T[1990e]中的 SVR4sigaction（2）手册页称 SA_SIGINFO 标志（见图 10-16）使信号可

■靠地排队，这是不正确的。表面上内核部分地实现了此功能，但在 SVR4 中并不起作用。令人不

可思议的是，SVID （ System V接口定义〉对这种可靠队列并未做同样的声明。

如果有多个信号要递送给一个进程，那将如何呢？ POSK.1并没有规定这些信号的递送顺序。但 是 POSDC1 基础部分建议：在其他信号之前递送与进程当前状态有关的信号，如 SIGSEGV。

每个进程都有一个信号屏蔽字（signal mask），它规定了当前要阻塞递送到该进程的信号集。対 于每种可能的信号，该屏蔽字中都有一位与之对应。対于某种信号，若其对应位已设置，则它当前是 被阻塞的。进程可以调用 sigprocmask （在 10.12节中说明）来检测和更改其当前信号屏蔽字。

信号编号可能会超过一个整型所包含的二进制位数，因此 POSIX.1定义了一个新数据类型 sigset.t，它可以容纳一个信号集。例如，信号屏蔽字就存放在其中一个信号集中。10.11节将 说明对信号集进行操作的 5 个函数。

##### 10-9 函数 kill 和 raise

kill函数将信号发送给进程或进程组。raise函数则允许进程向自身发送信号。

raise最初是由 ISO C定义的。后来，为了与 1SOC 标准保持一致，POSIX.1也包括了该函

数。但是 POSIX.1扩展了 raise的規范，使其可处理线程（12.8中讨论线程如何与信号交互）。

因为 ISOC 并不涉及多进租，所以它不能定义以进程 ID 作为其参数（如 kill 函数）的函数。[336]

\#include <signal.h>

int kill (pid_t pid, int signo);

int raise (int signo)；

两个函数返回值：若成功，返回 0；若出错，返回-I

调用

raise（signo）;

等价于调用

kill（getpidt）, signo）; kill的 pZrf 参数有以下 4 种不同的情况。

pid>Q    将该信号发送给进程 ID 为/wW的进程。

pid=0    将该信号发送给与发送进程属于同一进程组的所有进程（这些进程的进程组 ID

等于发送进程的进程组 ID），而且发送进程具有权限向这些进程发送信号。这 里用的术语“所有进程”不包括实现定义的系统进程集。对于大多数 UNIX 系 统，系统进程集包括内核进程和 init （pid为 I）。

pid<0    将该信号发送给其进程组 ID 等于/»7/绝对值，而且发送进程具有权限向其发送

信号的所有进程。如前所述，所有进程并不包括系统进程集中的进程。

pid^-\    将该信号发送给发送进程有权限向它们发送信号的所有进程。如前所述，所有

进程不包括系统进程集中的进程。

如前所述，进程将信号发送给其他进程需要权限。超级用户可将信号发送给任一进程。对于 非超级用户，其基本规则是发送者的实际用户 1D 或有效用户 ID 必须等于接收者的实际用户 ID 或有效用户 ID。如果实现支持_POSIX_SAVED_IDS （如 POSIX.1现在要求的那样），则检査接收 者的保存设置用户 ID （而不是有效用户 ID）。在对权限进行测试时也有一个特例：如果被发送的 信号是 SIGCONT，则进程可将它发送给属于同一会话的任一其他进程。

POSIX.1将信号编号 0 定义为空信号。如果参数是 0，则 kill 仍执行正常的错误检查， 但不发送信号。这常被用来确定一个特定进程是否仍然存在。如果向一个并不存在的进程发送空 信号，则 kill 返回-1，errno被设置为 ESRCH。但是，应当注意，UNIX系统在经过一定时间

[337]后会重新使用进程 ID，所以一个现有的具有所给定进程 ID 的进程并不一定就是你所想要的进程。

还应理解的是，测试进程是否存在的操作不是原子操作。在 kill 向调用者返回测试结果时，

原来已存在的被测试进程此时可能已经终止，所以这种测试并无多大价值。

如果调用 kill 为调用进程产生信号，而且此信号是不被阻塞的，那么在 kill 返回之前，

hgno或者某个其他未决的、非阻塞信号被传送至该进程。（对于线程而言，还有一些附加条件； 详细情况见 12.8节。）

##### 10.10 函数 alarm 和 pause

使用 alarm 函数可以设置一个定时器（闹钟时间），在将来的某个时刻该定时器会超时。当 定时器超时时，产生 SIGALRM 信号。如果忽略或不捕捉此信号，则其默认动作是终止调用该 alarm函数的进程。

\#include <unistd.h>

unsigned int alarm (unsigned int seconds、••

返回值，0或以前设置的闹钟时间的余留秒数

参数 wcom*的值是产生信号 SIGALRM 需要经过的时钟秒数。当这一时刻到达时，信号由内 核产生，由于进程调度的延迟，所以进程得到控制从而能够处理该信号还需要一个时间间隔。

早期的 UNIX 系统实现曾提出警告，这种信号可能比预定值提前 Is 发送。POSIX.1则不允许 这样做。

每个进程只能有一个闹钟时间。如果在调用 alarm 时，之前己为读进程注册的闹钟时间还没有超 时，则该闹钟时间的余留值作为本次 alarm 函数调用的值返回。以前注册的闹钟时间则被新值代替。

如果有以前注册的尚未超过的闹钟时间，而且本次调用的 secwi 也值是 0，则取消以前的闹钟 时间，其余留值仍作为 alarm 函数的返回值。

虽然 SIGALRM 的默认动作是终止进程，但是大多数使用闹钟的进程捕捉此信号。如果此时 进程要终止，则在终止之前它可以执行所需的清理操作。如果我们想捕捉 SIGALRM 信号，则必 须在调用 alarm 之前安装该信号的处理程序。如果我们先调用 alarm，然后在我们能够安装

SIGALRM处理程序之前已接到该信号，那么进程将终止。 pause函数使调用进程挂起直至捕捉到一个信号。

| #include <unistd.h> |                              |
| ------------------- | ---------------------------- |
| int pause(void);    | 返回值：-1，errno设置为 EINTR |

只有执行了一个信号处理程序并从其返回时，pause才返回。在这种情况下，pause返回-1, errno设置为 E 工 NTR。

为■实例

使用 alarm 和 pause，进程可使自己休眠一段指定的时间。图 10-7中的 sleepl 函数看似 提供了这种功能(其实这里面存在问题，我们很快就会看到)。

\#include    <signal.h>

ttinclude    <unistd.h>

static void

sig_alrm(int signo)

t

/* nothing to do, just return to wake up the pause */

»

unsigned int

sleepl(unsigned int seconds)

if (signal(SIGALRM, sig_alrm) == SIG_ERR) return(seconds);

alarmfseconds)，-    /* start the timer */

pause();    /* next caught signal wakes us up */

return(alarm(O));    /* turn off timer, return unslept time */

J

图 10-7 sleep简化而不完整的实现

程序中的 sleepl 函数看起来与将在 10.19节中说明的 sleep 函数类似，但这种简单实现有 以下 3 个问题。

(1)    如果在调用 sleepl 之前，调用者已设置了闹钟，则它被 sleepl 函数中的第一次 alarm 调用擦除。可用下列方法更正这一点：检査第一次调用 alarm 的返回值，如其值小于本次调用 alarm的参数值，则只应等到已有的闹钟超时。如果之前设置的闹钟超时时间晚于本次设置值，

则在 sleepl 函数返回之前，重置此闹钟，使其在之前闹钟的设定时间再次发生超时。

(2)    该程序中修改了对 SIGALRM 的配置。如果编写了一个函数供其他函数调用，则在该函 数被调用时先要保存原配置，在该函数返回前再恢复原配置。更正这一点的方法是：保存 signal 函数的返回值，在返回前重置原配置。

(3)    在第一次调用 alarm 和 pause 之间有一个宽争条件。在一个繁忙的系统中，可能 alarm 在调用 pause 之前超时，并调用了信号处理程序。如果发生了这种情况，则在调用 pause 后，

如果没有捕捉到其他信号，调用者将永远被挂起。    [339]

sleep的早期实现与图 10-7程序类似，但更正了第 1 个和第 2 个问题。有两种方法可以更正第

3个问题。第一种方法是使用 setjmp，下一个实例将说明这种方法。另一种方法是棚 sigprocnask 和 sigsuspend，10.19节将说明这种方法。    H9

SVR2中的 sleep 实现使用了 setjmp和 longjmp （见 7.10节），以避免前一个实例的第 3 个问题中说明的竞争条件。此函数的一个简化版本称为 Sleep2，示于图 10-8中（为了缩短实例 程序的长度，程序中没有处理上面所说的第 1 个和第 2 个问题）。

\#include #include #include



<setjmp.h>

<3ignal.h>

<unistd.h>

static jmp__buf env_alrm;

static void

sig_alrm(int signo)

(

longjmp{env_alrm, 1);

unsigned int

sleep2(unsigned int seconds)

if (signal(SIGALRM, 3ig_alrm) return(seconds);



==SIG_ERR)

start the timer */

next caught signal wakes us up */

turn off timer, return unslept time */

图 10-8 sleep的另一个不完善的实现

在此函数中，已避免了图 10-7中具有的竞争条件。即使 pause 从未执行，在发生 SIGALRM 时，sleep2函数也返回。

但是，sleeP2函数中却有另一个难以察觉的问题，它涉及与其他信号的交互。如果 SIGALRM 中断了某个其他信号处理程序，则调用 longjmp 会提早终止该信号处理程序。图 10-9显示了这 种情况。SIGINT处理程序中包含了 for循环语句，它在作者所用系统上的执行时间超过 5s，也 就是大于 Sleep2 的参数值，这正是我们想要的。整型变量 k 说明为 volatile，这样就阻止了

[340]优化编译程序去除循环语句。

番 include "apue.h1

| unsigned intstatic void | sleep2(unsigned int); sig_int (int)，- |
| ----------------------- | -------------------------------------- |
| intmain(void)           |                                        |

unsigned int unslept;

if (signal(SIGINT, sig_int) == SIG_ERR) err_sys("signal(SIGINT) error");

unslept = sleep2{5);

printf("sleep2 returned: %u\n", unslept); exit (0);

}

static void

sig_int(int signo)

{

int    i, j;

volatile int    k;

\*    Tune these loops to run for more than 5 seconds

\*    on whatever system this test program is run.

*/

printf("\nsig_int starting\n");

for (i = 0; i < 300000; i++) for (j = 0; j < 4000; j++)

k += i * j;

printf("sig_int finished\n");

图 10-9在一个捕捉其他信号的程序中调用 sleeP2 执行图 10-9中的程序，可以通过键入中断字符来中断休眠，运行结果如下：

$ ./a.out

*C    键入中断字符

sig_int starting sleep2 returned: 0

从中可见 sleeP2 函数所引起的 longjmp 使另一个信号处理程序 sig_int提早终止，即使它未 完成也会如此。如果将 SVR2 的 sleep 函数与其他信号处理程序一起使用，就可能碰到这种情况， 见习题 10.3。

sleepl和 sleep2 函数的这两个实例是告诉我们在涉及信号时需要有精细而周到的考虑。下面 几节将说明解决送壁问题的方法，使我们能够可靠地、在不影响其他代码段的情况下处理信号。    [Kl

■实例

除了用来实现 sleep 函数外，alarm还常用于对可能阻塞的操作设置时间上限值。例如，

程序中有一个读低速设备的可能阻塞的操作(见 10.5节)，我们希望超过一定时间量后就停止执 行该操作。图 10-10实现了这一点，它从标准输入读一行，然后将其写到标准输出上。

\#include "apue.h"

static void sig_alrm(int);

int

main(void)

int

n?



Char    line[MAXLINE];

if (signal(SIGALRM, sig_alrm) == SIG_ERR) err_sys("signal(SIGALRM) error");

alarm{10);

if ((n = read(STDIN_FILENO, line, MAXLINE)) < 0) err_sys("read error");

alarm{0);

write(STDOUT_FILENO， line, n);

exit(0);

static void

sig_alrm(int signo)

(

/* nothing to do, just return to interrupt the read */

}

图 10-10带时间限制调用 read

这种代码序列在很多 UNIX 应用程序中都能见到，但是这种程序有两个问题：

(1)    图 10-10中的程序具有与图 10-7中的程序相同的问题：在第一次 alarm 调用和 read 调用之间有一个竞争条件。如果内核在这两个函数调用之间使进程阻塞，不能占用处理机运行， 而其时间长度又超过闹钟时间，则 read 可能永远阻塞，大多数这种类型的操作使用较长的闹钟 时间，例如 1 分钟或更长一点，使这种问题不会发生，但无论如何这是一个竞争条件。

(2)    如果系统调用是自动重启动的，则当从 SIGALRM 信号处理程序返回时，read并不被中 [342]断。在这种情形下，设置时间限制不起作用。

在这里我们确实需要中断慢速系统调用。我们将在 10.14节对此进行详细讨论。    ■穀

、实例

让我们用 longjmp 再实现前面的实例。使用这种方法无需担心一个慢速的系统调用是否被 中断，见图 10-11。

肴 include "apue.h"

\#include <setjmp.h>

static void    sig_alrm(int)；

static jmp_buf    env_alrm;

int

main(void)

{

int    n;

char    linefMAXLINE];

if (signal(SIGALRM, sig_alrra) == SIG_ERR) err_sys("signal(SIGALRM) error");

if {setjmp(env_alrm) != 0)

err_quit("read timeout");

alarm(10);

if {(n = read(STDIN_FILENO, line, MAXLINE)) < 0) err_sys("read error")；

alarm(O);

write(5TD0UT_FILEN0, line, n); exit (0);

}

static void

sig_alrm(int signo)

{

longjmp tenv_alrm, 1);

图 10-11使用 longjmp，带时间限制调用 read

不管系统是否重新启动被中断的系统调用，该程序都会如所预期的那样工作。但是要知道， 该程序仍旧有和图 10-8中的程序相同的与其他信号处理程序交互的问题。

如果要对 I/O操作设置时间限制，则如上所示可以使用 longjmp，当然也要清楚它可能有与 其他信号处理程序交互的问题。另一种选择是使用 select 或 poll 函数，14.4.1节和 14.4.2节 将对它们进行说明。

##### 10.11信号集

我们需要有一■个能表示多个信号-信号集(signal set)的数据类塑。我们将在 sigprocmask

(下一节中说明)类函数中使用这种数据类型，以便告诉内核不允许发生该信号集中的信号。如 前所述，不同的信号的编号可能超过一个整型量所包含的位数，所以一般而言，不能用整型量中 的一位代表一种信号，也就是不能用一个整型量表示信号集。POSIX.1定义数据类型 SigSet_t 以包含一个信号集，并且定义了下列 5 个处理信号集的函数。

\#include <signal.h>

int sigemptyset {sigset_t *sel);

int sigfillset (sigset_t *set、；

int sigaddset (sigset_t *set, int signo};

int sigdelset (sigset_t * set, int signo}:

4个函数返回值：若成功，返回 0:若出错，返回-1

int sigismember (const sigset_t *set, int sign。、：

返回值：若真，返回 1:若假，返回 0

函数 sigemptyset |刀始化由 se/指向的信号集，清除其中所有信号。函数 sigfillset 初 始化由 s 权指向的信号集，使其包括所有信号。所有应用程序在使用信号集前，要对该信号集调 用 sigemptyset 或 sigfillset 一次。送是因为 C 编译程序将不轼初值的外部变量和静态变 量都初始化为 0，而这是否与给定系统上信号集的实现相对应却并不清楚。

一旦已经初始化了一个信号集，以后就可在该信号集中增、删特定的信号。函数 sigaddset

将一个信号添加到己有的信号集中，sigdelset则从信号集中删除一个信号。对所有以信号集 作为参数的函数，总是以信号集地址作为向其传送的参数。

■实现

如果实现的信号数目少于一个整型量所包含的位数，则可用一位代表一个信号的方法实现信号集。 例如，本书的后续部分都假定一种实现有 31 种信号和 32 位整型。sigemptyset函数将整型设置为 0, sigfillset函数则将整型中的各位都设置为 1。这两个函数可以在<Signal.h>头文件中实现为宏：

番 define sigemptyset(ptr) ([1](#bookmark9) [2](#bookmark10)(ptr) = 0)

\#define sigfillset(ptr) ([2](#bookmark10)(ptr) = ' (sigset_t)0, 0)

注意，除了设置信号集中各位为 1 外，sigfillset必须返回 0，所以使用 C 语言的逗号算符，

[344]它将逗号算符后的值作为表达式的值返回，

使用送种实现，sigaddset开启一位(将该位设置为 1)，sigdelset则类闭一位(将该

位设置为 0): sigismember测试一个指定的位。因为没有信号编号为 0，所以从信号编号中减 1以得到要处理位的位编号数。图 10-12给出了这些函数的实现。

return(-1);

}

return((*set & (1 « (signo - 1))) != 0);

}

图 10-12 sigaddset、sigdelset 和 sigismember 的实现 也可将这 3 个函数在＜3191131.11＞中实现为各一行的宏，但是 POSIX.1要求检査信号编号参

数的有效性，如果无效则设置 errno。在宏中实现这一点比函数要难。

##### 10.12 函数 sigprocmask

10.8节曾提及一个进程的信号屏蔽字规定了当前阻塞而不能递送给该进程的信号集。调用函 数 sigprocmask 可以检测或更改，或同时进行检测和更改进程的信号屏蔽字。

\#include <signal.h>

int sigprocmask (int how, const sigset_t * restrict set, sigset_t * restrict oset) !

返回值：若成功，返回(h若出错，返回-1

首先，若是非空指针，那么进程的当前信号屏蔽字通过(W故返回，

其次，若 5 过是一个非空指针，则参数 few 指示如何修改当前信号屏蔽字。图 10-13说明了

Aow可选的值。SIG_BLOCK是或操作，而 SIG_SETMASK则是赋值操作。注意，不能阻塞 SIGKILL 和 SIGSTOP 信号。

| how         | 说明                                                         |
| ----------- | ------------------------------------------------------------ |
| SIG_BLOCK   | 该进程新的信号屏蔽字是其当前信号屏蔽字和 Jef 指向信号集的并集。包含了希 望阻塞的附加信号 |
| SIG_UNBLOCK | 该进程新的信号屏蔽字是其当前信号屏蔽字和所指向信号集补集的交集。set包 含了希望解除阻塞的信号 |
| SIG SETMASK | 该进程新的信号屏蔽是指向的值                                 |

图 10-13用 sigprocmask 更改当前信号屏蔽字的方法

如果 ser 是个空指针，则不改变该进程的信号屏蔽字，Aow的值也无意义。

在调用 sigprocmask 后如果有任何未决的、不再阻塞的信号，则在 sigprocmask 返回前，

至少将其中之一递送给该进程。

sigprocmask是仅为单线程进程定义的。处理多线程进程中信号的屏蔽使用另一个函数。

:我们将在 12.8节中对此进行讨论。

■实例

图 1CH4 程序是一个函数，它打印调用进程信号屏蔽字中的信号名＜■图 10＞20中的程序和图 10-22 中的程序将调用此函数。    [346]

sigset_t sigset; int    errno_save;

errno_save = errno?    /* we can be called by signal handlers */

if (sigprocmask(0, NULL, ssigset) < 0) {

err_ret{"sigprocmask error");

} else {

printf("%s", str); if (sigismember(Ssigset,

printf(" SIGINT"); if (sigismember(Ssigset,

printf(" SIGQUIT"); if (sigismember(&sigset,

printf(" SIGUSR1"); if (sigismember(Ssigset,

printf (" SIGALRM*');

SIGINT))

SIGQUIT)}

SIGOSR1)}

SIGALRM))



remaining signals can go here */

errno = errno_save;

)



/* restore errno */



图 10-14为进程打印信号屏蔽字

为了节省空间，没有对图 10-1中列出的每一种信号测试该屏蔽字（见习题 10.9）。

##### 10.13 函数 sigpending

sigpending函数返回一信号集，对于调用进程而言，其中的各信号是阻塞不能递送的，因 而也一定是当前未决的。该信号集通过 set 参数返回。

♦include <signal.h>

int sigpending(sigset_t *set)；

返回值：若成功，返回 0；若出错，返回-1

、实例

图 10-15展示了很多前面说明过的信号功能。

err_sys("can't catch SIGQUIT");

\* Block SIGQUIT and save current signal mask.

*/

sigemptyset(finewmask);

sigaddset(&newraask, SIGQUIT);

if (sigprocmask(SXG_BLOCK, &newmask, &oldmask) < 0) err_sys("SIG_BLOCK error");

sleep(5);    /* SIGQUIT here will remain pending */

if (sigpending(Spendmask) < 0> err_sys("sigpending error");

if (sigismember(spendmask, SIGQUIT)) printf (•’\nSIGQUIT pending\n");

\* Restore signal mask which unblocks SIGQUIT.

*/

if (sigprocmask(SIG_SETMASK, soldmask, NULL) < 0) err_sys{"SIG_SETMASK error");

printf("SIGQUIT unblocked\n");

sleep(5);    /* SIGQUIT here will terminate with core file */

exit(0);

static void

sig_quit{int signo)

{

printf("caught SIGQUIT\n");

if (signal(SIGQUIT, SIG_DFL> == SIG_ERR)

err_sys (’’can’t reset SIGQUIT");

图 10-15信号设置和 sigprocmask 实例    13481

进程阻塞 SIGQUIT 信号，保存了当前信号屏蔽字(以便以后恢复)，然后休眠 5 秒。在此期

间所产生的退出信号 SIGQUIT 都被阻塞，不递送至该进程，直到该信号不再被阻塞。在 5 秒休 眠结束后，检查该信号是否是未袂的，然后将 SIGQUIT 设置为不再阻塞。

注意，在设置 SIGQUIT 为阻塞时，我们保存了老的屏蔽字。为了解際対该信号的阻塞，用 老的屏蔽字重新设置了进程信号屏蔽字(SIG_SETMASK)o另一种方法是用 SIGJJNBLOCK 使阻 塞的信号不再阻塞。但是，应当了解如果编写一个可能由其他人使用的函数，而且需要在函数中 阻塞一个信号，则不能用 SIG_UNBLOCK简单地解除对此信号的阻塞，这是因为此函数的调用者 在调用本函数之前可能也阻塞了此信号。在这种情况下必须使用 SIG_SETMASK将信号屏蔽字恢 复为先前的值，这样也就能继续阻塞该信号。10.18节的 system 函数部分有这样的一个例子。

在休眠期间如果产生了退出信号，那么此时该信号是未决的，但是不再受阻塞|所以在 sigprocmask返回之前，它被递送到调用进程。从程序的输出中可以看到这一点：SIGQUIT处 理程序(sig^quit)中的 printf 语句先执行，然后再执行 sigprocmask 之后的 printf 语句。

然后该进程再休眠 5 秒。如果在此期间再产生退出信号，那么因为在上次捕捉到该信号时，

已将其处理方式设置为默认动作，所以这一次它就会使该进程终止，在下列输出中，当我们在终 端键入退出字符 Ctrl+\时，终端打印^\ (终端退出字符)：

? ./a.out

A\

SIGQUIT pending caught SIGQUIT SIGQUIT unblocked A\Quit(coredump)

$ ./a.out



产生信号一次｛在 5s 之内) 从 sleep 返回后 在信号处理程序中 从 sigprocmask 返回后

再次产生信号

产生信号 10 次(在 5s 之内)

SIGQUIT pending caught SIGQUIT SIGQUIT unblocked A\Quit(coredump)

只产生信号一次

再产生信号



shell发现其子进程异常终止时输出 QUIT (coredump)信息。注意，第二次运行该程序时， 在进程休眠期间使 SIGQUIT 信号产生了 10次，但是解除了对该信号的阻塞后，只向进程传送一 次 SIGQUIT。从中可以看出在此系统上没有将信号进行排队。

##### 10-14 函数 sigaction

sigaction函数的功能是检查或修改(或检查并修改)与指定信号相关联的处理动作。此函 !349j数取代了 UNIX早期版本使用的 signal 函数。在率节末尾用 sigaction 函数实现了 signal。

\#include 〈signal.h>

int sigaction (int signo, const struct sigaction *restrict act, struct sigaction *restrict oact);

返回值：若成功，返回 0:若出错。返回-1

其中，参数打 gno 是要检测或修改其具体动作的信号编号。若指针非空，则要修改其动作。 如果^指针非空，则系统经由 oact 指针返回该信号的上一个动作。此函数使用下列结构，

struct sigaction ｛

void    (*sa_handler) (int); /* addr of signal handler, */

/* or SIG_IGN, or SIG_DFL */

sigset_t sa_mask;    /* additional signals to block */

int    sa_flags;    /* signal options. Figure 10.16 */

/* alternate handler */

void (*sa_sigaction) (int, siginfo_t *, void *);

｝；

当更改信号动作时，如果 sa_handler字段包含一个信号捕捉函数的地址(不是常量 SIG_IGN或 SIG_DFL)，则 sa_mask字段说明了一个信号集，在调用该信号捕捉函数之前，这 一信号集要加到进程的信号屏蔽字中。仅当从信号捕捉函数返回时再将进程的信号屏蔽字恢复为 原先值-这样，在调用信号处理程序时就能阻塞某些信号。在信号处理程序被调用时，操作系统 建立的新信号屏蔽字包括正被递送的信号。因此保证了在处理一个给定的信号时，如果这种信号 再次发生，那么它会被阻塞到对前一个信号的处理结束为止。回忆 10.8节，若同一种信号多次发 生，通常并不将它们加入队列，所以如果在某种信号被阻塞时，它发生了 5次，那么对这神信号

解除阻塞后，其信号处理函数通常只会被调用一次（上一个例子已经说明了这种特性）。

一旦対给定的信号设置了一个动作，那么在调用 sigaction 显式地改变它之前，该设置就

一直有效。这种处理方式与早期的不可靠信号机制不同，符合 POSIX.1在这方面的要求。

act结构的 sa_flags字段指定对信号进行处理的各个选项。图 10-16详细列出了这些选项

的意义。若该标志已定义在基本 POSIX.1标准中，那么 SUS 列包含“•”：若该标志定义在基本 POSIX.1标准的 XSI 扩展中，那么该列包含“XSI”。

| 选项         | SUS  | FreeBSD Linux 8.0    3.2.0 | Mac OSX 10.6.8 | Solaris10 | 说钥                                                         |
| ------------ | ---- | -------------------------- | -------------- | --------- | ------------------------------------------------------------ |
| SA_INTERRUPT |      |                            |                |           | 由此信号中断的系统调用不自动重启 动（XSI对于 sigaction 的就认处理方 式）。详见 10.5节 |
| SA_NOCLDSTOP |      |                            |                |           | 若是 SIGCHLD，当子进程停止（作 业控制），不产生此信号。当子进程终止 时，仍旧产生此信号（但请参阅下面说 明的 SA NOCLDWAIT选项）。若已设置 此标志，则当停止的进程继续运行时，作为 XSI 扩展，不产生 SIGCHLD 信号 |
| SA_NOCLDWAIT |      |                            |                |           | 若 Wgno 是 SIGCHLD，则当调用进程 的子进程终止时。不创建僵死进程•若 调用进程随后调用 wait，则阻塞到它所 有子进程都终止，此时返回-1, errno 设置为 ECHILD （见 10.7节） |
| SA_NODEFER   |      |                            |                |           | 当捕捉到此信号时，在执行其信号捕 捉函数时，系统不自动阻塞此信号（除 非 sa mask包括了此信号）。注意，此 种类型的操作对应于早期的不可靠信号 |
| SA_ONSTACK   | XSI  | • •                        |                | •         | 若用 sigaltstack（2）已声明了一个 替换栈，则此信号递送给替换桟上的进程 |
| SA_RESETHAND |      |                            |                |           | 在此信号捕捉函数的入口处，将此信号 的处理方式重置为 SIG_DFL，井清除 SA SIGINFO标志。注意。此种类型的信 号对应于早期的不可靠信号。但是，不能 自动重置 SIGILL 和 SIGTRAP 这两个信 号的紀量。设置此禄志使 sigaction 的 行为如同设置了 SA_NODErER标志 |
| SA_RESTART   | •    | • •                        |                |           | 由此信号中断的系统调用自动重启动 （参见 10.5节）              |
| SA_SIGINFO   |      |                            |                |           | 此选项对信号处理程序提供了附加信 息：一个指向 siginfo 结构的指针以及 一个指向进程上下文标识符的指针 |

图 10-16处理每个信号的可选标志（sa_flags）

[1](#footnote1)

\#include    <signal.h>

\#include    <errno.h>

/[2](#bookmark10)

\* <signal.h> usually defines NSIG to include signal number 0.

*/

\#define SIGBAD(signo){(signo) <= 0 || (signo) >= NSIG) int

sigaddset(sigset_t [2](#bookmark10)set, int signo)

if (SIGBAD(signo)) { errno = EINVAL; return(-l);

}

[2](#footnote2)

set [= 1 << (signo - 1);    /[2](#bookmark10) turn bit on [2](#bookmark10)/

return <0);

}

int

sigdelset(sigset_t [2](#bookmark10)set, int signo)

f

if (SIGBAD(signo))    {

errno = EINVAL; return{-1)7

1

*set &= -(1 « (signo - 1));    /[2](#bookmark10) turn bit off [2](#bookmark10)/

return(0);

int

sigismember(const sigset_t [2](#bookmark10)set, int signo) {

if (SIGBAD(signo))( errno = EINVAL;

\#include "apue.h"

\#include <errno.h>

void

pr_mask(const char *str) #include "apue.h"

static void sig_quit(int);

int

main (void)

1

sigset_t newmask, oldmask, pendmask;

if (signal(SIGQUIT, sig_quit) == SIG_ERR>



sa_sigaction字段是一个替代的信号处理程序，在 sigaction 结构中使用了 SA_SIGINFO 标志时，使用该信号处理程序。对于 sa_sigaction字段和 sa_handler字段两者，实现可能 使用同一存储区，所以应用只能一次使用这两个字段中的一个=    ®

通常，按下列方式调用信号处理程序：

void handler（int signo）;

但是，如果设置了 SA_SIGINFO标志，那么按下列方式调用信号处理程序：

void handler （int signo, siginfo_t ★info, void * context）；

siginfo结构包含了信号产生原因的有关信息。该结构的大致样式如下所示。符合 POSDC1 的 所有实现必须至少包括 sijigno 和 si_COde成员。另外，符合 XSI 的实现至少应包含下列字段：

struct siginfo {

int    si_signo;

int    si_errno;

int    si_code;

pid_t    si_pid;

uid_t    si_uid;

void    *si_addr;

int    si_status;

union sigval si_value;



/* signal number */

/* if nonzero, errno value from <errno.h> */ /* additional info (depends on signal) */

/* sending process ID */

/* sending process real user ID */

/* address that caused the fault */

/* exit value or signal number */

/* application-specific value */

/* possibly other fields also */



sigval联合包含下列字段:

int sival_int； void *sival_ptr;

应用程序在递送信号时，在 si_value. sival_int中传递一个整型数或者在 si_value. sival_ptr 中传递一个指针值。

图 10-17示出了对于各种信号的 si_code值，这些信号是由 Single UNIX Specification定义 的。注意。实现可定义附加的代码值。

若信号是 SIGCHLD，则将设置 si_pid、si_status和 si_uid字段。若信号是 SIGBUS、 SIGILL、SIGFPE或 SIGSEGV，则 si_addr包含造成故障的根源地址：该地址可能并不准确。 Si_errnO字段包含错误编号，它对应于造成信号产生的条件，并由实现定义。

信号处理程序的参数是无类型指针，它可被强制类型转换为 ucontext_t结构类型, 该结构标识信号传递时进程的上下文。该结构至少包含下列字段：

ucontext_t

sigset_t

stack_t

mcontext_t



★uc_link;

uc_sigmask;

uc_stack;

uc_mcontext;



/* pointer to context resumed when */

/* this context returns */

/* signals blocked when this context */ /* is active */

/* stack used by this context */

/* machine-specific representation of */ /* saved context */



uc_stack字段描述了当前上下文使用的桟，至少包括下列成员:



void *ss_sp; size_t ss_size; int ss_flags;



/* stack base or pointer */ /* stack size */

/* flags */

351

/

353



当实现支持实时信号扩展时，用 SA_SIGINFO标志建立的信号处理程序将造成信号可靠地排 队。一些保留信号可由实时应用使用＜，如果信号由 sigqueue 函数产生，郎么 siginfo 结构能 包含应用特有的数据（参见 10.20节乂

■实例：signal函数

现在用 sigaction 实现 signal 函数。很多平台都是这样做的（POSIX.I的基础阐述部好 也说明这是 POSIX 所希望的）》另一方面，有些系统支持老的不可靠信号语义 signal 函数，

其目的是实现二进制向后兼容。除非特殊地要求老的不可靠语义（为了向后兼容），否则应当使 用下面的 signal 实现，或者直接调用 sigaction （可以在调用 sigaction 时指定 SA_RESETHAND和 SA_NODEFER选项以实现老语义的 signal 函数）＜，本书中所有调用 signal 的实例均调用图 10-18中实现的函数。

| 信号    | 代码                                                         | 原因                                                         |
| ------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| SIGILL  | ILLjLLOPCILL_ILLOPNXLL_ILLADRILL_ILLTRPILL_PRVOPCILL_PRVREGILL_COPROCILL BADSTK | 非法操作码 非法操作数 非法地址模式 非法陷入 特权操作码 特权寄存器 协处理器出错 内部栈出错 |
| SIGFPE  | FPE_INTDIVFPE_INTOVFFPE_FLTDIVFPE_FLTOVFFPE_FLTUNDFPE_FLTRESFPE_FLTINVFPE FLTSUB | 整数除以 0 整数溢出 浮点除以 0 浮点向上溢出 浮点向下溢出 浮点不精确结果 无效浮点操作 下标超出范围 |
| SIGSEGV | SEGV_MAPERRSEGV ACCERR                                       | 地址不映射至对象 对于映射对象的无效权限                      |
| SIGBUS  | BUS_ADRALNBUS_ADRERRBUS OBJERR                               | 无效地址对齐 不存在的物理地址 对象特定硬件错                 |
| SIGTRAP | TRAP_BRKPTTRAP TRACE                                         | 进程断点陷入 进程跟踪陷入                                    |
| SIGCHLD | CLD_EXITEDCLD^KILLEDCLD_DUMPEDCLD_TRAPPEDCLD_STOPPEDCLD CONTINUED | 子进程已终止子进程已异常终止（无 core）子进程已异常终止（有 core）被跟踪子进程已陷入 子进程已停止停止的子进程已继续 |
| Any     | SI_USERSI_QUEUESI_TIMERSI_ASYNCIOSI MESGQ                    | kill发送的信号 sigqueue发送的信号 tiraer_settime设置的定时器超时（实时扩展） 异步 I/O淸求完成（实时扩展）—条消息到达消息队列（实时扩展） |

图 10-17 siginfo_t 代码值

\#include "apue.h"

/* Reliable version of signal。，using POSIX sigaction (). Sigfunc *

signal(int signo, Sigfunc *func)

(

struct sigaction act, oact;

act.sa_handler = func; sigemptyset(&act.sa_mask); act.sa_flags = 0;

if (signo == SIGALRM) 1 #ifdef SA_INTERRUPT

act.sa_flags 1= SA_INTERRUPt；

ttendif

} else {

act.sa_flags I= sa_restart；

}

if {sigaction(signo, Sact, Soact) < 0} return (SIG_ERR);

return(oact.sa_handler);

J

图 1048 用 sigaction 实现的 signal 国数

注意，必须用 sigemptyset 函数初始化 act 结构的 sa_mask成员。不能保证 act.sa_mask=0 会做同样的事情。

对除 SIGALRM 以外的所有信号，我们都有意尝试设置 SA_RESTART标志，于是被这些信号 中断的系统调用都能自动重启动。不希望重启动由 SIGALRM 信号中断的系统调用的原因是：我 们希望対 I/O操作可以设置时间限制（请回忆有关图 10-10的讨论）。

某些早期系统（如 SunOS）定义了 SA_INTERRUPT标志。这些系统的默认方式是重新启动 被中断的系统调用，而指定此标志则使系统调用被中断后不再重启动。Linux定义 SA_INTERRUPT 标志，以便与使用该标志的应用程序兼容。但是，如若信号处理程序是用 sigaction 设置的， 那么其默认方式是不重新启动系统调用。Single UNIX Specification的 XSI 扩展规定，除非说明了

[5^1 SA_RESTART标志，否则 sigaction 函数不再重启动被中断的系统调用。

曬实例：signal_intr函数

圈 10-19给出的是 signal 函数的另一种版本，它力图阻止被中断的系统调用重启动。

\#include "apue.h"

Sigfunc *

signal_intr（int signo, Sigfunc *func）

{

struct sigaction act, oact;

act.sa_handler = func; sigemptyset(&act.sa_mask); act.sa_flags = 0;

\# i fdef SA_INTERRU PT

ct.sa_flags |= SA_INTERRUPT;

\#endif

if (sigaction(signo, &act, &oact> < 0} return(SXG_ERR);

return(oact.sa_handler);

}

图 10-19 signal_intr 函数

如果系统定义了 SA_INTERRUPT标志，那么为了提髙可移植性，我们在 sa_flags中增加 该标志，这样也就阻止了被中断的系统调用的重启动。

##### 10-15 函数 sigsetj呼和 sxglongjmp

7.10节说明了用于非局部转移的 setjmp 和 longjmp 函数。在信号处理程序中经常调用 longjmp函数以返回到程序的主循环中，而不是从该处理程序返回。图 10-8和图 10-11中已经出 现了这种情况 D

但是，调用 longjmp 有一个问题。当捕捉到一个信号时，进入信号捕捉函数，此时当前信号 被自动地加到进程的信号屏蔽字中。这阻止了后来产生的这种信号中断诶信号处理程序。如果用 lcmgjmp跳出信号处理程序，那么，对此进程的信号屏蔽字会发生什么呢？

在 FreeBSD 8.0和 Mac OS X 10.6.8中，setjmp和 longjmp 保存和恢复信号屏蔽字。但是，

]Linux 3.2.0和 Solaris 10并不执行这种操作，虽然 Linux 支持提供 BSD 行为的选项。FreeBSD 8.0 j和 Mac OS X 10.6.8提供函数_56七 jmp *_longjmp，它 4 门也不保存和恢复信号昇获字。

为了允许两种艰式并存，POSIX.1并没有指定 setjmp 和 longjmp 对■信号屏蔽字的作用，

而是定义了两个新函数 sigsetjmp 和 siglongjmp。在信号处理程序中进行非局部转務时应当 使用这两个函数。    [355]

\#include <setjmp.h>

int sigset jmp (sigjmp_buf env, int savemask);

返回值：若直接调用，返回 0:若从 siglongjmp 调用返回，则返回非 0

void siglongjmp (sigjmp buf e”v, int vg/>;

这两个函数和 setjmp、longjmp之间的唯一区别是 sigsetjmp 增加了一个参数。如果 似 vewosi 非 0，则 sigset jmp在 env 中保存进程的当前信号屏蔽字。调用 siglongjmp 时，如果带 非 0 savemast的 sigsetjmp 调用已经保存了 env，则 siglongjmp 从其中恢复保存的信号屏蔽字。

实例

图 10-20中的程序演示了在信号处理程序被调用时，系统所设置的信号屏蔽字如何自动地包 括刚被捕捉到的信号。此程序也示例说明了如何使用 sigsetjmp 和 siglongjmp 函数。

\#include "apue.h"

\#include <setjmp.h>

\#include <time.h>

static void

sig_usrl(int); sig_alrm(int); jmpbuf ; canjump;



static void

static sigjmp_buf

static volatile sig_atomic_t int

main(void)

{

if {signal(SIGUSR1, sig_usrl) == SIG_ERR) err_sys ("signal {SXGUSR1) error")，-

if (signal(SIGALRM, sig_alrm) == SIG_ERR> err_sys("signal(SIGALRM) error");

pr^mask("starting main: ");    /* Figure 10,14 */

if (sigsetjmp(jmpbuf, 1)) {

pr_mask("ending main:");

exit (0);

can jump = 1;    /* now sigsetjmpO is OK */

for (;;) pause ();

i

13561 static void

sig_usrl(int signo)

{

time_t starttime;

if {canjump == 0)

return;    /* unexpected signal, ignore */

pr_mask("starting sig_usrl:");

alarm(3);    /* SIGALRM in 3 seconds */

starttime = time(NULL);

for ( ; ; )    /* busy wait for 5 seconds */

if {time(NULL) > starttime + 5,

break;

pr_mask ("finishing sig__usrl:");

canjump = 0;

siglongjmp(jmpbuf, 1);" jump back to main, don't return */

static void

sig_alrm(int signo)

{

pr_mask("in sig_alrm:

图 10-20 信号屏蔽、sigsetjmp 和 siglongjmp 实例 此程序演示了另一种技术，只要在信号处理程序中调用 siglongjmp 就应使用这种技木。

仅在调用 sigsetjmp 之后才将变量 canjump 设置为非 0 值。在信号处理程序中检测此变量， 仅当它为非 0 值时才调用 siglongjmp。这提供了一种保护机制，使得在 jmpbuf （跳转缓冲） 尚未由 sigsetjmp 初始化时，防止调用信号处理程序。（在本程序中，siglongjmp之后程序 很快就结束，但是在较大的程序中，在 siglongjmp 之后的较长一段时间内，信号处理程序可 能仍旧被设置乂在一般的 C 代码中（不是信号处理程序），对于 longjmp 并不需要这种保护措 施。但是，因为信号可能在任何时候发生，所以在信号处理程序中，需要这种保护措施。

在程序中使用了数据类型 sig_^tOmic_t，这是由 ISO C标准定义的变量类型，在写这种类 型变量时不会被中断。这意味着在具有虚拟存储器的系统上，这种变量不会跨越页边界，可以用 一条机器指令对其进行访问。这种类型的变量总是包括 ISO 类型修饰符 volatile，其原因是：该 变量将由两个不同的控制线程~main函数和异步执行的信号处理程序访问。图 10-21显示了此 程序的执行时间顺序。可将图 10-21分成三部分：左面部分（对应于 main），中间部分（sig_usrl）

和右面部分（sig_alrm）o在进程执行左面部分时，信号屏蔽字是 0 （没有信号是阻塞的）。而执 行中间部分时，其信号屏蔽字是 SIGUSR1。执行右面部分时，信号屏蔽字是 SIGUSR1 I SIGALRM。

r^n    固



signal(} signal() pr_mask()

slgset } pause()

SIGUSR1 递送



sig_usrl



pr mask() alarm (j time{) time() t.iine()



SIGALBH 递送



从信号处理程序中返回



8ig alrra I

pr_mask() return{)



sigsetjmp() PrekitS(k)(}



pr mask() Bxglbngjmp()



图 10-21处理两个信号的实例程序的时间顺序 执行图 10-20程序，得到下面的输出：



$ ./a.out 6

starting main:

[1]    531

$ kill -USR1 531

starting sig_usrl: SIGUSR1 $ in sig_alrm: SIGOSR1 SIGALRM finishing sig_usrl: SIGUSR1 ending main:



在后台启动进程

作业控制 shell 打印其进程 tD 向该进程发送 SIGUSR1



键入回车



[1] + Done



./a.out &



该输出与我们所期望的相同：当调用一个信号处理程序时，被捕捉到的信号加到进程的当前信号 屏蔽字中。当从信号处理程序返回时，恢复原来的屏蔽字。另外，siglongjmp恢复了由 sigset jmp所保存的信号屏蔽字。

如果在 Linux 中将图 10-20程序中的 sigsetjmp 和 siglongjmp 好别替换成 setjmp 和 long jmp （在 FreeBSD 中，则替换成_361: jmp和_10叫：）11^），则最后一行输出变成：

ending main: SIGUSR1

这意味着在调用 setjmp 之后执行 main 函数时，其 SIGUSR1 是阻塞的。这多半不是我们所 希望的。    ■"* S58]

##### 10.16 函数 sigsuspend

上面已经说明，更改进程的信号屏蔽字可以阻塞所选择的信号，或解除对它们的阻塞。使用这种 技术可以保护不希望由信号中断的代码临界区。如果希望对一个信号解除阻塞，然后 pause 以等待 以前被阻塞的信号发生，则又将如何呢？假定信号是 SIGINT，实现这一点的一种不正确的方法是：

sigset_t newmask, oldmask; sigemptyset (finewmask) sigaddset{&newmask, SIGINT)；

/* block SIGINT and save current signal mask */ if (sigprocmask(SIG_BLOCK, Snewmask, Soldmask) < 0)

err_sys("SXG_BLOCK error");

/* critical region of code */

/* restore signal mask, which unblocks SIGINT */ if (sigprocmask(SIG—SETMASK, Soldmask, NULL) < 0)

err^sys("SIG_SETMASK error");

/* window is open */

pause();    /* wait for signal to occur */

/* continue processing */

如果在信号阻塞时，产生了信号，那么该信号的传递就被推迟直到对它解除了阻塞。对应用 程序而言，该信号好像发生在解除对 SIGINT 的阻塞和 pause 之间(取决于内核如何实现信号)、 如果发生了这种情况，或者如果在解除阻塞时刻和 pause 之间确实发生了信号，那么就会产生 问题。因为可能不会再见到该信号，所以从这种意义上讲，在此时间窗口中发生的信号丢失了， 这样就使得 pause 永远阻塞。这是早期的不可靠信号机制的另一个问题。

为了纠正此问题，需要在一个原子操作中先恢复信号屏蔽字，然后使进程休眠。这种功能是 由 sigsuspend 函数所提供的-

♦include <signal.h>

int sigsuspend (const sigset_t *sigmask);

返回值：-1.并将 errno 设置为 EINTR

进程的信号屏蔽字设置为由 5 初《0^指向的值。在捕捉到一个信号或发生了一个会终止该进 程的信号之前，该进程被挂起。如果捕捉到一个信号而且从该信号处理程序返回，则 sigsuspend 返回，并且该进程的信号屏蔽字设置为调用 sigsuspend 之前的值。

注意，此函数没有成功返回值。如果它返回到调用者，则总是返回-1，并将 errno 设置为 [359] eintr (表示一个被中断的系统调用)。

■实例

图 10-22显示了保护代码临界区，使其不被特定信号中断的正确方法。 番 include "apue.h"

static void sig_int(int);

int

main{void)

sigset_t newmask, oldmask, waitmask;

pr_mask("program start:");

if (signal(SIGINT, sig_int) == SIG_ERR) err_sys("signal(SIGINT) error");

sigemptyset(&waitmask); sigaddset(Swaitmask, SIGUSRl); sigemptyset(&newmask); sigaddset(finewmask, SIGINTJ;

/*

\*    Block SIGINT and save current signal mask.

*/

if {sigprocmask(SIG_BLOCK, &newma3k, &oldmask) < 0) err_sys (，，SIG_BLOCK error");

Z*

\*    Critical region of code.

*/

pr_mask("in critical region:");

/*

\*    Pause, allowing all signals except SIGUSRl.

*/

if (sigsuspend(Swaitmask) != -1) err_sys("sigsuspend error");

pr_mask("after return from sigsuspend:");

/*

\*    Reset signal mask which unblocks SIGINT.

*/

if (sigprocmask(SIG_SETMASK, &oldmask, NULL) < 0) err_sys{"SIG_SETMASK error")?

\*    And continue processing ...

*/

pr__mask ("program exit:");

exit(0);

1

static void

sig_int(int signo)

{

pr_mask("\nin sig_int:

J_

图 10-22保护临界区不被信号中断    胃］

注意，当 sigsuspend 返回时，忘将信号屏蔽字设置为调用它之前的值。在本例中，SIGINT

信号将被阻塞=因此将信号屏蔽恢复为之前保存的值(oldnask)。

运行图 10-22中的程序得到下面的输出，

$ ./a.out

program start:

in critical region: SIGINT

AC    键入中断字符

in sig.int: SIGINT SIGUSR1

after return from sigsuspend: SIGINT

program exit:

在调用 sigsuspend 时，将 SIGUSRI 信号加到了进程信号屏蔽字中，所以当运行该信号处理程 序时，我们得知信号屏蔽字已经改变了。从中可见，在 sigsxispend 返回时，它将信号屏蔽字 恢复为调用它之前的值。

■实例

sigsuspend的另一种应用是等待一个信号处理程序设置一个全局变量。图 10-23中的程序 用于捕捉中断信号和退出信号，但是希望仅当捕捉到退出信号时，才唤醒主例程。 tinclude "apue.h"

volatile sig_atomic_t quitflag;    /* set nonzero by signal handler */

static void

sig_inC(int signo) /* one signal handler for SIGINT and SIGQUIT */

{

if {signo == SIGINT)

printf("\ninterrupt\nn);

else if (signo == SIGQUIT)

quitflag = 1; /* set flag for main loop */

int

main(void)

{

sigset_t newmask, oldmask, zeromask;

if (signal(SIGINT, sig_int) == SIG—ERR) err_sys("signal(SIGINT) error”)；

if (signal(SIGQUIT, sig_int) == SIG_ERR) err_sys("signal(SIGQUIT) error");

sigemptyset(Szeromask); sigemptyset (SnewmasJc); sigaddset(Snewmask, SIGQUIT};

/*

\* Block SIGQUIT and save current signal mask.

*/

if (sigprocmask(SIG_BLOCK, snewmask, &oldmask) < 0) err_sys{"SIG_BLOCK error");

while (quitflag == 0)

sigsuspend《&zeromask);

\*    SIGQUIT has been caught and is now blocked; do whatever */

quitflag = 0;

/*

\*    Reset signal mask which unblocks SIGQUIT.

*/

if (sigprocmask(SIG_SETMASK, &oldmask, NULL) < 0) err_sys("SIG_SETMASK error");

exit(0);

图 10-23用 sigsuspend 等待一个全局变量被设置

此程序的样本输出是：

$ ./a.out

*C    键入中断字符

interrupt

*c    再次键入中断字符

interrupt

*C    再一次

interrupt

*\ $    用退出符终止

■葑

考虑到支持 ISO C的非 POSIX 系统与 POSIX 系统两者之间的可移植性，在一个信号处理程 序中唯一应当做的是为 sig_atomic_t类型的变量蛾一个值。POSK.1规定得更多一些，它详细

:说明了在一个信号处理程序中可以安全地调用的函数列表(见图 1(M)，但是如果这样来编写代码，

则它们可能不会正确地在非 POSEX 系统上运行。

、实例

可以用信号实现父、子进程之间的同步，这是信号应用的另一个实例。图 10-24给出了 8.9 节中提到的 5 个例程的实现，它们是 TELLWA 工 T、TELL_PARENT、TELL„CHILD> WAXT_PARENT 和 WAIT_CHILD=,    13621

\#include "apue-h"

static volatile sig_atomic_t sigflag; /* set nonzero by sig handler */ static sigset_t newmask, oldmask, zeroroask;

static void

sig_usr(int signo) /* one signal handler for SIGUSRl and SIGUSR2 */

t

sigflag = 1;

void

TELL_WAIT(void)

{

if (signal(SIGUSRl, sig_usr) == SIG_ERR) err_sys("signal(SIGUSRl) error");

if {signal(SIGUSR2, sig_usr) == SIG_ERR) err_sys{"signal(SIGUSR2) error");

sigemptyset(fizeromask); sigemptyset(&newmask); sigaddset(&newmask, SIGUSRl)； sigaddset(Snewmask, SIGUSR2);

/* Block SIGUSRl and SIGDSR2, and save current signal mask */ if (sigprocmask(SIG_BLOCK# &newmask, &oldmask) < 0)

err_sys("SIG_BLOCK error");

}

void

TELL_PARENT(pid_t pid)

kill(pid, SIGUSR2);    /* tell parent we're done */

}

void

WAIT_PARENT(void)

while (sigflag == 0)

sigsuspend(&zeromask); /* and wait for parent */ sigflag = 0;

/* Reset signal mask to original value */ if (sigprocmask(SIG_SETMASK, &oldmask, NULL) < 0)

err_sys<MSIG_SETMASK error");

void

TELL_CHILD(pid_t pid)

kill(pid, SIGUSRl);    /* tell child we're done */

void

| 363 | WAIT_CHILD(void)

{

while (sigflag == 0)

sigsuspend(fizeromask) ; /* and wait for child */ sigflag = 0；

/* Reset signal mask to original value */ if (sigprocmask(SIG_SETMASK, Soldmask, NOLL) < 0)

err_sys("SIG_SETMASK error");

图 10-24父子进程可用来实现同歩的例程

其中使用了两个用户定义的信号：SIGUSRl由父进程发送给子进程，SIGUSR2由子进程发 送给父进程。图 15-7显示了使用管道的这 5 个函数的另一种实现。

如果在等待信号发生时希望去休眠，则使用 sigsuspend 函数是非常适当的（正如在前面 两个例子中所示），但是如果在等待信号期间希望调用其他系统函数，那么将会怎样呢？遗憾的

是，在单线程环境下对此问题没有妥善的解决方法。如果可以使用多线程，则可专门安排一个线 程处理信号(见 12.8节中的讨论)。

如果不使用线程，那么我们能尽力做到最好的是，当信号发生时，在信号捕捉程序中对一个 全局变量置 1。例如，若我们捕捉 SIGINT 和 SIGALRM 这两种信号，并用 signal_intr函数 设置这两个信号的处理程序，使得它们中断任一被阻塞的慢速系统调用。当进程阻塞在调用 read 函数等待慢速设备输入时，很可能发生这两种信号(如果设置闹钟以阻止永远等待输入，那么対 于 SIGALRM 信号，这种情况尤其会发生)。处理这种问题的代码类似于下面所示：

if (intr_flag)    /* flag set by our SIGINT handler */

handle_intr();

if (alrm_flag)    /* flag set by our SIGALRM handler */

handle_alrm();

/* signals occurring in here are lost */ while (read( ... ) < 0) {

if (errno == EINTR) { if (alrm_flag)

handle_alrm(); else if (intr_flag)

handle_intr();

} else {

/* some other error */

}

} else if (n == 0J {

/* end of file */

} else {

/* process input */

1    1364|

在调用 read 之前测试各全局标志，如果 read 返回一■个中断的系统调用错误，则再次进行 测试。如果在前两个 if 语句和后随的 read 调用之间捕捉到两个信号中的任意一个，则问题就 发生了。正如代码中的注释所指出的，在此处发生的信号丢失了。调用信号处理程序，它们设置 了相应的全局变量，但是 read 决不会返回(除非某些数据已准备好可读)。

我们希望实现下列操作步骤。

(1)    阻塞 SIGINT 和 SIGALRM。

(2)    测试两个全局变量以判别是否发生了一个信号，如果已发生则对此进行处理。

(3)    调用 read (或任何其他系统函数)并解除对这两个信号的阻塞，这两个操作应当是一 个原子操作。

仅当第(3〉步是 pause 操作时，sigsuspend函数才能帮助我们。

##### 10-17 函数 abort

前面己提及 abort 函数的功能是使程序异常终止。

| #include <stdlib.h> |                |
| ------------------- | -------------- |
| void abort(void);   | 此函数不返回值 |

此函数将 SIGABRT 信号发送给调用进程(进程不应忽略此信号)。ISOC规定，调用 abort

将向主机环境递送一个未成功终止的通知，其方法是调用 raise （SIGABRT）函数。

ISO C要求若捕捉到此信号而且相应信号处理程序返回，abort仍不会返回到其调用者。如

果捕捉到此信号，则信号处理程序不能返回的唯一方法是它调用 exit、_exit、_Exit、longjmp 或 siglongjmp （10.15 节讨论了 longjmp 和 siglongjmp 之间的区别）。POSK.1 也说明 abort 并不理会进程对此信号的阻塞和忽略。

让进程捕捉 SIGABRT 的意图是：在进程终止之前由其执行所需的清理操作。如果进程并不 在信号处理程序中终止自己，POSK.1声明当信号处理程序返回时，abort终止该进程。

ISO C针对此函数的规范将下列问题留由实现决定：是否要冲洗输出流以及是否要删除临时 文件（见 5.13节）。POSIX.1的要求则更进一步，它要求如果 abort 调用终止进程，则它对所 有打开标准 I/O流的效果应当与进程终止前对每个流调用 fclose 相同。

System V的早期版本中，abort函数产生 SIGIOT 信号。更进一步，进程忽略此信号或者捕 ®    捉它并从信号处理程序返回，这都是可能的，在返回情况下，abort返回到它的调用者。

4.3BSD产生 SIGILL 信号。在此之前，该函数解除对此信号的阻塞，将其配置恢复为 SIG_DFL （终止并创建 core 文件）。这阻止一个进程忽略或捕捉此信号。

历史上，abort的各种实现在如何处理标准 I/O流方面是并不相同的。对于保护性的程序设 :计以及为提高可移植性，如果希望冲洗标准 I/O流，则在调用 abort 之前要执行这种操作。在 :err_dump函数中实现了这一点（见附彔 B）。

因为大多数 UNIX 系统 tmpfile （临时文件）的实现在创建该文件之后立即调用 unlink, 所以 ISO C关于临时丈件的警告通常与我们无关。

图 10-25中的 abort 函数是按 POSIX.1说明实现的。

♦include <signal.h> #include <stdio.h>

\#include <stdlib.h> ♦include <unistd.h>

void

/* POSIX-style abort() function */



mask;

action;



abort(void)

i

sigset_t

struct sigaction

/* Caller can't ignore SIGABRT, if so reset to default */ sigaction(SIGABRT, NULL, Saction);

(action.sa_handler == SIG_IGN) { action.sa_handler = SIG_DFL; sigaction(SIGABRT, faction, NULL);



if



}

if



(action.sa_handler == SIG_DFL)

fflush(NULL);    /* flush all open stdio streams */

/* Caller can't block SIGABRT; make sure it’s unblocked */ sigfillset(&mask);

sigdelset(&mask, SIGABRT" /* mask has only SIGABRT turned off */

sigprocmask(SIG_SETMASK, &mask, NULL);

kill(getpidf), SIGABRT);    /* send the signal */

/* If we're here, process caught SIGABRT and returned */ fflush(NULL);    /* flush all open stdio streams */

action.sa_handler = SIG_DFL;

sigaction(SIGABRT, Saction, NULL};    /* reset to default */

sigprocmask(SIG_SETMASK, Smask, NULL);    /* just in case ... */

kill (getpid() , SIGABRT)，-    /* and one more time */

exit(1); /* this should never be executed ... */

J_

图 10-25 abort 的 POSIX.l 实现    1刪

首先査看是否将执行默认动作，若是则冲洗所有标准 I/O流。这并不等价于对所有打开的流

调用 fclose (因为只冲洗，并不关闭它们)，但是当进程终止时，系统会关闭所有打开的文件。

如果进程捕捉此信号并返回，那么因为进程可能产生了更多的输出，所以再一次冲洗所有的流。

不进行冲洗处理的唯一条件是如果进程捕捉此信号，然后调在这种情况下，

任何未冲洗的内存中的标准 I/O缓存都被丢弃。我们假定捕捉此信号，而且_exit的调 用者并不想要冲洗缓冲区。

回忆 10.9节，如果调用 kill 使其为调用者产生信号，并且如果该信号是不被阻塞的(图 10-25 中的程序保证做到这一点)，则在 kill 返回前读信号(或某个未决、未阻塞的信号)就被传送给 了该进程。哉们阻塞除 SIGABRT 外的所有信号，这样就可知如果对 kill 的调用返回了，则该 进程一定已捕捉到该信号，并且也从该信号处理程序返回。

##### 10-18 函数 system

8.13节已经有了一个 system 函数的实现，但是该版本并不执行任何信号处理。POSIX.l要 求 system 忽略 S1GINT 和 SIGQUIT，阻塞 SIGCHLD。在给出一个正确地处理这些信号的一个 版本之前，先说明为什么要考虑信号处理。

、实例

图 10-26中的程序使用 8.13节中的 system 版本，用其调用 ed(l)编辑器。(ed编辑器很久 以来就是 UNIX 的组成部分。在这里使用它的原因是：它是捕捉中断和退出信号的交互式程序。 若从 shell 调用 ed，并键入中断字符，则它捕捉中断信号并打印问号。ed程序对退出信号的处理 方式设置为忽略。)

图 10-26中的程序用于捕捉 SIGINT 和 SIGCHLD 信号。若调用它则可得：

5 ./a.out

a    将正文追加至编辑器缓冲区

Here is one line of text

.    行首的点停止追加方式

l,$p    打印缓冲 K 中的第一行至最后一行，以便观察其内容

Here is one line of text w temp.foo    将缓冲 E 写至一文件

25    编辑器称写了 25个字节

q    离开编辑器

caught SIGCHLD

当编辑器终止时，系统向父进程（a.out进程）发送 SIGCHLD 信号。父进程捕捉它，执行其处 理程序 sig_chid，然后从信号处理程序返回。但是若父进程正捕捉 SIGCHLD 信号（因为它创

[367]建了子进程，所以应当这样做以便了解它的子进程在何时终止），那么正在执行 system 函数时， 应当阻塞对父进程递送 SIGCHLD 信号。实际上，选就是 POSIX.1所说明的。否则，当 system 创 建的子进程结束时，system的调用者可能错误地认为，它自己的一个子进程结束了。于是，调 用者将会调用一种 wait 函数以获得子进程的终止状态，这样就阻止了 system函数获得子进程 的终止状态，并将其作为它的返回值。

\#include "apue.h" static void

sig_int(int signo)

(

printf("caught SIGINT\n");

static void

sig_chld(int signo)

printf("caught SIGCHLD\n");

} int

main(void)

{

if (signal{SIGINT, sig_int) == SIG_ERR) err_sys("signal(SIGINT) error");

if (signal(SIGCHLD, sig_chld) == SIG_ERR) err_sys("signal(SIGCHLD) error");

if (system("/bin/ed") < 0)

err_sys ["systemO error");

exit{0);

图 10-26用 syetem 调用 ed 编辑器

如果再次执行该程序，在这次运行时将一个中断信号传送给编辑器，则可得:

$ ./a.out

a

hello, world

1,$P

hello, world

w temp.foo

13

AC

•9

caught SIGINT

q

caught SIGCHLD



将正文追加至编辑器缓冲区

行首的点停止追加方式

打印缓冲区中的第一行至最后一行，以便观察其内容

将缓冲区写至一文件

编辑器称写了 13个字节

键入中断符

编辑器捕捉信号，打印问号

父进程执行同一操作

离开编辑器

回忆 9.6节可知，键入中断字符可使中断信号传送给前台进程组中的所有进程。图 10-27展示了编

辑器正在运行时的各个进程的关系。

图 10-27图 10-26程序运行时的前台和后台进程组 在这一实例中，SIGINT被送给 3 个前台进程（shell进程忽略此信号）。从输出中可见，a.out

进程和 ed 进程捕捉该信号。但是，当用 system 运行另一个程序时，不应使父、子进程两者都 捕捉终端产生的两个信号：中断和退出。这两个信号只应发送给正在运行的程序：子进程。因为 由 system 执行的命令可能是交互式命令（如本例中的 ed），以及因为 system 的调用者在程序 执行时放弃了控制，等待该执行程序的结束，所以 system 的调用者就不应接收这两个终端产生 的信号。这就是为什么 POSIX.1规定 system 的调用者在等待命令完成时应当忽略这两个信号 的原因。

图 10-28中的程序是 system 函数的另一个实现，它进行了所要求的信号处理。

^include

ttinclude

^include

\#include



<sys/wait.h> <errno.h> <signal.h> <unistd.h>

int

system(const char *cmdstring)    /* with appropriate signal handling */

{

pid_t    pid;

int    status;

struct    sigact土 on    ignore,    saveintr,    savequit；

sigset_t    chldmask,    savemask;

if (cmdstring == NULL)

return ⑴；    /* always a command processor with UNIX */

ignore.sa_handler = SIG_IGN; /* ignore SIGINT and SIGQUIT */

sigemptyset(Signore.sa_mask);

[369]



ignore.sa_flags = 0;

if (sigaction(SIGINT, Signore, &saveintr) < 0) return(-1);

if (sigaction(SIGQUIT, signore, Ssavequit) < 0) return(-1);

sigemptyset(schldmask);    /* now block SIGCHLD */

sigaddset(schldmask, SIGCHLD);

if (sigprocraask(SIG_BLOCK, &chldmask, Ssavemask) < 0) return (-1) '•

if ((pid = fork()) < 0)(

status = -1;    /* probably out of processes */

} else if (pid == 0) {    /* child */

/* restore previous signal actions & reset signal mask */ sigaction(SIGINT, Ssaveintr, NULL);

sigaction(SIGQUIT, ssavequit, NULL); sigprocmask(SIG„SETMASK, Ssavemask, NULL);

execl("/bin/sh", "sh", "-c", cmdstring, (char *)0);

_exit(127)；    /* exec error */

} else {    /* parent */

while (waitpid(pid, &status, 0) < 0)

if {errno != EINTR} {

status = -1; /* error other than EINTR from waitpid() */ break;

1

}

/* restore previous signal actions & reset signal mask */ if (sigaction(SIGINT, &saveintr, NULL) < 0)

return(-1);

if (sigaction(SIGQUIT, Ssavequit, NULL) < 0) return(-1);

if (sigprocmask(SIG_SETMASK, Ssavemask, NULL) < 0) return(-1J;

return(status);

图 10-28 system函数的 POSIX.1正确实现

如果将图 10-26中的程序与 system 函数的这一实现相链接，那么所产生的二进制代码与上 一个有缺陷的程序相比较，存在如下差别。

(1)    当我们键入中断字符或退出字符时，不向调用进程发送信号。

(2)    当 ed 命令终止时，不向调用进程发送 SIGCHLD 信号。作为替代，在程序末尾的 sigprocmask调用对 SIGCHLD 信号解除阻塞之前，SIGCHLD信号一直被阻塞。而对

® sigprocmask函数的这一次调用是在 system 函数调用 waitpid 获取子进程的终止状态之后。

! POS1X.1说明，在 SIGCHLD 未决期间，如若 wait 或 waitpid 返回了子进程的状悉，那么 ；SIGCHLD信号不应递送给该父进程，除非另一个子进程的状态也可用。FreeBSD 8.0、Mac OS X

10.6.8和 Solaris 10都实现了这种语义，而 Linux 3.2.0没有实现这种语义，在 system 函数调用了 waitpid后，SIGCHLD保持为未决；当解除了对此信号的阻塞后，它被递送至调用者。如果我

1们在图 10-26的 sig_chld函数中调用 wait, Linux系统将返回-1，并将 errno 设置为 ECHILD, 因为 system 曲数已取到子进程的终止状态。

很多较早的书中使用下列程序段，它忽略中断和退出信号：

if { {pid = fork()) < 0) {

err_sys("fork error");

}else if (pid == 0) {

/* child */ execl(...)；

_exit(127);

/* parent */

old_intr = signal(SIGINT, SIG_IGN); old_quit = signal(SIGQUIT, SIG_IGN);

waitpid(pid, fistatus, 0) signal(SIGINT, old_intr); signal (SIGQUIT, old_quit)，-

这段代码的问题是：在 fork 之后不能保证父进程述是子进程先运行。如果子进程先运行， 父进程在一段时间后再运行，那么在父进程将中断信号的处理更改为忽略之前，就可能产生这种 信号。由于这种原因，图 10-28中在 fork 之前就改变对该信号的配置。

注意，子进程在调用 execl 之前要先恢复这两个信号的处理。如同 8.10节中所说明的一样， 这就允许在调用者配置的基础上，execl可将它们的配置更改为默认值。 system的返回值

注意 system 的返回值，它是 shell 的终止状态，但 shell 的终止状态并不总是执行命令字符串进 程的终止状态。图 8-23中有一堅例子，其结果正是我们所期望的。如果执行一条如 date 那样的简 单命令，其终止状态是 0。执行 shell 命令 exit 44，则得终止状态 44。在信号方面又如何呢？

运行图 8-24程序，并向正在执行的命令发送一些信号：

$ tsys "sloep 30"

ACnormal termination, exit status = 130    键入中断符

$ tsys "sleep 30"

A\sh: 946 Quit    键入退出符

normal termination, exit status = 131    间

当用中断信号终止 sleep 时，pr_exit函数(见图 8-5)认为它正常终止。当用退出符杀死 sleep 进程时，会发生同样的事情。终止状态 130、131又是怎样得到的呢？原来 Bourne shell有一个在 其文档中没有说清楚的特性，其终止状态是 128 加上一个信号编号，该信号终止了正在执行的命 令。用交互方式使用 shell 可以看到这一点，

$ sh    确保运行 Bourne shell

S sh -c "sleep 30"

*C    键入中断符

$ echo    $?    打印最后一条命令的终止状态

130

S sh -c "sleep 30"

A\sh: 962 Quit - core dumped    费入退出符

$ echo 9?    打印最后一条命令的终止状态

131

$ exit    离开 Bourne sheil

在所使用的系统中，SIGINT的值为 2，SIGQUIT的值为 3，于是给出 shell 终止状态 130、131。

再试一个类似的例子，这一次将一个信号直接送给 shell，然后观察 system 返回什么：

| 5 tsys "sleep 30" fi | 这一次在后台启动它 |        |               |       |                     |
| -------------------- | ------------------ | ------ | ------------- | ----- | ------------------- |
| 9257                 |                    |        |               |       |                     |
| S                    | pa -f              |        |               |       | 査看进程 ID          |
|                      | □ ID               | PID    | PPID          | TTY   | TIME CMD            |
|                      | sar                | 9260   | 949           | pts/5 | 0:00 ps -f          |
|                      | sar                | 9258   | 9257          | pts/5 | 0:00 sh -c sleep 30 |
|                      | sar                | 949    | 947           | pts/5 | 0:01 /bin/sh        |
|                      | sar                | 9257   | 949           | pts/5 | 0:00 tsys sleep 30  |
|                      | sar                | 9259   | 9258          | pts/5 | 0:00 sleep 30       |
| $                    | kill -KILL 9258    |        | 杀死 shell 自身 |       |                     |
| abnormal             | termination,       | signal | number = 9    |       |                     |

从中可见，仅当 shell 本身异常终止时，system的返回值才报告一个异常终止。

其他的 Shell 在处理终端产生的信号（如 SIGINT 和 SIGQUIT）时表现出来的行为各不相同。

'例如在 bash 和 dash 中，键入中断或退出符会导致带有对应信号編号的表示异常终止的退出状态。 ；但是，如果发现正在执行 sleep 的进程并直接给它发送信号，这样信号只会到达单个进程而不是 ，整个前台进程组。这些 shell 与 Bourne shell类似，以正常终止状态 128 加上信号编号退出。

在编写使用 system 函数的程序时，一定要正确地解释返回值。如果直接调用 fork、exec 13721和 wait，则终止状态与调用 system 是不同的。


##### 10.19 函数 sleep、nanosleep 和 clock__nanosleep

在本书的很多例子中都已使用了 sheep函数，在图 10-7程序和图 10-8程序中有两个 sleep 的 实现，但它们都是有缺陷的。

Sinclude <unistd.h>

unsigned int sleep （unsigned int seconds）;

返回值：0或未休眠完的秒数

此函数使调用进程被挂起直到满足下面两个条件之一。

（1）    已经过了也所指定的墙上时钟时间。

（2）    调用进程捕捉到一个信号并从信号处理程序返回。

如同 alarm 信号一样，由于其他系统活动，实际返回时间比所要求的会迟一些。

在第 1 种情形，返回值是 0。当由于捕捉到某个信号 sleep 提早返回时（第 2 种情形），返

冋值是未休眠完的秒数（所要求的时间减去实际休眠时间）。

尽管 sleep 可以用 alarm 函数（见 10.10节）实现，但这并不是必需的。如果使用 alarm,

则这两个函数之间可能相互影响。POSIX.1标准对这些相互影响并未做任何说明。例如，若先调用 alarmClO），过了 3秒后又调用 sleep（5），那么将如何呢？ sleep将在 5 秒后返回（假定在这段时间 内没有捕捉到另一个信号），但是否在 2 秒后又产生另一个 SIGALRM 信号呢？此细节与具体实现有关。

FreeBSD 8.0、Linux 3.2.0、Mac OS X 10.6.8 和 Solaris 10 用 nanosleep 函数实现 sleep,

:使 sleep 具体实现与信号和闹钟定时器相互独立。考虑到可移植性，不应对 sleep 的实現进行任何 '假定，但是如果屁合调用 sleep 和其他与时间有关的函数，则需了解它们之间可能产生的交互。

、实例

图］0-29给出的是一个 POSIX.1 sleep函数的实现。此函数是图 10-7程序的修改版，它可 靠地处理信号，避免了早期实现中的竞争条件，但是仍未处理与以前设置的闹钟的交互作用（正 如前面提到的，POSIX.1并未显式地对这些交互进行定义）。

^include "apue.h"

static void sig_alrm(int signo)

/* nothing to do, just returning wakes up sigsuspend() */

}

unsigned int

sleep(unsigned int seconds)

{

struct sigaction newact, oldact;

sigset_t    newmask, oldmask, suspmask;

unsigned int    unslept;

/* set our handler, save previous information */ newact.sa_handler = sig_alrm; sigemptyset(&newact.sa_mask); newact.sa_flags = 0;

sigaction(SIGALRM, snewact, soldact)；

/* block SIGALRM and save current signal mask */ sigemptyset(&newmask); sigaddset(Snewmask, SIGALRM); sigprocmask(SIG_BLOCK, Snewmask, &oldmask);

alarm(seconds}; suspmask = oldmask;

/* make sure SIGALRM isn't blocked */ sigdelset(fisuspmask, SIGALRM);

/* wait for any signal to be caught */ sigsuspend{&suspmask);

/* some signal has been caught, SIGALRM is now blocked */

unslept = alarm(0);

/* reset previous action */ sigaction(SIGALRM, Soldact, NULL);

/* reset signal mask, which unblocks SIGALRM */ sigprocmask(SIG_SETMASK, fioldmask, NULL); return{unslept);

J

图 10_29 sleep的可靠实现

与图 10-7相比，为了可靠地实现 sleep，图 10-29的代码比较长。程序中没有使用任何形式 的非局部转移（如图 10-8中为了避免在 alarm 和 pause 之间的竞争条件所做的那样），所以对 处理 SIGALRM 信号期间可能执行的其他信号处理程序没有任何影响。    ■

nanosleep函数与 sleep 函数类似，但提供了纳秒级的精度。

♦include <time.h>

int nanosleep (const struct timespec *reqtp, struct timespec *remtp};

返回值：若休眠到要求的时间，返回 0:若出错，返回-1

这个函数挂起调用进程，直到要求的时间己经超时或者某个信号中断了该函数。伊参数用 秒和纳秒指定了需要休眠的时间长度。如果某个信号中断了休眠间隔，进程并没有终止，remtp

参数指向的 timespec 结构就会被设置为未休眠完的时间长度。如果对未体眠完的时间并不感兴 趣，可以把该参数置为 NULL。

如果系统并不支持纳秒这一精度，要求的时间就会取整。因为 nanosleep 函数并不涉及产 生任何信号，所以不需要担心与其他函数的交互，

nanosleep函数过去属于 Single UNIX Specification的定时器选领，现已被移至 SUSv4 的基 础部分。

随着多个系统时钟的引入（回忆 6.10节），需要使用相对于特定时钟的延迟时间来挂起调用 线程。clock_nanosleep函数提供了这种功能。

番 include <time.h>

int clock_nanosleep(clockid_t dock_id, int flags,

const struct timespec *reqtp, struct timespec *remtp};

返回值：若休眠要求的时间，返回 0:若出错，返回错误码

参数指定了计算延迟时间基于的时钟。时钟标识符列于图 6-8中。flags参数用于控制延 迟是相对的还是绝对的。7/^职为 0 时表示休眠时间是相対的（例如，希望休眠的时间长度〉，如果加 gs 值设置为 TIMER_ABSTIME，表示休眠时间是绝对的（例如，希望休眠到时钟到达某个特定的时间）。 其他的参数 re 识 p 和与 mawoj/eep函数中的相同。但是，使用绝对时间时，rem伊参数

未使用，因为没有必要。在时钟到达指定的绝对时间值以前，可以为其他的 clOCk_nan0Sleep 调用复用 re 识 p 参数相同的值。

注意，除了出错返回，调用

clock_nanosleep（CLOCK_REALTIME, 0, reqtp, remtp>;

和调用

nanosleep（reqtp, remtp）;

的效果是相同的。使用相对休眠的问题是有些应用对休眠长度有精度要求，相对体眠时间会导致 实际休眠时间比要求的长。例如，某个应用程序希望按固定的时间间隔执行任务，就必须获取当 前时间，计算下次执行任务的时间，然后调用 nanosleep。在获取当前时间和调用 nanosleep 之间，处理器调度和抢占可能会导致相対体眠时间超过实际需要的时间间隔，即便分时进程调 度程序对休眠时间结束后是否会马上执行用户任务并没有给出保证，使用绝対时间还是改善了 精度。

1 在 Single UNIX Specification的早期版本中，clock_nanosleep函数属于时钟选择选项，在 SUSv4中，该函数已移至基础部分。

##### 10.20 函数 sigqueue

在 10.8节中，我们介绍了大部分 UNIX 系统不对信号排队。在 POSIX.1的实时扩展中，有 些系统开始增加对信号排队的支持。在 SUSv4 中，排队信号功能已从实时扩展部分移至基础说 明部分。

通常一个信号带有一个位信息：信号本身。除了对信号排队以外，这些扩展允许应用程序在

递交信号时传递更多的信息（回忆 10.14节）。这些信息嵌入在 siginfo 结构中。除了系统提供 的信息，应用程序还可以向信号处理程序传递整数或者指向包含更多信息的缓冲区指针。

使用排队信号必须做以下几个操作》

（1）    使用 sigaction 函数安装信号处理程序时指定 SA_SIGINFO标志。如果没有给出这个 标志，信号会延迟，但信号是否进入队列要取决于具体实现。

（2）    在 sigaction 结构的 sa_sigaction成员中（而不是通常的 sa_handler字段）提 供信号处理程序。实现可能允许用户使用 sa_handler字段，但不能获取 sigqueue 函数发送 出来的额外信息。

（3）    使用 sigqueue 函数发送信号。

\#include <signal.h>

int sigqueue (pid_t pid, int sigrto, const union sigval value);

返回值：若成功，返回 0:若出错，返回-1

sigqueue函数只能把信号发送给单个进程，可以使用 vfl/we参数向信号处理程序传递整数 和指针值，除此之外，sigqueue函数与 kill 函数类似。

信号不能被无限排队，回忆图 2-9和图 2-11中的 SIGQUEUE_MAX限制，到达相应的限制以 后，sigqueue就会失败，将 errno 设为 EAGAIN。

随着实时信号的增强，引入了用于应用程序的独立信号集。这些信号的编号在 SIGRTMIN〜 SIGRTMAX之间，包括这两个限制值，注意，这些信号的默认行为是终止进程。

图 10-30总结了排队信号在本书不同的实现中的行为上的差异。

Mac OS X 10.6.8并不支持 sigqueue 或者实时信号。在 Solaris 10中，sigqueue在矣时库

librt 中。

| 行为                                         | SUS  | FreeBSD8.0 | Linux3.2.0 | Mac OSX 10.6.8 | Solaris10 |
| -------------------------------------------- | ---- | ---------- | ---------- | -------------- | --------- |
| 支持 sigqueue                                | •    |            |            |                | •         |
| 对在 SIGRTMIN 和 SIGRTMAX 之外的信号排队         | 可选 |            |            |                | •         |
| 即使调用者没使用 SA SIGINFO标志，也对信号排队 | 可选 |            |            |                |           |

图 10-30不同平台上排队信号的行为    [376]

10-21作业控制信号

在图 10-1所示的信号中，POSIX.1认为有以下 6 个与作业控制有关。

SIGCHLD子进程已停止或终止=

SIGCONT如果进程已停止，则使其继续运行。

SIGSTOP停止信号（不能被捕捉或忽略）。

SIGTSTP交互式停止信号。

SIGTTIN后台进程组成员读控制终端。

SIGTTOU后台进程组成员写控制终端。

除 SIGCHLD 以外，大多数应用程序并不处理这些信号，交互式 Shell 则通常会处理这些信号 的所有工作。当键入挂起字符（通常是 Ctrl+Z）时，SIGTSTP被送至前台进程组的所有进程。当

我们通知 shell 在前台或后台恢复运行一个作业时，shell向读作业中的所有进程发送 SIGCONT 信 号。与此类似，如果向一个进程递送了 SIGTTIN或 SIGTTOU 信号，则根据系统默认的方式，停 止此进程，作业控制 shell 了解到这一点后就通知我们。

一个例外是管理终端的进程，例如，vi(l)编辑器。当用户要挂起它时，它需要能了解到这一 点，这样就能将终端状态恢复到 vi 启动时的情况。另外，当在前台恢复它时，它需要将终端状 态设置回它所希望的状态，并需要重新绘制终端屏幕。可以在下面的例子中观察到与 vi 类似的 程序是如何处理这种情况的。

在作业控制信号间有某些交互。当对一个进程产生 4 种停止信号(SIGTSTP、SIGSTOP、 SIGTTIN或 SIGTTOU)中的任意一种时，对该进程的任一未决 SIGCONT 信号就被丢弃。与此 类似，当对一个进程产生 SIGCONT 信号时，对同一进程的任一未决停止信号被丢弃。

注意，如果进程是停止的，则 SIGCONT 的默认动作是继续该进程；否则忽略此信号。通常， 对该信号无需做任何事情。当对一个停止的进程产生一个 SIGCONT 信号时，该进程就继续，即 使该信号是被阻塞或忽略的也是如此。

■实例

图 10-31中的程序演示了当一个程序处理作业控制时通常所使用的规范代码序列。该程序只 ._。是将其标准输入复制到其标准输出，而在信号处理程序中以注释形式给出了管理屏幕的程序所执

行的典型操作。

main《void)

i

int    n;

char    buf[BUFFSIZEJ;

\* Only catch SIGTSTP if we're running with a job-control shell. */

if (signal{SIGTSTP, SXG_IGN) == SIG_DFL) signal (SIGTSTP, siq_tstp)

while ((n = read(STDIN_FILENO, buf, BUFFSIZE)) > 0) if (write(STDOUT_FILENO, buf, n) != n)

err_sys("write error");

if (n < 0)

err_sys{"read error"};

exit (0);

J

图 10-31如何处理 SIGTSTP

当图 10-31中的程序启动时，仅当 SIGTSTP 信号的配置是 SIG_DFL，它才安排捕捉该信号。

其理由是：当此程序由不支持作业控制的 shell （如/bin/sh）启动时，此信号的配置应当设置为[378] SIG_IGN。实际上，shell并不显式地忽略此信号，而是由 init 将送 3 个作业控制信号 SIGTSTP、 SIGTTIN和 SIGTTQU 设置为 SIG_IGN。然后，这种配置由所有登录 shell 继承。只有作业控制 shell才应将这 3 个信号重新设置为 SIGJDFL。

当键入挂起字符时，进程接到 SIGTSTP 信号，然后调用该信号处理程序。此时，应当进行 与终端有关的处理：将光标移到左下角、恢复终端工作方式等。在将 SIGTSTP 重置为默认值（停 止该进程），并且解除了对此信号的阻塞之后，进程向自己发送同一信号 SIGTSTP。因为正在处 理 SIGTSTP 信号，而在捕捉该信号期间系统自动地阻塞它，所以应当解除对此信号的阻塞。到 达这一点时，系统停止该进程。仅当某个进程（通常是正响应一个交互式 fg 命令的作业控制 Shell）

向该进程发送一个 SIGCONT 信号时，该进程才继续。我们不捕捉 SIGCONT 信号。该信号的默 认配置是继续运行停止的进程，当此发生时，此程序如同从 kill 函数返回一样继续运行。当 此程序继续运行时，将 SIGTSTP 信号重置为捕捉，并且做我们所希望做的终端处理（如重新绘 制屏幕）。    ■

10.22信号名和编号

本节介绍如何在信号编号和信号名之间进行映射。某些系统提供数组 extern char *sys_siglist[];

数组下标是信号编号，数组中的元素是指向信号名符串的指针=

FreeBSD 8.0、Linux 3.2.0和 Mac OS X 10.6.8都提供这种信号名数组。Solaris 10也提供信号

名數组，但该数组名是_sys_siglist。

可以使用 psignal 函数可移植地打印与信号编号对应的字符串。

\#include <signal.h>

void psignal (int sign。, const char *wjg);

字符串 msg （通常是程序名）输出到标准错误文件，后面跟随一个冒号和一个空格，再后面 对该信号的说明，最后是一个换行符。如果 m 呀为 NULL，只有信号说明部分输出到标准错误文 件，该函数类似于 perror （1.7节）。

如果在 sigaction 信号处理程序中有 siginfo 结构，可以使用 psiginfo 函数打印信号 信息。

\#include <signal.h>

void psiginfo (const siginfo t *info, const char    ;

它的工作方式与 psignal 函数类似。虽然这个函数访问除信号编号以外的更多信息，但不 同的平台输出的这些额外信息可能有所不同。

如果只需要信号的字符描述部分，也不需要把它写到标准错误文件中（如可以写到曰志文件 中），可以使用 strsignal 函数，它类似于 strerror （另见 1.7节）。

\#include <string.h>

char * strsignal （int signo）;

返回值，指向描述该信号的字符串的指针 给出一个信号编号，strsignal将返回描述该信号的字符串。庾用程序可用该字符串打印 关于接收到信号的出错消息。

!    本书讨论的所有平台都提供 psignal 和 strsignal 轟数，但相互之间有些差别。在 Solaris

賣 10 中，若信号编号无效，strsignal将返田一个空推针，而 Fre 曲 SD 8.0、Linux 3.2.0和 Mac OS | X 10.6.8则返回一个字符串，它指出信号编号是不可识别的。

:    只有 Linux 3.2.0 和 Solaris 10 支持 psiginfo 西数。

Solaris提供一对函数，一个函数将信号编号映射为信号名，另一个则反之。

\#include <signal.h>

int sig2str （int signo, char *str）;

int str2sig （const char *str, int *signop）;

两个函数的返回值，若成功，返回 0；若出错，返回-1

在编写交互式程序，其中需接收和打印信号名和信号编号时，这两个函数是有用的。 sig2str函数将给定信号编号翻译成字符串，并将结果存放在对 r 指向的存储区。调用

者必须保证该存储区足够大，可以保存最长字符串，包括终止 null 字节。Solaris在 <signal.h>中包含了常量 SIG2STR_MAX，它定义了最大字符串长度。该字符串包括不带 “SIG”前缀的信号名。例如，SIGKILL被翻译为字符串“KILL”，并存放在 Wr 指向的存储 缓冲区中。

str2sig函数将给出的信号名翻译成信号编号。该信号编号存放在■y/gw叩指向的整型中。 名字要么是不带“S1G”前缀的信号名，要么是表示十进制信号编号的字符串（如“9”）。

[38。| 往意 f sig2str和 str2sig 与常用的函数做法不同，当定们失败时，并不设置 errno。

##### 10.23小结

信号用于大多数复杂的应用程序中，理解进行信号处理的原因和方式对于髙级 UNIX 编程极 其重要。本章对 UNIX 信号进行了详细而且比较深入的介绍。首先说明了早期信号实现的问题以 及它们是如何显现出来的。然后介绍了 POSIX.1的可靠信号概念以及所有相关的函数。在此基础 上提供了 abort、system和 sleep 函数的 POSIX.1实现。最后以观察分析作业控制信号以及 信号名和信号编号之间的转换结束。

习题

10.1删除图 10-2程序中的 for （;;）语句，结果会怎样？为什么？

10.2实现 10.22节中说明的 sig2str 函数。

10.3画出运行图 10-9程序时的桟喊情况。

10.4图 10-11程序中利用 setjmp 和 longjmp 设置 I/O操作的超时，下面的代码也常见用于此 种目的：

signal（SIGALRM, sig_alrm）; alarm（60）;

if （setjmp（env_alrm） != 0）（

/* handle timeout */

}

这段代码有什么错误？

10.5仅使用一个定时器（alarm或较髙精度的 setitimer），构造一组函数，使得进程在该单 一定时器基础上可以设置任一数量的定时器。

10.6编写一段程序测试图 10-24中父进程和子进程的同步函数，要求进程创建一个文件并向 文件写一个整数 0，然后，进程调用 fork，接着，父进程和子进程交替増加文件中的计 数器值，每次计数器值増加 1 时，打印是哪一个进程（子进程或父进程）进行了该增加 I操作。

10.7在图 10-25中，若调用者捕捉了 SIGABRT并从该信号处理程序中返回，为什么不是仅仅调 而要恢复其默认设置并再次调用 kill?

10.8为什么在 siginfo 结构（见 10.14节）的 si_uid字段中包括实际用户 ID 而非有效用 户 ID?

10.9重写图 10-14中的函数，要求它处理图 10-1中的所有信号，每次循环处理当前信号屏蔽字

中的一个信号（并不是对每一个可能的信号都循环一次）。    [353

10.10编写一段程序，要求在一个无限循环中调用 sleep<60》函数，每 5 分钟（即 5 次循环）

取当前的日期和时间，并打印 tm_SeC字段。将程序执行一晚上，请解释其结果。有些程 序，如 cron 守护进程，每分钟运行一次，它是如何处理这类工作的？

10.11修改图 3-5的程序，要求：（a）将 BUFFSIZE 改为 100; （b）用 signal_intr函数捕 捉 SIGXFSZ 信号量并打印消息，然后从信号处理程序中返回；（C）如果没有写满请求

的字节数，则打印 write 的返回值。将软资源限制 RLIMIT_FS1ZE （见 7.11节）更改为 1 024字节（在 shell 中设置软资源限制，如果不行就直接在程序中调用 setrlimit），然 后复制一个大于 1024 字节的文件，在各种不同的系统上运行新程序，其结果如何？为什么？

10.12编写一段调用 fwrite 的程序，它使用一个较大的缓冲区（约 1GB），调用 fwrite 前调 用 alarm 使得 1 s以后产生信号。在信号处理程序中打印捕捉到的信号，然后返回。fwrite

®    可以完成吗？结果如何？
