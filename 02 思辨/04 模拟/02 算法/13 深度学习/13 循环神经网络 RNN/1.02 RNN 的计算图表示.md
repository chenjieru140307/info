

# 展开计算图

计算图是形式化一组计算结构的方式，如那些涉及将输入和参数映射到输出和损失的计算。

本节，我们对展开递归或循环计算得到的重复结构进行解释，这些重复结构通常对应于一个事件链。展开这个计算图将导致深度网络结构中的参数共享。

## 考虑动态系统的经典形式

例如，考虑动态系统的经典形式：



$$\begin{aligned}
\boldsymbol s^{(t)} = f(\boldsymbol s^{(t-1)}; \boldsymbol \theta),
\end{aligned}\tag{10.1}$$



其中 $\boldsymbol s^{(t)}$ 称为系统的状态。

$\boldsymbol s$ 在时刻 $t$ 的定义需要参考时刻 $t-1$ 时同样的定义，因此式 10.1 是循环的。

对有限时间步 $\tau$， $\tau-1$ 次应用这个定义可以展开这个图。例如 $\tau = 3$，我们对式 10.1 展开，可以得到：



$$\begin{aligned}
 \boldsymbol s^{(3)} &= f(\boldsymbol s^{(2)}; \boldsymbol \theta) \\
 & = f(f(\boldsymbol s^{(1)}; \boldsymbol \theta) ; \boldsymbol \theta).
\end{aligned}\tag{10.3}$$

以这种方式重复应用定义，展开等式，就能得到不涉及循环的表达。

## 使用传统的有向无环计算图呈现

现在我们可以使用传统的有向无环计算图呈现这样的表达。

式 10.1 和式 10.3 的展开计算图如下图所示。


<p align="center">
    <img width="70%" height="70%" src="http://images.iterate.site/blog/image/20190718/H0L1dVREQVrI.png?imageslim">
</p>

> 10.1 将式 10.1 描述的经典动态系统表示为展开的计算图。每个节点表示在某个时刻 $t$ 的状态，并且函数 $f$ 将 $t$ 处的状态映射到 $t+1$ 处的状态。所有时间步都使用相同的参数（用于参数化 $f$ 的相同 $\boldsymbol \theta$ 值）。


## 让我们考虑由外部信号驱动的动态系统

作为另一个例子，让我们考虑由外部信号 $\boldsymbol x^{(t)}$ 驱动的动态系统，



$$
\begin{aligned}
 \boldsymbol s^{(t)} = f(\boldsymbol s^{(t-1)}, \boldsymbol x^{(t)} ; \boldsymbol \theta),
\end{aligned}\tag{10.4}
$$



我们可以看到，当前状态包含了整个过去序列的信息。

## 有隐藏单元的

循环神经网络可以通过许多不同的方式建立。就像几乎所有函数都可以被认为是前馈网络，本质上任何涉及循环的函数都可以被认为是一个循环神经网络。

很多循环神经网络使用式 10.5 或类似的公式定义隐藏单元的值。为了表明状态是网络的隐藏单元，我们使用变量 $\boldsymbol h$ 代表状态重写式 10.4 ：


$$\begin{aligned}
 \boldsymbol h^{(t)} = f(\boldsymbol h^{(t-1)}, \boldsymbol x^{(t)} ; \boldsymbol \theta),
\end{aligned}\tag{10.5}$$


如下图所示，典型 RNN 会增加额外的架构特性，如读取状态信息 $\boldsymbol h$ 进行预测的输出层。


<p align="center">
    <img width="70%" height="70%" src="http://images.iterate.site/blog/image/20190718/dpgPNEjFm9BV.png?imageslim">
</p>

> 10.2 没有输出的循环网络。此循环网络只处理来自输入 $\boldsymbol x$ 的信息，将其合并到经过时间向前传播的状态 $\boldsymbol h$。(左)回路原理图。 黑色方块表示单个时间步的延迟。(右)同一网络被视为展开的计算图，其中每个节点现在与一个特定的时间实例相关联。



当训练循环网络根据过去预测未来时，网络通常要学会使用 $\boldsymbol h^{(t)}$ 作为过去序列（直到 $t$）与任务相关方面的有损摘要。

此摘要一般而言一定是有损的，因为其映射任意长度的序列 $(\boldsymbol x^{(t)},\boldsymbol x^{(t-1)}, \boldsymbol x^{(t-2)},\dots,\boldsymbol x^{(2)}, \boldsymbol x^{(1)})$ 到一固定长度的向量 $\boldsymbol h^{(t)}$。根据不同的训练准则，摘要可能选择性地精确保留过去序列的某些方面。

例如，如果在统计语言建模中使用的 RNN，通常给定前一个词预测下一个词，可能没有必要存储时刻 $t$ 前输入序列中的所有信息；而仅仅存储足够预测句子其余部分的信息。最苛刻的情况是我们要求 $\boldsymbol h^{(t)}$ 足够丰富，并能大致恢复输入序列，如自编码器框架。

## 两种不同的方式来绘制

式 10.5 可以用两种不同的方式来绘制。


- 一种绘制 RNN 的方式是用循环图，对于可能存在于模型的物理实现中的每个组件，都在图中包含其对应的节点。这种方式的一个示例是生物神经网络。在这种视角下，网络定义了实时操作的回路，如图 10.2 的左侧，其当前状态可以影响其未来的状态。在本章中，我们使用回路图中的黑色方块表示单个时间步延时所发生的交互，即从时刻 $t$ 的状态到时刻 $t+1$ 的状态的变化。
- 另一种绘制 RNN 的方式是用展开的计算图，其中每一个组件由许多不同的变量表示，每个时间步一个变量，用来表示组件在该时间点的状态。
每个时间步的每个变量绘制为计算图的一个独立节点，如图 10.2 的右侧。我们所说的展开是将左图中的回路映射为右图中包含重复组件的计算图的操作。这样，展开图的大小取决于序列长度。

我们可以用一个函数 $g^{(t)}$ 代表经 $t$ 步展开后的循环：




$$\begin{aligned}
\boldsymbol h^{(t)} &=g^{(t)}(\boldsymbol x^{(t)},\boldsymbol x^{(t-1)}, \boldsymbol x^{(t-2)},\dots,\boldsymbol x^{(2)}, \boldsymbol x^{(1)}) \\
& =  f(\boldsymbol h^{(t-1)}, \boldsymbol x^{(t)} ; \boldsymbol \theta) .
\end{aligned}$$



函数 $g^{(t)}$ 将全部的过去序列 $(\boldsymbol x^{(t)},\boldsymbol x^{(t-1)}, \boldsymbol x^{(t-2)},\dots,\boldsymbol x^{(2)}, \boldsymbol x^{(1)})$ 作为输入来生成当前状态，但是展开的循环架构允许我们将 $g^{(t)}$ 分解为函数 $f$ 的重复应用。因此，展开过程引入两个主要优点：


- 无论序列的长度，学成的模型始终具有相同的输入大小，因为它指定的是从一种状态到另一种状态的转移， 而不是在可变长度的历史状态上操作。
- 我们可以在每个时间步使用相同参数的相同转移函数 $f$。




这两个因素使得学习在所有时间步和所有序列长度上操作单一的模型 $f$ 是可能的，而不需要在所有可能时间步学习独立的模型 $g^{(t)}$。学习单一的共享模型允许泛化到没有见过的序列长度（没有出现在训练集中），并且估计模型所需的训练样本远远少于不带参数共享的模型。

无论是循环图和展开图都有其用途：

- 循环图简洁。展开图能够明确描述其中的计算流程。
- 展开图还通过显式的信息流动路径帮助说明信息在时间上向前（计算输出和损失）和向后（计算梯度）的思想。



# 相关

- 《深度学习》花书
习》花书
