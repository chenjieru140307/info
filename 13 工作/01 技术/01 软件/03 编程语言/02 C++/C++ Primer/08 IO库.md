
### 第 n 部分 C++标准库

<307]



内容

随着 C++版本的一次次修订，标准库也在不断成长。确实，新的 C++标准中有三分之 二的文本都用來描述标准库。虽然我们不能深入讨论所有标准库设施，俏有些核心库没施 是每个 C++程序员都应该熟练掌握的，第二部分将介绍这些内容。

我们首先在第 8 拳中介绍基本的 IO 库设施。除了使用标准库读写与控制台窗口相关 联的流之外，我们还将学习其他一些库类型，可以帮助我们读写命名文件以及完成到 string对象的内存 1O 操作。

标准库的核心是很多容器类和一族泛型算法，这辟没施能帮助我们编写简洁高效的程 序，标准库会去关注那些簿记操作的细节，特别是内存管理，这样我们的程序就可以将令 部注意力投入到需要求解的问题上。

我们在第 3 章中已经介绍了容器类型 vector，在第 9 章中将介绍更多 vector 相关 的内容，这一章也会涉及其他顺序容器，我们还会介绍更多 string 类型所支持的操作， 可以将 string 看作一种只包含字符元素的特殊容器。string支持很多容器操作，但并 不是全部。

< 308 I



第 10 章介绍泛型算法。这类算法通常在顺序容器一定范围内的元素上或其他类型的 序列上进行操作。算法库为各种经典算法提供了高效的实现，如排序和搜索算法，还提供 了其他一些常用操作。例如，标准庳提供了 copy算法，完成一个序列到另一个序列的元 素拷贝；还提供了 find算法，实现给定元素的查找，等等。泛型算法的通用性体现在两 个层面：可应用于不同类型的序列；对序列中元素的类型限制小，大多数类型都是允许的。

标准库还提供了一些关联容器，第 11 章介绍这部分内容。关联容器中的元素是通过 关键字来访问的，关联容器支持很多顺序容器的操作，也定义了一些自己特有的操作，

第 12 章是第二部分的最后一章，这一章介绍动态内存管理相关的一些语言特性和库 设施。这一章介绍智能指针的一个标准版本，它是新标准库中最重要的类之一。通过使用 智能指针，我们可以大幅度提高使用动态内存的代码的鲁棒性。这一章最后将给出一个较 大的例子，使用了第 n 部分介绍的所有标准库设施。

#### 第 8 章

< 309 j

 IO库

内容

..................................................................................................................290

C杆语言不直接处理输入输出，而是通过一族定义在标准库中的类型来处理 10。这些 类型支持从设备读取数裾、向设备写入数据的 IO 操作，没备可以是文件、控制台脔口等。 还有一些类型允许内存 10，即，从 string 读取数据，向 string 写入数据。

10库定义了读写内置类型值的操作。此外，一些类，如 string，通常也会定义类似 的 1O 操作，来读写自己的对象。

本章介绍 10 库的基本内容。后续章节会介绍更多 IO 库的功能：第 14 章将会介绍如 何编写自己的输入输出运算符，第 17 章将会介绍如何控制输出格式以及如何对文件进行 随机访问。

ESD>    我们的程序已经使用了很多 IO 库设施了。我们在 1.2节（第 5 页）已经介绍了大部

分 IO 库设施：

•    istream （输入流）类型，提供输入操作。

•    ostream （输出流）类型，提供输出操作。

•    cin, 一个 istream 对象，从标准输入读取数裾。

•    cout，一个 ostream 对象，向标准输出写入数据。

•    cerr, 一个 ostream 对象，通常用于输出程序错误消息，写入到标准错误。

•〉〉运算符，用来从一个 istream 对象读取输入数据。

•    «运算符，用来向一个 ostream 对象写入输出数据。

•    getline函数（参见 3.3.2节，第 78 页），从一个给定的 istream 读取一行数据， 存入一个给定的 string 对象中。

袒 8.1 IO类

到目前为止，我们已经使用过的 IO 类型和对象都是操纵 char 数据的。默认情况下， 这些对象都是关联到用户的控制台窗口的。当然，我们不能限制实际应用程序仅从控制台 窗口进行 IO 操作，应用程序常常需要读写命名文件。而且，使用 IO 操作处理 string 中 的字符会很方便。此外，应用程序还可能读写需要宽字符支持的语言。

为了支持这些不同种类的 IO 处理操作，在 istream 和 ostream 之外，标准库还定 义了其他一些 10 类型，我们之前都已经使用过了，表 8.1列出了这些类型，分别定义在 三个独立的头文件中：iostream定义了用于读写流的基本类型，fstream定义了读写 命名文件的类型，sstream定义了读写内存 string 对象的类型。

| 表 8.1: I0库类型和头文件 |                                                              |
| ----------------------- | ------------------------------------------------------------ |
| 头文件                  | 类型                                                         |
| iostream                | istream, wistream从流读取数据 ostream，wostream向流写入数据 iostream, wiostream 读写流 |
| fstream                 | if stream, wif stream从文件读取数据 of stream, wof stream向文件写入数据 fstream，wfstream 读写文件 |
| sstream                 | istringstream, wistringstream 从 string 读取数据 ostringstream, wostringstream 向 string 写入数据 stringstream, wstringstream 读写 string |

rW>    为了支持使用宽字符的语言，标准库定义了一组类型和对象来操纵 wchar_t类型的

数据（参见 2.1.1节，第 30 页）。宽字符版本的类型和函数的名字以一个 w 开始。例如， wcin、wcout和 wcerr 是分别对应 cin、cout和 cerr 的宽字符版对象。宽字符版本 的类型和对象与其对应的普通 char 版本的类型定义在同一个头文件中。例如，头文件 fstream 定义了 if stream 和 wif stream 类型。

IO类型间的关系

概念上，设备类型和字符大小都不会影响我们要执行的 IO 操作。例如，我们可以用 >>读取数据，而不用管是从一个控制台窗口，一个磁盘文件，还是一个 string 读取。类 似的，我们也不用管读取的字符能存入一个 char 对象内，还是需要一个 wchar_t对象 来存储。

标准库使我们能忽略这些不同类型的流之间的差异，这是通过继承机制（inheritance） 实现的。利用模板（参见 3.3节，第 87 页），我们可以使用具有继承关系的类，而不必了 解继承机制如何工作的细节=我们将在第 15 章和 18.3节（第 710 页）介绍 C++是如何支 持继承机制的。

简单地说，继承机制使我们可以声明一个特定的类继承自另一个类。我们通常可以将 一个派生类（继承类）对象当作其基类（所继承的类）对象来使用。

类型 ifstream 和 istringstream 都继承自 istream。因此，我们可以像使用 istream对象一样來使用 if stream和 istringstream 对象。也就是说，我们是如何 使用 cin 的，就可以同样地使用这些类型的对象。例如，可以对一个 ifstream 或 istringstream对象调用 getline ，也可以使用 >> 从-•个 ifstream 或 istringstream对象中读取数裾。类似的，类型 of stream和 ostringstream 都继 承自 ostream。因此，我们是如何使用 cout 的，就可以同样地使用这些类型的对象。

![img](C++  Primer 5-76.jpg)



本节剩下部分所介绍的标准库流特性都可以无差别地应用于普通流、文件流和 string流，以及 char 或宽字符流版本•

###### 8.1.1 IO对象无拷贝或赋值

如我们在 7.1.3节（第 234 页）所见，我们不能拷贝或对 10 对象赋值： ofstream outl, out2;

outl = out2;    //错误：不能对流对象賦值

ofstream print （of stream） ;    // 错误：不能初始化 of stream 参数

out2 = print （out2） ;    //错误：不能拷贝流对象

由于不能拷贝 IO 对象，因此我们也不能将形参或返回类型设置为流类型（参见 6.2.1节， 第 188 页）。进行 1O 操作的函数通常以引用方式传递和返回流。读写一个 IO 对象会改变 其状态，因此传递和返回的引用不能是 const 的。

###### 8.1.2条件状态    <3ia

io操作一个与生俱来的问题是可能发生错误。一些错误是可恢复的，而其他错误则 发生在系统深处，已经超出了应用程序可以修 iE 的范围。表 8.2列出了 IO类所定义的一 些函数和标志，可以帮助我们访问和操纵流的条件状态（condition state）。

| 表 8.2: IO库条件状态 |                                                              |
| ------------------- | ------------------------------------------------------------ |
| strm : : iostate    | strm是一种 10 类型，在表 8.1 （第 278 页）中已列出。iostate 是一种机器相关的类型，提供了表达条件状态的完整功能 |
| strm: : badbit      | strm: : badbi t用来指出流已崩溃                              |
| strm: : failbit     | strm:: failbit用来指出一个 IO 操作失败了                       |

续表

| strm: : eofbit    | strm: : eofbit用来指出流到达了文件结束                       |
| ----------------- | ------------------------------------------------------------ |
| strm: : goodbit   | : goodbit用来指出流未处于错误状态。此值保证为零              |
| s . eof()         | 若流 s 的 eofbit 置位，则返回 true                                |
| s.failO           | 若流 s 的 failbit 或 badbit 置位，则返回 true                       |
| s.bad()           | 若流 s 的 badbit 置位，则返回 true                                |
| s.good()          | 若流 s 处于有效状态，则返回 true                                |
| s.clear ()        | 将流 s 中所有条件状态位复位，将流的状态设置为有效。返回 void    |
| s•clear (flags)   | 根据给定的 flags 标志位，将流 s 中对应条件状态位复位。flags 的类型为於削：：iostate。返回 void |
| s.setstate(flags) | 根据给定的 flags 标志位，将流 s 中对应条件状态位置位。flags 的类型为於⑽：：iostate。返回 void |
| s.rdstate()       | 返回流 s 的当前条件状态，返回值类型为 strm: : iostate           |

下面是一个 IO 错误的例子：

int ival; cin » ival;

如果我们在标准输入上键入 Boo，读操作就会失败。代码中的输入运算符期待读取一个 int，但却得到了一个字符 B。这样，cin会进入错误状态。类似的，如果我们输入一个 文件结束标识，cin也会进入错误状态。

一个流一旦发生错误，其上后续的 1O 操作都会失败。只有当一个流处于无错状态时， 我们才可以从它读取数据，向它写入数据。由于流可能处于错误状态，因此代码通常应该 在使用一个流之前检查它是否处于良好状态。确定一个流对象的状态的最简单的方法是将 它当作一个条件来使用：

while （cin » word）

//ok:读操作成功......

while循环检查》表达式返回的流的状态。如果输入操作成功，流保持有效状态，则条 件为真。

查询流的状态

将流作为条件使用，只能告诉我们流是否有效，而无法告诉我们具体发生了什么。有 时我们也需要知道流为什么失败。例如，在键入文件结束标识后我们的应对措施，可能与 遇到一个 IO 设备错误的处理方式是不同的。

10库定义了一个与机器无关的 iostate 类型，它提供了表达流状态的完整功能。这 个类型应作为一个位集合来使用，使用方式与我们在 4.8节中（第 137 页）使用 quizl 的方式一样。IO库定义了 4个 iostate 类型的 constexpr 值（参见 2.4.4节，第 58 页）， 表示特定的位模式。这些值用来表示特定类型的 10 条件，可以与位运算符（参见 4.8节， 第 137 页）一起使用来一次性检测或设置多个标志位。

badbit表示系统级错误，如不可恢复的读写错误。通常情况下，一旦 badbit 被置 位，流就无法再使用了。在发生可恢复错误后，failbit被置位，如期望读取数值却读 出一个字符等错误。这种问题通常是可以修正的，流还可以继续使用。如果到达文件结束 位置，eofbit和 failbit 都会被置位。goodbit的值为 0，表示流未发生错误。如果 badbit、failbit和 eofbit 任一个被置位，则检测流状态的条件会失败。

标准库还定义了一组函数来查询这些标志位的状态。操作 good 在所有错误位均未置 位的情况下返回 true，而 bad、fail和 eof 则在对应错误位被置位时返回 true。此<3»] 外，在 badbit 被置位时，fail也会返回 true。这意味着，使用 good 或 fail 是确定 流的总体状态的正确方法。实际上，我们将流当作条件使用的代码就等价于！ fail ()»而 eof和 bad 操作只能表示特定的错误。

管理条件状态

流对象的 rdstate 成员返回一个 iostate 值，对应流的当前状态。setstate操 作将给定条件位置位，表示发生了对应错误。clear成员是一个重载的成员(参见 6.4节， 第 206 页)：它有一个不接受参数的版本，而另一个版本接受一个 iostate 类型的参数。

clear不接受参数的版本清除(复位)所有错误标志位。执行 clear ()后，调用 good 会返回 true。我们可以这样使用这些成员：

//记住 cin 的当前状态



auto old_state = cin.rdstate();



//记住 cin 的当前状态 //使 cin 有效 //使用 cin //将 cin 置为原有状态



cin.clear();

process_input(cin); cin.setstate(old_state);

带参数的 clear 版本接受一个 iostate 值，表示流的新状态。为了复位单一的条件 状态位，我们首先用 rdstate 读出当前条件状态，然后用位操作将所需位复位来生成新 的状态。例如，下面的代码将 failbit 和 badbit 复位，但保持 eofbit 不变：    <2KI

//复位 failbit 和 badbit，保持其他标志位不变

cin.clear(cin.rdstate() & 〜cin.failbit & 〜cin.badbit};

###### 8.1.2节练习

练习 8.1:编写函数，接受一个 istream&参数，返回值类型也是 istream&。此函数 须从给定流中读取数据，直至遇到文件结束标识时停止。它将读取的数据打印在标准输 出上。完成这些操作后，在返回流之前，对流进行复位，使其处于有效状态。

练习 8.2:测试函数，调用参数为 cin»

练习 8.3:什么情况下，下面的 while 循环会终止？ while (cin » i) /* ... ★/

###### 8.1.3管理输出缓冲

每个输出流都管理一个缓冲区，用来保存程序读写的数据。例如，如果执行下面的代码 os << "please enter a value:

文本串可能立即打印出来，但也有可能被操作系统保存在缓冲区中，随后再打印。有了缓 冲机制，操作系统就可以将程序的多个输出操作组合成单一的系统级写操作。由于设备的 写操作可能很耗吋，允许操作系统将多个输出操作组合为单一的设备写操作可以带来很大 的性能提升。

导致缓冲刷新(即，数据真正写到输出设备或文件)的原因有很多：

•程序正常结束，作为 main 函数的 return 操作的一部分，缓冲刷新被执行。

•缓冲区满时。需要刷新缓冲，而后新的数据才能继续写入缓冲区。

•我们可以使用操纵符如 endl （参见 1.2节，第 6 页）来显式刷新缓冲区。

•在每个输出操作之后，我们可以用操纵符 unitbuf 设置流的内部状态，来清空缓 冲区。默认情况下，对 cerr 是设置 unitbuf 的，因此写到 cerr 的内容都是立 即刷新的。

• 一个输出流可能被关联到另一个流。在这种情况下，当读写被关联的流时，关联到 的流的缓冲区会被刷新。例如，默认情况下，cin和 cerr 都关联到 cout，因此， 读 cin 或写 cerr 都会导致 cout 的缓冲区被刷新=

刷新输出缓冲区

我们已经使用过操纵符 endl，它完成换行并刷新缓冲区的工作。IO库中还有两个类 似的操纵符：flush和 ends。flush刷新缓冲区，但不输出任何额外的字符：ends向 缓冲区插入一个空字符，然后刷新缓冲区：

cout << "hi!" << endl;    //输出 hi 和一个换行，然后刷新缓冲区

cout « "hi!n « flush; //输出 hi，然后刷新缓冲区，不附加任何额外字符

cout « "hi ! " << ends;    //输出 hi 和一个空字符，然后刷新缓冲区

unitbuf操纵符

如果想在每次输出操作后都刷新缓冲区，我们可以使用 unitbuf 操纵符。它告诉流 在接下来的每次写操作之后都进行一次 flush 操作。而 nounitbuf 操纵符则重置流， 使其恢复使用正常的系统管理的缓冲区刷新机制：

cout << unitbuf;    //所有輪■出操作后都会立即刷新缓冲区

//任何输出都立即刷新，无缓冲

cout « nounitbuf;    //回到正常的緩冲方式

笞告：如果程序崩溃，输出缓冲区不会被刷新

如果程序异常终止，输出缓冲区是不会被刷新的。当一个程序崩溃后，它所输出的 数据很可能停留在输出缓冲区中等待打印。

当调试一个已经崩溃的程序时，需要确认那些你认为已经输出的数据确实已经刷新 了。否则，可能将大量时间浪费在追踪代码为什么没有执行上，而实际上代码已经执行 了，只是程序崩溃后缓冲区没有被刷新，输出数据被挂起没有打印而已。

关联输入和输出流

当一个输入流被关联到一个输出流时，任何试图从输入流读取数据的操作都会先刷新 关联的输出流，标准库将 cout 和 cin 关联在一起，因此下面语句

cin » ival;

导致 cout 的缓冲区被刷新。

![img](C++  Primer 5-77.jpg)



交互式系统通常应该关联输入流和输出流。这意味着所有输出，包括用户提示 信息，都会在读操作之前被打印出来

tie有两个重载的版本（参见 6.4节，第 206 页）：一个版本不带参数，返回指向输

出流的指针。如果本对象当前关联到一个输出流，则返回的就是指向这个流的指针，如果 对象未关联到流，则返回空指针。tie的第二个版本接受一个指向 ostream 的指针，将 自己关联到此 ostream。即，x. tie （&o）将流 x 关联到输出流 o。

我们既可以将一个 istream 对象关联到另一个 ostream，也可以将一个 ostream 关联到另一个 ostream：

cin. tie （Scout） ;    //仅仅是用来展示：标准库将 cin 和 cout 关联在一起

// old_tie指向当前关联到 cin 的流（如果有的话）

ostream *old_tie = cin. tie （nullptr） ; // cin 不再与其他流关联

//将 cin 与 cerr 关联；这不是一个好主意，因为 cin 应•该关联到 cout cin.tie （&cerr） ;    // 读取 cin 会刷新 cerr 而不是 cout

cin. tie （old_tie） ;    //重建 cin 和 cout 间的正常关联

在这段代码中，为了将一个给定的流关联到一个新的输出流，我们将新流的指针传递给了 tie。为了彻底解开流的关联，我们传递了一个空指针。每个流同时最多关联到一个流，

但多个流可以同时关联到同一个 ostream。

##### 8.2文件输入输出    粗

头文件 fstream 定义了三个类型来支持文件 10: if stream从一个给定文件读取数据， ofstream向一个给定文件写入数据，以及 fstream 可以读写给定文件。在 17.5.3节中 （第 676 页）我们将介绍如何对同一个文件流既读又写。

这些类型提供的操作与我们之前已经使用过的对象 cin 和 cout 的操作一样。特别是，

我们可以用 IO 运算符（＜＜和＞＞）来读写文件，可以用 getline （参见 3.2.2节，第 79 页）从一个 if stream读取数据，包括 8.1节中（第 278 页）介绍的内容也都适用于这些 类型。

除了继承自 iostream 类型的行为之外，fstream中定义的类型还增加了一些新的 成员来管理与流关联的文件，在表 8.3中列出了这些操作，我们可以对 fstream、 if stream和 ofstream 对象调用这些操作，但不能对其他 IO 类型调用这些操作。

| 表 8.3: fstream特有的操作  |                                                              |
| ------------------------- | ------------------------------------------------------------ |
| fstream fstrm;            | 创建一个未绑定的文件流。fstream是头文件 fstream 中定义的 一个类型 |
| fstream fstrm (s);        | 创建一个并打开名为 s 的文件。s可以是 string 类型，或者是一个指向 C 风格字符串的指针（参见 3.5.4节，第 109 页）。 这些构造函数都是 explicit 的（参见 7.5.4节，第 265 页）。默 认的文件模式 mode 依赖于 fstream 的类型 |
| fstream f strm (s, mode); | 与前一个构造函数类似，但按指定 mode 打开文件                   |
| fstrm.open (s)            | 打开名为 s 的文件，并将文件与 fstrm 绑定。s可以是一个 string或一个指向 C 风格字符串的指针。默认的文件 mode 依 赖于 fstream 的类型。返回 void |
| f strm.close ()           | 关闭与 fstrm 绑定的文件。返回 void                              |
| f strm.is_open ()         | 返回一个 bool 值，指出与 fstrm 关联的文件是资成功打开且尚 未关闭 |

###### 8.2.1使用文件流对象

当我们想要读写一个文件时，可以定义一个文件流对象，并将对象与文件关联起来。 每个文件流类都定义了一个名为 open 的成员函数，它完成一些系统相关的操作，来定位 给定的文件，并视情况打开为读或写模式。

创建文件流对象时，我们可以提供文件名（可选的 k 如果提供了一个文件名，则 open 会自动被调用：

if stream in （ifile） ;    II构造一个：Lf stream并打开给定文件

of stream out;    II输出文件流未关联到任何文件

这段代码定义了一个输入流 in，它被初始化为从文件读取数据，文件名由 string 类型 的参数 ifile 指定。第二条语句定义了一个输出流 out，未与任何文件关联。在新 C++

間标准中，文件名既可以是库类型 string 对象，也可以是 C 风格字符数组（参见 3.5.4节， 1 第 109 页）。旧版本的标准库只允许 C 风格字符数组。

用 fstream 代替 iostream&

我们在 8.1节（第 279 页）已经提到过，在要求使用基类型对象的地方，我们可以用 继承类型的对象来替代。这意味着，接受一个 iostream 类型引用（或指针）参数的函 数，可以用一个对应的 fstream （或 sstream）类型来调用。也就是说，如果有一个函 数接受一个 ostreamS 参数，我们在调用这个函数时，可以传递给它一个 ofstream 对 象，对 istream&和 if stream也是类似的。

例如，我们可以用 7.1.3节中的 read 和 print 函数来读写命名文件。在本例中，我 们假定输入和输出文件的名字是通过传递给 main 函数的参数来指定的（参见 6.2.5节， 第 196 页）：

//打开销售记录文件 //打开输出文件 //保存销售总额的变量 //读取第一条销售记录 //保存下一条销售记录的变量



ifstream input(argv[1]); ofstream output(argv[2]); Sales_data total; if (read(input, total))    {

Sales_data trans;

//读取剩余记录



//检查 isbn //更新销售总额

//打印结果 //处理下一本书



while(read(input, trans))    {

if (total.isbn () == trans.isbn()) total.combine(trans);

else {

print(output, total) « endl; total = trans;

}

}

print （output, total） « endl; //打印最后一本书的销售额 else    //文件中无输入数据

cerr « "No data?!" « endl;

除了读写的是命名文件外，这段程序与 229 页的加法程序几乎是完全相同的。重要的部分 是对 read 和 print 的调用。虽然两个函数定义时指定的形参分别是 istream&和 ostream&，但我们可以向它们传递 fstream 对象。

I 318〉成员函数 open 和 close

如果我们定义了一个空文件流对象，可以随后调用 open 来将它与文件关联起来:

ifstream in (ifile) ;    //构筑一个 if stream并打开给定文件

of stream out;    / /愉出文件流未与任何文件相关联

out. open (if ile + ".copy");    / / 打开指定文件

如果调用 open 失败，failbit会被置位(参见 8 丄 2 节，第 280 页)。因为调用 open 可能失败，进行 open 是否成功的检测通常是一个好习惯：

if (out) //检查 open 是否成功

// open成功，我们可以使用文件了

这个条件判断与我们之前将 cin 用作条件相似。如果 open 失败，条件会为假，我们就不 会去使用 out 了。

一旦一个文件流已经打开，它就保持与对应文件的关联。实际上，对一个已经打开的 文件流调用 open 会失败，并会导致 failbit 被置位。随后的试图使用文件流的操作都 会失败。为了将文件流关联到另外一个文件，必须首先关闭已经关联的文件。一旦文件成 功关闭，我们可以打开新的文件：

in. close () ;    // 关闭文件

in.open (ifile + "2"〉；    // 打幵另一个文件

如果 open 成功，则 open 会设置流的状态，使得 good ()为 true。

自动构造和析构

考虑这样一个程序，它的 main 函数接受一个要处理的文件列表(参见 6.2.5节，第 196页)。这种程序可能会有如下的循环：

//对每个传递给程序的文件执行循环操作

for (auto p = argv + 1; p != argv + argc; ++p)    {

ifstream input (*p);    //创建输出流并打开文件

if (input) {    //如果文件打开成功，“处理”此文件

process(input);

} else

cerr « "couldn't open: ’’ + string (*p);

} //每个循环步 input 都会离开作用域，因此会被销毁

每个循环步构造一个新的名为 input 的 ifstream 对象，并打开它来读取给定的文件。 像之前一样，我们检查 open 是否成功。如果成功，将文件传递给一个函数，该函数负责 读取并处理输入数据，如果 open 失败，打印一条错误信息并继续处理下一个文件。

因为 input 是 while 循环的局部变量，它在每个循环步中都要创建和销毁一次(参 见 5.4.1节，第 165 页)。当一个 fstream 对象离开其作用域时，与之关联的文件会自动 关闭。在下一步循环中，input会再次被创建。

###### 50 8.2.2文件模式

每个流都有一个关联的文件模式(file mode)，用來指出如何使用文件。表 8.4列出了 文件模式和它们的含义。

表 8.4:文件模式

| in     | 以读方式打开                 |
| ------ | ---------------------------- |
| out    | 以写方式打开                 |
| app    | 每次写操作前均定位到文件末尾 |
| ate    | 打开文件后立即定位到文件末尾 |
| trunc  | 截断文件                     |
| binary | 以二进制方式进行 IO           |

无论用哪种方式打开文件，我们都可以指定文件模式，调用 open 打开文件时可以， 用一个文件名初始化流来隐式打开文件时也可以。指定文件模式有如下限制：

•只可以对 of stream或 f stream对象设定 out 模式。

•只可以对 if stream或 f stream对象设定 in 模式。

•只有当 out 也被设定时才可设定 trunc 模式。

•只要 trunc 没被设定，就可以设定 app 模式。在 app 模式下，即使没有显式指定 out模式，文件也总是以输出方式被打开。

•默认情况下，即使我们没有指定 trtmc，以 out 模式打开的文件也会被截断。为 了保留以 out 模式打开的文件的内容，我们必须同时指定 app 模式，这样只会将 数据追加写到文件末尾；或者同时指定 in 模式，即打开文件同时进行读写操作(参 见 17.5.3节，第 676 页，将介绍对同一个文件既进行输入又进行输出的方法)。

• ate和 binary 模式可用于任何类型的文件流对象，且可以与其他任何文件模式组 合使用。

每个文件流类型都定义了一个默认的文件模式，当我们未指定文件模式时，就使用此默认 模式。与 ifstream 关联的文件默认以 in 模式打幵；与 ofstream 关联的文件默认以 out模式打开；与 f stream关联的文件默认以 in 和 out 模式打幵。

□20＞以 out 模式打开文件会丢弃已有数据

默认情况下，当我们打开一个 of stream时，文件的内容会被丢弃。阻止一个 of stream清空给定文件内容的方法是同时梢定 app 模式：

//在这几条语句中，filel都被截断

of stream out ("filel"); //隐含以输出模式打开文件并截断文件 of stream out2 ("filel", ofstream: :out) ; // 隐含地截断文件 ofstream out3("filel", ofstream::out | ofstream::trunc);

//为了保留文件内容，我们必须显式指定 app 模式

ofstream app("file2", of stream: : app) ; // 隐含为输出模式 ofstream app2("file2", ofstream::out | ofstream::app);

WARNING



保留被 ofstream 打开的文件中已有数据的唯一方法是显式指定或 in 模式、

每次调用 open 时都会确定文件模式

对于一个给定流，每当打开文件时，都可以改变其文件模式。

of stream out; //未指定文件打开模式

out.open ("scratchpad"}; //模式隐含设置为输出和截断

out. close () ; //关闭 out，以便我们将其用于其他文件

out. open ("precious", of stream: : app) ; // 模式为输出和追加

out.close ();

第一个 open 调用未显式指定输出模式，文件隐式地以 out 模式打幵。通常情况下，out 模式意味着同时使用 trtmc 模式。因此，当前目录下名为 scratchpad 的文件的内容将 被清空。当打开名为 precious 的文件时，我们指定了 append模式。文件中已有的数 据都得以保留，所有写操作都在文件末尾进行。

![img](C++  Primer 5-80.jpg)



在每次打开文件时，都要设置文件模式，可能是显式地设置，也可能是隐式地 设置。当程序未指定模式时，就使用默认值。

###### 8.2.2节练习

练习 8.7:修改上一节的书店程序，将结果保存到一个文件中。将输出文件名作为第二 个参数传递给 main 函数。

练习 8.8:修改上一题的程序，将结果追加到给定的文件末尾。对同一个输出文件，运 行程序至少两次，检验数据是否得以保留。

##### 8.3 string 流

<32T|



sstream头文件定义了三个类型来支持内存［O，这些类型可以向 string 写入数据， 从 string 读取数据，就像 string 是一个 10 流一样。

istringstream 从 string 读耳又数据，ostringstream 向 string 写入数据， 而头文件 stringstream 既可从 string 读数据也可向 string 写数据。与 fstream 类型类似，头文件 sstream 中定义的类型都继承自我们已经使用过的 iostream 头文件 中定义的类型。除了继承得来的操作，sstream中定义的类型还增加了一些成员来管理 与流相关联的 string。表 8.5列出了这些操作，可以对 stringstream 对象调用这些 操作，但不能对其他 10 类型调用这些操作。

| 表 8.5: stringstream特有的操作 |                                                              |
| ----------------------------- | ------------------------------------------------------------ |
| sstream s t rm;               | strm是一个未绑定的 stringstream 对象。sstream是头文件 sstream中定义的一个类型 |
| sstream strm (s);             | strm是一个 sstream 对象，保存 string s的一个拷贝。此构造函 数是 explicit 的(参见 7.5.4节，第 265 页) |
| strm.str()                    | 返回 strm 所保存的 string 的拷贝                                 |
| strm.str(s)                   | 将 string s拷贝到 strm 中。返回 void                             |

###### 8.3.1 使用 istringstream

当我们的某些工作是对整行文本进行处理，而其他一些工作是处理行内的单个单同

时，通常可以使用 istringstreamo

考虑这样一个例子，假定有一个文件，列出了一些人和他们的电话号码。某些人只有 —个号码，而另一些人则有多个——家庭电话、工作电话、移动电话等。我们的输入文件 看起来可能是这样的：

morgan 2015552368 8625550123 drew 9735550130

lee 6095550132 2015550175 8005550000

文件中每条记录都以一个人名开始，后面跟随一个或多个电话号码。我们首先定义一个简 单的类来描述输入数据：

//成员默认为公有；参见 7.2节(第 240 页) struct Personlnfo {

string name; vector<string> phones;

}；

类型 Personlnfo 的对象会有一个成员来表示人名，还有一个 vector 来保存此人的所 有电话号码。

I 322〉    我们的程序会读取数据文件，并创建一个 Personlnfo 的 vector。vector中每个

元素对应文件中的一条记录。我们在一个循环中处理输入数据，每个循环步读取一条记录， 提取出一个人名和若干电话号码：

string line, word;    //分别保存来自输入的一行和单词

vector<Person工 nfo> people;    //保存来自输入的所有记录

//逐行从输入读取数据，直至 cin 遇到文件尾(或其他错误) while (getline(cin, line))    {

Personlnfo info;    //创建一个保存此记录数据的对象

istringstream record (line) ;    // 将 i 己录彭 P 定至 0 冈 1J 读入的 4 亍

record » info.name;    // 读取名字

while (record >> word)    //读耳又电话号码

info .phones .push—back (word) ; // 保持它们

people .push_back (info) ;    // 将分匕 i 己录追加至 4 people 末尾

}

这里我们用 getline 从标准输入读取整条记录。如果 getline 调用成功，那么 line 中将保存着从输入文件而来的一条记录。在 while 中，我们定义了一个局部 Personlnfo 对象。來保存当前记录中的数据。

接下来我们将一个 istringstream 与刚刚读取的文本行进行绑定，这样就可以在 此 istringstream 上使用输入运算符来读取当前记录中的每个元素。我们首先读取人 名，随后用一个 while 循环读取此人的电话号码。

当读取完 line 中所有数据后，内层 while 循环就结束了。此循环的工作方式与前 面章节中读取 cin 的循环很相似，不同之处是，此循环从一个 string 而不是标准输入 读取数据。当 string 中的数据全部读出后，同样会触发“文件结束”信号，在 record 上的下一个输入操作会失败。

我们将刚刚处理好的 Personlnfo 追加到 vector 中，外层 while 循环的一个循环 步就随之结束了。外层 while 循环会持续执行，直至遇到 cin 的文件结朿标识。

###### 8.3.1节练习

练习 8.9：使用你为 8.1.2节（第 281 页）第一个练习所编写的函数打印一个 istringstream对象的内容。

练习 8.10:编写程序，将来自一个文件中的行保存在一个 vector<string>中。然后 使用一个 istringstream 从 vector 读取数据元素，每次读取一个单词。

练习 8.11:本节的程序在外层 while 循环中定义了 istringstream对象。如果 record对象定义在循环之外，你需要对程序进行怎样的修改？重写程序，将 record 的定义移到 while 循环之外，验证你设想的修改方法是否正确。

练习 8.12：我们为什么没有在 Personlnfo 中使用类内初始化？

###### 8.3.2 使用 ostringstream

< 323 I



当我们逐步构造输出，希望最后一起打印吋，ostringstream是很有用的。例如， 对上一节的例子，我们可能想逐个验证电话号码并改变其格式。如果所有号码都是有效的， 我们希望输出一个新的文件，包含改变格式后的号码。对于那些无效的号码，我们不会将 它们输出到新文件中，而是打印一条包含人名和无效号码的错误信息。

由于我们不希望输出有无效电话号码的人，因此对每个人，直到验证完所有电话号码 后才可以进行输出操作。但是，我们可以先将输出内容“写入”到一个内存 ostringstream 中：

for (const auto Sentry : people) { // 对 people 中每一项

ostringstream formatted, badNums; // 每个循琢步创建的对象 for (const auto &nums : entry .phones) { // 对每个数

if (!valid(nums))    {

badNums <<”’’<< nums; //将数的字符串形式存入 badNums } else

//将格式化的字符串“写入” formatted

formatted « " " << format(nums);

}

if (badNums . str () . empty () )    // 没有错误的数

os « entry.name « "    // 打印名字

« formatted. str () « endl;    // 和格式化的数

else //否则，打印名字和错误的数

cerr « "input error: " « entry.name

« " invalid number(s) " « badNums.str() « endl;

在此程序中，我们假定已有两个函数，valid和 format，分别完成电话号码验证和改变 格式的功能。程序最有趣的部分是对字符串流 formatted 和 badNums 的使用。我们使 用标准的输出运算符（《）向这些对象写入数据，但这些“写入”操作实际上转换为 string 操作，分别向 formatted 和 badNums 中的 string 对象添加字符。

###### 8.3.2节练习

练习 8.13:重写本节的电话号码程序，从一个命名文件而非 cin 读取数据。 练习 8.14:我们为什么将 entry 和 nums 定义为 const auto&?

1~324> 小结    _

C++使用标准库类来处理面向流的输入和输出：

•    iostream处理控制台 1O

•    fstream处理命名文件 IO

•    stringstream 完成内存 string 的 10

类 fstream 和 stringstream 都是继承自类 iostream 的。输入类都继承自 istream，输出类都继承自 ostream。因此，可以在 istream 对象上执行的操作，也 可在 if stream或 istringstream 对象上执行。继承自 ostream 的输出类也有类似 情况。

毎个 IO 对象都维护一组条件状态，用来指出此对象上是否可以进行 10 操作。如果遇 到了错误——例如在输入流上遇到了文件末尾，则对象的状态变为失效，所有后续输入操 作都不能执行，直至错误被纠正。标准库提供了一组函数，用來设置和检测这些状态。

##### 术语表

条件状态(condition state)可被任何流类

使用的一组标志和函数。用来指出给定流 是否可用，

文件模式(file mode)类 f stream定义的 一组标志，在打开文件时指定，用来控制 文件如何被使用。

文件流(file stream)用来读写命名文件的

流对象。除了普通的 iostream 操作，文 件流还定义了 open和 close 成员。成员 函数 open 接受一个 string 或一个 C 风 格字符串参数，指定要打开的文件名，它 还可以接受一个可选的参数，指明文件打 开模式。成员函数 close 关闭流所关联的 文件，调用 close 后才可以调用 open 打 开另一个文件。

fstream用于同时渎写一个相同文件的文 件流。默认情况下，fstream以 in 和 out 模式打开文件。

ifstream用于从输入文件读取数据的文件 流。默认情况下，ifstream以 in 模式打 开文件。



继承(inheritance)程序设计功能，令一

个类型可以从另一个类型继承接口。类 ifstream 和 istringstream 继承自 istream, ofstream 和 ©stringstream 继承自 ostream。第 15 章将介绍继承。

istringstream用来从给定 string 读取数 裾的字符串流。

ofstream用来向输出文件写入数据的文 件流。默认情况下，of stream以 out 模 式打开文件。

字符串流(string stream )用于读写

string的流对象，除了普通的 iostream 操作外，字符串流还定义了一个名为 str 的重载成员。调用 str 的无参版本会返冋 字符串流关联的 string。调用时传递给 它一个 string 参数，则会将字符串流与 该 string 的一个拷贝相关联。

stringstream用于读写治定 string 的字 符串流。

 
