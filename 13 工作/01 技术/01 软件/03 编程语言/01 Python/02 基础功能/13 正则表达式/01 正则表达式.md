# 正则表达式

正则表达式，可以：

- 验证字符串是否为某种模式，比如电话号码或者邮箱。
- 可以用来识别文档中的特定文本，完全删除该文本或者用其他文本替换它。
- 可以从字符串中提取子字符串。可以查找文档内或输入域内特定的文本。


## 字符

### 普通字符

包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。


### 非打印字符

| 字符 | 描述                                                         |
| :--- | :----------------------------------------------------------- |
| `\cx`  | 匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。 |
| `\f`   | 匹配一个换页符。等价于 \x0c 和 \cL。                         |
| `\n`   | 匹配一个换行符。等价于 \x0a 和 \cJ。                         |
| `\r`   | 匹配一个回车符。等价于 \x0d 和 \cM。                         |
| `\s`   | 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。注意 Unicode 正则表达式会匹配全角空格符。 |
| `\S`   | 匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。                  |
| `\t`   | 匹配一个制表符。等价于 `\x09` 和 `\cI`。                         |
| `\v`   | 匹配一个垂直制表符。等价于 `\x0b` 和 `\cK`。                     |
| `\d`           | 匹配一个数字字符。等价于 [0-9]。                             |
| `\D`           | 匹配一个非数字字符。等价于 [^0-9]。                          |
| `\w`           | 匹配字母、数字、下划线。等价于'[A-Za-z0-9_]'。               |
| `\W`           | 匹配非字母、数字、下划线。等价于 '[^A-Za-z0-9_]'。           |
| `\xn`          | 匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，'\x41' 匹配 "A"。'\x041' 则等价于 '\x04' & "1"。正则表达式中可以使用 ASCII 编码。 |
| `\num`         | 匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，'(.)\1' 匹配两个连续的相同字符。 |
| `\n`           | 标识一个八进制转义值或一个向后引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。 |
| `\nm`          | 标识一个八进制转义值或一个向后引用。如果 \nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm。 |
| `\nml`         | 如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。 |
| `\un`          | 匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号 (?)。 |

（上面一些普通字符还有些没有很清楚）

### 特殊字符

若要匹配这些特殊字符，必须首先使字符"转义"，即，将反斜杠字符`\` 放在它们前面。

| 特别字符 | 描述                                                         |
| :------- | :----------------------------------------------------------- |
| `$`        | 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 '\n' 或 '\r'。要匹配 `$` 字符本身，请使用 `\$`。 |
| `( )`      | 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 `\(` 和 `\)`。 |
| `*`        | 匹配前面的子表达式零次或多次。要匹配 `*` 字符，请使用 `\*`。     |
| `+`        | 匹配前面的子表达式一次或多次。要匹配 `+` 字符，请使用 `\+`。     |
| `.`        | 匹配除换行符 \n 之外的任何单字符。要匹配 `.` ，请使用 `\.` 。  所以模式 `^.5$` 与任何两个字符的、以数字5结尾和以其他非"新行"字符开头的字符串匹配。模式 `.` 可以匹配任何字符串，除了空串和只包括一个`"新行"`的字符串。  |
| `[`        | 标记一个中括号表达式的开始。要匹配 `[`，请使用 `\[`。            |
| `?`        | 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 `?` 字符，请使用 `\?`。 |
| `\`        | 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， 'n' 匹配字符 'n'。'\n' 匹配换行符。序列 '\\' 匹配 "\"，而 '\(' 则匹配 "("。 |
| `^`        | 匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用 `\^`。 |
| `{`        | 标记限定符表达式的开始。要匹配 {，请使用 `\{`。                |
| `\|`       | 指明两项之间的一个选择。要匹配 `\|`，请使用 `\|`。               |



### 限定符

限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 `*` 或 `+` 或 `?` 或 `{n}` 或 `{n,}` 或 `{n,m}` 共6种。


| 字符  | 描述                                                         |
| :---- | :----------------------------------------------------------- |
| `*`     | 匹配前面的子表达式零次或多次。例如，zo* 能匹配 "z" 以及 "zoo"。* 等价于{0,}。 |
| `+`     | 匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。+ 等价于 {1,}。 |
| `?`     | 匹配前面的子表达式零次或一次。例如，"do(es)?" 可以匹配 "do" 、 "does" 中的 "does" 、 "doxy" 中的 "do" 。? 等价于 {0,1}。 |
| `{n}`   | n 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 "Bob" 中的 'o'，但是能匹配 "food" 中的两个 o。 |
| `{n,}`  | n 是一个非负整数。至少匹配n 次。例如，'o{2,}' 不能匹配 "Bob" 中的 'o'，但能匹配 "foooood" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*'。 |
| `{n,m}` | m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。例如，"o{1,3}" 将匹配 "fooooood" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。 |

备注：

-  `?` 与 `{0,1}` 是相等的
-  `*` 与 `{0,}` 是相等的
-  `+` 与 `{1,}` 是相等的


举例：

- 从 1 开始的整数：`[1-9][0-9]*`
  - `[1-9]`设置第一个数字不是 0，`[0-9]*` 表示任意多个 `[0-9]`
  - 不使用 + 限定符，因为在第二个位置或后面的位置不一定需要有一个数字。
  - 也不使用 ? 字符，因为使用 ? 会将整数限制到只有两位数。
- 0~99 的两位数，包括 01：`[0-9]{1,2}`
- 1~99 的正整数：`[1-9][0-9]?` 或 `[1-9][0-9]{0,1}`


贪婪与非贪婪：

- `*`、`+` 限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个`?`就可以实现非贪婪或最小匹配。

举例：

```py
import re

str = "<h1>this is a test</h1>"
print(re.match(r'<.*>', str))
print(re.match(r'<.*?>', str))
print(re.match(r'<\w+?>', str))
```

输出：

```
<re.Match object; span=(0, 23), match='<h1>this is a test</h1>'>
<re.Match object; span=(0, 4), match='<h1>'>
<re.Match object; span=(0, 4), match='<h1>'>
```

说明：

- `贪婪：`下面的表达式匹配从开始小于符号 (<) 到关闭 h1 标记的大于符号 (>) 之间的所有内容。
- `非贪婪：`如果您只需要匹配开始和结束 h1 标签，下面的非贪婪表达式只匹配 `<h1>`。
- 通过在 `*`、`+` 或 `?` 限定符之后放置 `?`，该表达式从"贪婪"表达式转换为"非贪婪"表达式或者最小匹配。


### 定位符

定位符使您能够将正则表达式固定到行首或行尾。它们还使您能够创建这样的正则表达式，这些正则表达式出现在一个单词内、在一个单词的开头或者一个单词的结尾。

定位符用来描述字符串或单词的边界，`^` 和 `$` 分别指字符串的开始与结束，`\b` 描述单词的前或后边界，`\B` 表示非单词边界。

正则表达式的定位符有：

| 字符 | 描述                                                         |
| :--- | :----------------------------------------------------------- |
| `^`    | 匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。 |
| `$`    | 匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \n 或 \r 之前的位置匹配。 |
| `\b`   | 匹配一个单词边界，即字与空格间的位置。                       |
| `\B`   | 非单词边界匹配。                                             |


注意：

- 不能将限定符与定位符一起使用。由于在紧靠换行或者单词边界的前面或后面不能有一个以上位置，因此不允许诸如 `^\`* 之类的表达式。
- 若要匹配一行文本开始处的文本，请在正则表达式的开始使用 `^` 字符。不要将 `^` 的这种用法与中括号表达式内的用法混淆。
- 若要匹配一行文本的结束处的文本，请在正则表达式的结束处使用 `$` 字符。


举例：

- 匹配一个章节标题，该标题只包含两个尾随数字，并且出现在行首：`^Chapter [1-9][0-9]{0,1}`
- 不仅出现行的开始处，而且它还是该行中仅有的文本：`^Chapter [1-9][0-9]{0,1}$`
- `\bCha`、`ter\b`、`\Bapt`


## 运算符优先级

正则表达式从左到右进行计算，并遵循优先级顺序，这与算术表达式非常类似。

相同优先级的从左到右进行运算，不同优先级的运算先高后低。下表从最高到最低说明了各种正则表达式运算符的优先级顺序：

| 运算符                      | 描述                                                         |
| :-------------------------- | :----------------------------------------------------------- |
| `\`                           | 转义符                                                       |
| `()`, `(?:)`, `(?=)`, `[]`          | 圆括号和方括号                                               |
| `*`, `+`, `?`, `{n}`, `{n,}`, `{n,m}`   | 限定符                                                       |
| `^`, `$`, `\任何元字符`、`任何字符` | 定位点和序列（即：位置和顺序）                               |
| `\|`                          | 替换，"或"操作 字符具有高于替换运算符的优先级，使得"m\|food"匹配"m"或"food"。若要匹配"mood"或"food"，请使用括号创建子表达式，从而产生"(m\|f)ood"。 |



## 捕获子匹配与非捕获元

捕获：

- `()` 。一个正则表达式模式或部分模式两边添加圆括号，将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 `\n` 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。


可以使用非捕获元字符来重写捕获，忽略对相关匹配的保存。

非捕获元：

- `(?:pattern)` 匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。
  - 举例：这在使用 "或" 字符 (\|) 来组合一个模式的各个部分是很有用。例如， `industr(?:y\|ies)` 就是一个比 `industry\|industries` 更简略的表达式。
- `(?=pattern)` 正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。
  - 例如，`Windows(?=95\|98\|NT\|2000)` 能匹配"Windows2000"中的"Windows"，但不能匹配"Windows3.1"中的"Windows"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。即：如果上面的表达式匹配 Windows 98，将在 Windows 之后而不是在 98 之后继续搜索。
- `(?!pattern)` 正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。
  - 例如 `Windows(?!95\|98\|NT\|2000)` 能匹配"Windows3.1"中的"Windows"，但不能匹配"Windows2000"中的"Windows"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。
- `(?<=pattern)` 反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。
  - 例如，"`(?<=95|98|NT|2000)Windows`"能匹配"`2000Windows`"中的"`Windows`"，但不能匹配"`3.1Windows`"中的"`Windows`"。
- `(?<!pattern)` 反向否定预查，与正向否定预查类似，只是方向相反。
  - 例如：`(?<!95|98|NT|2000)Windows` 能匹配"3.1Windows"中的"Windows"，但不能匹配"2000Windows"中的"Windows"。



清晰的说法：

- `(?<=Expression)` 
  - 逆序肯定环视，表示所在位置左侧能够匹配Expression
- `(?<!Expression)`
  - 逆序否定环视，表示所在位置左侧不能匹配Expression
- `(?=Expression)`
  - 顺序肯定环视，表示所在位置右侧能够匹配Expression
- `(?!Expression)`
  - 顺序否定环视，表示所在位置右侧不能匹配Expression

**举例1：**

- 使用匹配正则表达式匹配两个相同的字母，而不要匹配三个相同的字母

```py
import re

reg = r'(?<!a)aa(?!a)'
print(re.match(reg, 'aaa'))
print(re.match(reg, 'aa'))
```

输出：

```txt
None
<re.Match object; span=(0, 2), match='aa'>
```




**举例2：**

- 查找文本中两个相同的相邻单词的匹配项

```py
import re

str = "Is is the cost of of gasoline going up up"
reg = r'\b([a-z]+) \1\b'
print(re.findall(reg, str))
```

输出：

```txt
['of', 'up']
```

说明：

- `\1` 是对 `[a-z]+` 捕获的子匹配项的引用，
- 单词边界元字符确保只检测整个单词。否则，诸如 "is issued" 或 "this is" 之类的词组将不能正确地被此表达式识别。

疑问：

- js 的例子中，是 `\b([a-z]+) \1\b/ig` ，说全局标记 `g` 指定将该表达式应用到输入字符串中能够查找到的尽可能多的匹配。不区分大小写 `i` 标记指定不区分大小写。 python 里有吗？

**举例3：**

- 将通用资源指示符 (URI) 分解为其组件。假定您想将下面的 URI 分解为协议（ftp、http 等等）、域地址和页/路径：

```py
import re

str = "http://www.runoob.com:80/html/html-tutorial.html"
reg = r'(\w+):\/\/([^/:]+)(:\d*)?([^# ]*)'
print(re.match(reg, str).groups())
```

输出：

```txt
('http', 'www.runoob.com', ':80', '/html/html-tutorial.html')
```

说明：

- `\w+` 用于捕获 Web 地址的协议部分。该子表达式匹配在冒号和两个正斜杠前面的任何单词。
- `[^/:]+` 用于捕获地址的域地址部分。子表达式匹配非 `:` 和 `/` 之后的一个或多个字符。<span style="color:red;">有点没明白</span>
- `:\d*` 用于捕获端口号（如果指定了的话）。该子表达式匹配冒号后面的零个或多个数字。`?` 只能重复一次该子表达式。
- `[^# ]*` 用于捕获 Web 地址指定的路径和 / 或页信息。该子表达式能匹配不包括 # 或空格字符的任何字符序列。




## 常用表达式


- `[AaEeIiOoUu]` //匹配所有元音字符
- `[a-z]` //匹配所有的小写字母 
- `[A-Z]` //匹配所有的大写字母 
- `[a-zA-Z]` //匹配所有的字母 
- `[0-9]` //匹配所有的数字 
- `[0-9\.\-]` //匹配所有的数字，句号和减号 
- `[ \f\r\t\n]` //匹配所有的白字符
- `[^a-z]` //除了小写字母以外的所有字符 
- `[^\\\/\^]` //除了(\)(/)(^)之外的所有字符 
- `[^\"\']` //除了双引号(")和单引号(')之外的所有字符
- `^[a-zA-Z0-9_]{1,}$`      // 所有包含一个以上的字母、数字或下划线的字符串 
- `^[1-9][0-9]{0,}$`        // 所有的正整数 
- `^\-{0,1}[0-9]{1,}$`      // 所有的整数 
- `^[-]?[0-9]+\.?[0-9]+$`   // 所有的浮点数
- `^\s*$/`      匹配空行。
- `<\s*(\S+)(\s[^>]*)?>[\s\S]*<\s*\/\1\s*>` 匹配 HTML 标记。   

- `[\u4e00-\u9fa5]` 匹配中文
  - `^[\u4E00-\u9FA5]{2,4}$` 2~4个汉字
- `[a-zA-Z]` 英文字母
  - `^[A-Za-z]+$`　　//匹配由 26 个英文字母组成的字符串
  - `^[A-Z]+$`　　//匹配由 26 个英文字母的大写组成的字符串
  - `^[a-z]+$`　　//匹配由 26 个英文字母的小写组成的字符串
  - `^[A-Za-z0-9]+$`　　//匹配由数字和 26 个英文字母组成的字符串
  - `^w+$`　　//匹配由数字、26个英文字母或者下划线组成的字符串
- `[0-9]` 数字
- `^[\u4e00-\u9fa5_a-zA-Z0-9]+$` 匹配中文，英文字母和数字及下划线
  - `[\u4e00-\u9fa5_a-zA-Z0-9_]{4,10}` 同时判断输入长度
  - `[a-zA-Z0-9_\u4e00-\u9fa5]+`　至少一个汉字、数字、字母、下划线
  - `^[\u4e00-\u9fa5]{1,7}$|^[\dA-Za-z_]{1,14}$` 最长不得超过 7 个汉字，或 14 个字节(数字，字母和下划线)
  - `^[a-zA-Z0-9_\u4e00-\u9fa5]+$` 只含有汉字、数字、字母、下划线，下划线位置不限：
- `(?!_)`　　不能以`_`开头
- `(?!.*?_$)`　　不能以`_`结尾
- `^\w+$` 由数字、26个英文字母或者下划线组成的字符串 
- `[^x00-xff]` 匹配双字节字符(包括汉字在内)。可以用来计算字符串的长度（一个双字节字符长度计 2，ASCII字符计 1）
- `ns*r` 匹配空白行的正则表达式。可以用来删除空白行
- `<(S*?)[^>]*>.*?|<.*? />` 匹配 HTML 标记的正则表达式。仅仅能匹配部分，对于复杂的嵌套标记依旧无能为力
- `^s*|s*$` 匹配首尾空白字符的正则表达式。可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式

- `^[a-zA-Z0-9][\w\.-]*[a-zA-Z0-9]@[a-zA-Z0-9][\w\.-]*[a-zA-Z0-9]\.[a-zA-Z][a-zA-Z\.]*[a-zA-Z]$` 匹配 Email 地址的正则表达式。表单验证时很实用
- `^((13[0-9])|(14[0-9])|(15[0-9])|(17[0-9])|(18[0-9]))\d{8}$` 手机号。
- `(^\d{15}$)|(^\d{17}([0-9]|X|x)$)` 身份证。
- `[a-zA-z]+://[^s]*` 匹配网址 URL 的正则表达式。
- `^[a-zA-Z][a-zA-Z0-9_]{4,15}$` 匹配帐号是否合法(字母开头，允许 5-16字节，允许字母数字下划线)。表单验证时很实用
- `d{3}-d{8}|d{4}-d{7}` 匹配国内电话号码。匹配形式如 `0511-4405222` 或 `021-87888822`

- `[1-9][0-9]{4,}` 匹配腾讯 QQ 号。腾讯 QQ 号从 10000 开始
- `[1-9]d{5}(?!d)` 匹配中国邮政编码。中国邮政编码为 6 位数字
- `d{15}|d{18}` 匹配身份证。中国的身份证为 15 位或 18 位
- `d+.d+.d+.d+` 匹配 ip 地址。提取 ip 地址时有用


- `^[1-9]d*$`　 　 //匹配正整数
  - `^-[1-9]d*$` 　 //匹配负整数
  - `^-?[1-9]d*$`　　 //匹配整数
  - `^[1-9]d*|0$`　 //匹配非负整数（正整数 + 0）
  - `^-[1-9]d*|0$`　　 //匹配非正整数（负整数 + 0）
  - `^[1-9]d*.d*|0.d*[1-9]d*$`　　 //匹配正浮点数
  - `^-([1-9]d*.d*|0.d*[1-9]d*)$`　 //匹配负浮点数
  - `^-?([1-9]d*.d*|0.d*[1-9]d*|0?.0+|0)$`　 //匹配浮点数
  - `^[1-9]d*.d*|0.d*[1-9]d*|0?.0+|0$`　　 //匹配非负浮点数（正浮点数 + 0）
  - `^(-([1-9]d*.d*|0.d*[1-9]d*))|0?.0+|0$`　　//匹配非正浮点数（负浮点数 + 0）
- 输入验证：
  - 只能输入数字：“`^[0-9]*$`”
  - 只能输入 n 位的数字：“`^d{n}$`”
  - 只能输入至少 n 位数字：“`^d{n,}$`”
  - 只能输入 m-n位的数字：“`^d{m,n}$`”
  - 只能输入零和非零开头的数字：“`^(0|[1-9][0-9]*)$`”
  - 只能输入有两位小数的正实数：“`^[0-9]+(.[0-9]{2})?$`”
  - 只能输入有 1-3位小数的正实数：“`^[0-9]+(.[0-9]{1,3})?$`”
  - 只能输入非零的正整数：“`^+?[1-9][0-9]*$`”
  - 只能输入非零的负整数：“`^-[1-9][0-9]*$`”
  - 只能输入长度为 3 的字符：“`^.{3}$`”
  - 只能输入由 26 个英文字母组成的字符串：“`^[A-Za-z]+$`”
  - 只能输入由 26 个大写英文字母组成的字符串：“`^[A-Z]+$`”
  - 只能输入由 26 个小写英文字母组成的字符串：“`^[a-z]+$`”
  - 只能输入由数字和 26 个英文字母组成的字符串：“`^[A-Za-z0-9]+$`”
  - 只能输入由数字、26个英文字母或者下划线组成的字符串：“`^w+$`”
  - `^[a-zA-Z]w{5,17}$` 验证用户密码。以字母开头，长度在 6-18之间，只能包含字符、数字和下划线。
  - 验证是否含有`^%&',;=?$"`等字符：“`[^%&',;=?$x22]+`”
  - 只能输入汉字：“`^[u4e00-u9fa5],{0,}$`”
  - 验证 Email 地址：“`^w+[-+.]w+)*@w+([-.]w+)*.w+([-.]w+)*$`”
  - 验证 InternetURL：“`^http://([w-]+.)+[w-]+(/[w-./?%&=]*)?$`”
  - 验证身份证号（15位或 18 位数字）：“`^d{15}|d{}18$`”
  - 验证一年的 12 个月：“`^(0?[1-9]|1[0-2])$`”正确格式为：“01”-“09”和“1”“12”
  - 验证一个月的 31 天：“`^((0?[1-9])|((1|2)[0-9])|30|31)$`”
  - 正确格式为：“01”“09”和“1”“31”。
  - 匹配中文字符的正则表达式： `[u4e00-u9fa5]`
  - 匹配双字节字符(包括汉字在内)：`[^x00-xff]`
  - 匹配空行的正则表达式：`n[s| ]*r`
  - 匹配 HTML 标记的正则表达式：`/<(.*)>.*|<(.*) />/`
  - 匹配首尾空格的正则表达式：`(^s*)|(s*$)`
  - 匹配 Email 地址的正则表达式：`w+([-+.]w+)*@w+([-.]w+)*.w+([-.]w+)*`
  - 匹配网址 URL 的正则表达式：`http://([w-]+.)+[w-]+(/[w- ./?%&=]*)?`

