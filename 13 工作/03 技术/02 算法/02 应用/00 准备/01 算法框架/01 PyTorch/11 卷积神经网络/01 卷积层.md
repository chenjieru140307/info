---
title: 01 卷积层
toc: true
date: 2019-06-15
---
# 可以补充进来的

- 基本没什么新的。拆掉。
- 
# 卷积层

卷积是分析数学中一种很重要的运算，这里面我们只介绍离散形式的卷积。在图像上，对图像用一个卷积核进行卷积运算，实际上是一个滤波的过程。卷积实际上是提供了一个权重模板，这个模板在图像上滑动，并将中心依次与图像中每一个像素对齐，然后对这个模板覆盖的所有像素进行加权，并将结果作为这个卷积核在图像上该点的响应。

如果输入的是一张图片，首先把输入图像分解成可以被卷积层处理的矩阵，把卷积核作用于输入的不同的区域，然后产生对应的特征图，如图 7.2所示。


<p align="center">
    <img width="70%" height="70%" src="http://images.iterate.site/blog/image/20190615/eMBgTrrQOuHd.png?imageslim">
</p>


下面我们来看一看具体怎么操作的？

关于卷积层我们先来看什么叫卷积操作：图 7.3较大网格表示一幅图片，卷积核 Kj 的大小为 2×2。假设我们做步长为 1 的卷积操作，表示卷积核每次向右移动一个像素(当移动到边界时回到最左端并向下移动一个单位)。在卷积网络中，每个稀疏过滤器通过共享权值都会覆盖整个可视域，这些共享权值的单元构成一个特征映射卷积核。一方面，重复单元能够对特征进行识别，而不考虑它在可视域中的位置。另一方面，权值共享使得我们能更有效地进行特征抽取，因为它极大地减少了需要学习的自由变量的个数。通过控制模型的规模，卷积网络对视觉问题可以具有很好的泛化能力，每个单元内都有权重。


<p align="center">
    <img width="70%" height="70%" src="http://images.iterate.site/blog/image/20190615/vmb909avQkYv.png?imageslim">
</p>

图 7.3的卷积核内有 4 个权重。在卷积核移动的过程中，将图片上的像素和卷积核的对应权重相乘，最后将所有乘积相加得到一个个 $(4-2+1)×(4-2+1)=3×3 $ 的特征图。假设上一层的图大小是 n×n，卷积核的大小是 k×k，则该层的图大小是 $(n-k+1)×(n-k+1)$。

有时候我们会遇到每次移动步长较大，导致窗口的滑动出现不能刚好从头到尾的情况。于是就出现了 zero-padding 操作进行补零，保证窗口的滑动能刚好从头到尾。举个例子，$(4-2+1)×(4-2+1)=3×3 $ 刚好能够整除，所以窗口左侧贴着数据开始位置，滑到尾部刚好窗口右侧能够贴着数据尾部位置，因此是不需要补零的。如果滑动步长设为 3，第一次计算之后，窗口就无法滑动了，而尾部的数据，就没有计算，因此补零能够解决这个问题。我们可以发现，窗口滑动步长设定越短，两次滑动取得的数据，重叠部分越多，但是窗口停留的次数也会越多，运算量大。窗口滑动步长设定越长，两次滑动取得的数据，重叠部分越少，窗口停留次数也越少，运算量小，但是从一定程度上说，数据信息不如上面丰富了。



# 相关

- 《深度学习框架 Pytorch 快速开发与实战》
