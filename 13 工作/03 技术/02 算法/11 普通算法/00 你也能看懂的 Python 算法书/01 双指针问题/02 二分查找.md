
# 二分查找

用模拟指针的方法完成了数组的合并后，我们再来看看如何用指针实现有序数组的二分查找。

## 什么是二分查找

第二个问题也是有关有序数组的问题。如何快速在一个有序数组中准确地找到一个元素的位置呢？这就要用到本节要讲到的中心知识点-二分查找了。

二分查找又叫作折半查找，意思为每次查找后，查找的范围都折半。这样查找到最后，查找范围内只剩一个数时，判断它是否为要查找的数。如果是，就记录它的位置；如果不是，则要查找的数不在这个数组中。

现在，用图来了解一下二分查找。有一列体积从小到大有序排列的球。我们想要找到其中体积为 4 的球，该怎么做呢？

如果使用普通的遍历方法，如图 2.9和图 2.10所示，需要对每一个球进行判断，直到找到体积相同的球为止。用这种方法会使耗时大大增加。在元素较少的情况下，消耗的时间差异并不明显，但当整个序列中元素较多时（如上万个元素），使用二分查找的优势就十分明显了。


<p align="center">
    <img width="70%" height="70%" src="http://images.iterate.site/blog/image/20190625/cNVh4tbHHKQL.png?imageslim">
</p>


<p align="center">
    <img width="70%" height="70%" src="http://images.iterate.site/blog/image/20190625/iBVCIaoYeHAL.png?imageslim">
</p>

我们来看看换成二分查找的做法，把要查找的球从体积为 4 的球换成体积为 6 的球。

<p align="center">
    <img width="70%" height="70%" src="http://images.iterate.site/blog/image/20190625/abOQcnJagn5F.png?imageslim">
</p>

如图 2.11所示，二分查找需要两个指针，一个指向数组的第一个元素，叫作头指针；另一个指向数组最后一个元素的后方，叫作尾指针。假如最后一个元素的下标是 7，那么尾指针存储的值则是 8。要查找的范围是在头指针和尾指针之间的所有元素（包括头指针指向的元素但不包括尾指针指向的元素）。

初始化之后，需要找到查找范围中的中间数，也就是处于中间位置的元素。可以通过把头指针和尾指针的值相加再除以 2 来得到中间数的下标值。在这个问题中，（0+8）/2=4。把下标 4 指向的元素与要查找的元素做比较：8 > 6。

因为这是一个从小到大有序排列的数组，所以要查找的元素必定在 8 前面，它的下标一定小于 4。所以，给尾指针赋值 4，让它指向 8，把查找范围缩小到下标 0～4，进入图 2.12所示的状态。

<p align="center">
    <img width="70%" height="70%" src="http://images.iterate.site/blog/image/20190625/uC8svTJG0v9h.png?imageslim">
</p>

再一次对头指针和尾指针存储的下标值进行计算，求出中间数的下标，（0+5）//2=2（只取整数部分）。下标 2 指向的元素为 4，把 4 和 6 做比较，4 < 6。与之前同理，要查找的元素必定在 4 后面，它的下标一定大于 2。所以，我们给头指针赋值 2 来缩小查找范围，如图 2.13所示。

<p align="center">
    <img width="70%" height="70%" src="http://images.iterate.site/blog/image/20190625/H0dtFL7Awlj8.png?imageslim">
</p>

重复之前的操作，计算得出中间数的下标为 3。把下标 3 指向的数与 6 对比，发现 6=6。这时，就可以结束查找并记录元素的下标 3 了。

## 问题求解

在 2.2.1节中，我们用一个长为 7 的数组演示了二分查找。在本节中，我们要用程序实现一个有 15 个元素的数组`[1,3,5,6,7,8,13,14,15,17,18,24,30,43,56]`的二分查找。

由于整个查找过程将要重复相似的操作，并且不确定总共的查找次数，因此使用 `while` 循环来进行查找。当头指针和尾指针之间只剩一个数时，不需要再重复进行查找而可以直接进行判断，所以把 while 循环的条件设为下面的语句：

```
while tail-head !=1:
```


然后要编写头指针和尾指针之间只剩一个数时用于判断的语句。这里也用到了本章第一小节中提到的 `while...else` 语句：如果`while`循环因为`break`而结束，证明查找已经完成，不需要再判断一遍了。

有人可能会问，为什么不用判断尾指针指向的数，而只用判断头指针指向的数呢？在题目的开始可以看到，尾指针的定义是指向查找范围中最后一个数的后面的指针，它本身是不包含在查找范围内的。

接下来要编写`while`内部的语句。每一次`while`都是一次操作，最后的结果要么是移动头指针，要么是移动尾指针，要么是直接找到结果。这段话应该已经给了你提示，要采用 `if...elif...`语句来实现。下面就是我们的程序了：



## 最终代码

二分查找的最终代码如代码 2.2所示。

```py
def search_num_in_list(numbers, search):
    head, tail = 0, len(numbers)  # 数组长度刚好是最大下标值+1

    while tail - head > 1:  # 当尾指针 tail 减头指针 head 等于 1 时，查找范围内只 head 有指向的数
        mid = (head + tail) // 2  # mid存储中间数的下标，//2代表对/2的结果舍去分数部分取整
        if search < numbers[mid]:  # search是我们要搜索的元素，如果它小于 mid 指向的元素
            tail = mid
        if search > numbers[mid]:  # 如果 search 小于 mid 指向的元素
            head = mid + 1  # mid指向的元素小于 search，所以不用把它保留在范围内
        if search == numbers[mid]:
            ans = mid
            break  # 找到元素的话就直接结束
    else:
        if search == numbers[head]:
            ans = head
        else:
            ans = -1  # 如果数组中没有这个元素，那么输出-1
    return ans


numbers = [1, 3, 5, 6, 7, 8, 13, 14, 15, 17, 18, 24, 30, 43, 56]
ans = search_num_in_list(numbers, 8)
print(ans)
ans = search_num_in_list(numbers, 56)
print(ans)
ans = search_num_in_list(numbers, 0)
print(ans)
```

输出：


```
5
14
-1
```

程序说明：

- 这个还是比较容易看懂的，嗯。

你可以随意更改数组中已有的元素，也可以随意输入数值来验证二分查找。

二分查找问题到这里就解决了。




# 相关

- 《你也能看得懂的 python 算法书》
