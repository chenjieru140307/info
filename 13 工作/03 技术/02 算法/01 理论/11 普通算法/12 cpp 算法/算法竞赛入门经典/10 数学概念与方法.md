
10章 数学概念与方法

学习目标

E熟练掌握扩展欧几里德算法和它的时间复杂度 叵熟练掌握用筛法构造素数表，了解素数定理 E学会求二元线性不定方程的整数解

E熟练掌握模运算规则、快速幂取模算法和模线性方程的解法 E熟悉杨辉三角、二项式定理和组合数的基本性质 E学会推导约数个数公式和欧拉函数公式 E熟练掌握可重集全排列的编码和解码算法

E理解样本空间、事件和概率，学会用组合计数的方法计算离散概率 叵理解条件概率的概念和计算方法 叵理解连续概率和数学期望的概念和计算方法 E熟悉常见计数序列，如 Fibonacci 数列、Catalan数列等 E熟悉建立递推关系的基本方法、常见错误和实现技巧

没有数学就没有算法；没有好的数学基础，也很难在算法上有所成就。本章介绍算法竞

赛中涉及的常见数学概念和方法，包括数论、排列组合、递推关系和离散概率等。

###### 10.1 数论初步

数论被“数学王子”高斯誉为整个数学王国的皇后。在算法竞赛中，数论常常以各种面貌

出现，但万变不离其宗，大部分数论题目并不涉及多少特殊的知识，但对数学思维和能力要

求较高。本节介绍几个最为常用的算法，并通过例题展示一些常用的思维方式。

10.1.1 欧几里德算法和唯一分解定理

除法表达式。给出一个这样的除法表达式：；/;/；厂../;，其中；是正整数。除法

表达式应当按照从左到右的顺序求和，例如，表达式 1/2/1/2的值为 1/4。但可以在表达式中

嵌入括号以改变计算顺序，例如，表达式(1/2)/(1/2)的值为 1。

输入；，    ；，    ...，Xk ，判断是否可以通过添加括号，使表达式的值为整

数。 K<10000， Xi<109。

分析】

表达式的值一定可以写成的形式：^是其中一些七的乘积，而 5 是其他数的乘积。不 难发现，X2必须放在分母位置，那其他数呢？

幸运的是，其他数都可以在分子位置：

E=XJ(X,iX,/^X^



林'…A



![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-193.jpg)



接下来的问题就变成了：判断冗是否为整数。

第 1 种方法是利用前面介绍的高精度运算：k次乘法加一次除法。显然，这个方法是正确

的，但却比较麻烦。

第 2 种方法是利用唯一分解定理，把 X2 写成若干素数相乘的形式：

![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-194.jpg)



然后依次判断每个的约数。这次不用高精度乘法了，只需把所 有^中巧的指数加起来。如果结果比％小，说明还会有巧约不掉，因此冗不是整数。这种方法 在第 5 章中已经用过，这里不再赘述。

第 3 种方法是直接约分：每次约掉^和為的最大公约数 gcd(A, A2)，则当且仅当约分结束 后；=1时冗为整数，程序如下：

int judge(int* X) {

X[2] /= gcd(X[2], X[1]);

for(int i = 3; i <= k; i++) X[2] /= gcd(X[i], X[2]); return X[2] == 1;

}

整个算法的时间效率取决于这里的 gcd 算法。尽管依次试除也能得到正确的结果，但还 有一个简单、高效，而且相当优美的算法——辗转相除法。它也许是最广为人知的数论算 法。

辗转相除法的关键在于如下恒等式：gcd(A^) = gcd(6, mod幻。它和边界条件 gcd(^, 0)=^一起构成了下面的程序：

int gcd(int a, int b) { return b == 0 ? a : gcd(b, a%b);

这个算法称为欧几里德算法(Euclid algorithm )。既然是递归，那么免不了问一句：会 栈溢出吗？答案是不会。可以证明，gcd函数的递归层数不超过 4.785lg^    +    1.6723，其

中#=max{^6}。值得一提的是，让 gcd 递归层数最多的是 gcdCF^&j，其中&是后文要介绍 的 Fibonacci 数。

利用 gcd 还可以求出两个整数和的最小公倍数 lcm(^力)。这个结论很容易由唯一分解定 理得到。设

a = Px' P疒…P，

b = p'f' p/2 …p/r

则

gcd(a,Z?)=乃吨〜广⑽…夕，，/；} lcm(6Z，Z0 = prn^Ml} p^{e2,f2} .. . p^{er,fr}

由此不难验证 gcd(^力)*lcm(^力)=^*办。不过即使有了公式也不要大意。如果把 lcm 写成 a * b/gcd(a,b)，可能会因此丢掉不少分数——a*b可能会溢出！正确的写法是先除后乘，即 a/gcd(a,b) * b。这样一来，只要题面上保证最终结果在 int 范围之内，这个函数就不会出错。 但前一份代码却不是这样：即使最终答案在 int 范围之内，也有可能中间过程越界。注意这样 的细节，毕竟算法竞赛不是数学竞赛。

10.1.2 Eratosthenes 筛法

无平方因子的数。给出正整数《和讲，区间[«，    m]内的“无平方因子”的数有多少个？整

数^无平方因子，当且仅当不存在 A>1，使彳得是女 2 的倍数。1$ 必 m^1012，m-«<107。

【分析】

对于这样的限制，直接枚举判断会超时：需要判断 107 个整数，而每个整数还需要花费

一定的时间判断是否没有平方因子。怎么办呢？在介绍具体算法之前，需要学会用 Eratosthenes筛法构造 1 的素数表。

筛法的思想特别简单：对于不超过《的每个非负整数^，删除 2A 3A 4p，...，当处理完所 有数之后，还没有被删除的就是素数。如果用 vis[i]表示/已经被删除，筛法的代码可以写 成：

memset(vis, 0, sizeof(vis));

for(int i = 2; i <= n; i++) for(int j = i*2; j <= n; j+=i) vis[j] = 1;

尽管可以继续改进，但这份代码已经相当高效了。为什么呢？给定外层循环变量/，内 层循环的次数是- , i这样，循环的总次数小于    。这个结论来

源于欧拉在 1734 年得到的结果：-丁-丁——-=kn.,.，其中欧拉常数产 0.577218。这 样低的时间复杂度允许在很短的时间内得到 106 以内的所有素数。

下面来改进这份代码。首先，在“对于不超过 n 的每个非负整数中^可以限定为素数 ——只需在第二重循环前加一个判断 if(!vis[i])即可。另外，内层循环也不必从/*2开始——它 已经在/=2时被筛掉了。改进后的代码如下：

int m = sqrt(n+0.5);

memset(vis, 0, sizeof(vis));

for(int i = 2; i <= m; i++) if(!vis[i]) for(int j = i*i; j <= n; j+=i) vis[j] = 1;

这里有一个有意思的问题：给定的 n , c的值是多少呢？换句话说，不超过 n 的正整数 中，有多少个是素数呢？

素数定理：「I .」

lnx

其中，我表示不超过的素数的个数。上述定理的直观含义是：它和 x/lnx比较接近—— 对于算法入门来说，这已足够。表 10-1给出了一些值来加深读者的印象。

表 10-1 素数定理的直观验证

| N     | 102  | 103  | 104  | 105  | 106   | 107    | 108     |
| ----- | ---- | ---- | ---- | ---- | ----- | ------ | ------- |
| 酬    | 25   | 168  | 1229 | 9592 | 78498 | 664579 | 5761455 |
| n/lnn | 22   | 145  | 1086 | 8686 | 72382 | 620421 | 5428681 |

最后回到原题：如何求出区间内无平方因子的数？方法和筛素数是类似的：对于不超过: 的所有素数^ ，筛掉区间[n, m]内的所有倍数。

10.1.3 扩展欧几里德算法

直线上的点。求直线 ox+^y+c=0上有多少个整点(x,y)满足妖^，勾，yeLy^ys]。

【分析】

在解决这个问题之前，首先学习扩展欧几里德算法——找出一对整数(x，y)，使得似+吵= gcd(^，^)。注意，这里的和 y 不一定是正数，也可能是负数或者 0。例如，gcd(6,15)=3 , 6*3-

15*1=3，其中^=3，尸-1。这个方程还有其他解，如^=-2，y=1。 下面是扩展欧几里德算法的程序：

void gcd(int a, int b, int& d, int& x, int& y) {

if(!b){ d = a; x = 1; y = 0; }

else{ gcd(b, a%b, d, y, x); y -= x*(a/b); }

}

用数学归纳法并不难证明算法的正确性，此处略去。注意在递归调用时，和 y 的顺序变 了，而边界也是不难得出的：gcd(^,0)=1*^-0*0=^。这样，唯一需要记忆的是 y-=x*(W)，哪 怕暂时不懂得其中的原因也不要紧。

上面求出了 ax+^y=gcd(“力)的一组解(^乃)，那么其他解呢？任取另外一组解(x2,y2)，

则^+咖二^+批(它们都等于 gcd(a》))，变形得^^2)=办加-乃)。假设 gcd(^》)=g，方程 左右两边同时除以[g](#bookmark9)[m](#bookmark9)，得“'(^-^2)=^' (y2-y1)，其中“'=“/g，b'=blg。注意，此时和 b 互素， 因此^-^一定是 b 的整数倍。设它为妫'，计算得 y2-y1=^'。注意，上面的推导过程并没有用 到“似+by的右边是什么”，因此得出如下结论。

提示 10-1 :设 a, b, c为任意整数。若方程 3 乂+匕丫=〔的一组整数解为(x0,y0)，则它的任 意整数解都可以写成(x0+kb', y0-ka')，其中 a'=a/gcd(a,b)，b'=b/gcd(a,b)，k取任意整数。

有了这个结论，移项得似+by=-c，然后求出一组解即可。例如：

例 1 : 6^+15y=9。根据欧几里德算法，已经得到了 6x(-2)+15x1=3，两边同时乘以 3 得 6x(-6)+15^3=9，即_x=-6，y=3时 6_x+15y=9。

例 2 : 6^+15=8，两边除以 3 得 2 针 5=8/3。左边是整数，右边不是整数，显然无解。综合 起来，有下面的结论。

提示 10-2 :设 a, b, c为任意整数，g=gcd(a,b)，方程 ax+by=g的一组解是(x0,y0)，则 当 c 是 g 的倍数时 ax+by=c的一组解是(x0c/g, y0c/g)；当 c 不是 g 的倍数时无整数解。

这样，即完整地解决了本问题。顺便说一句，本题的名称为什么叫“直线上的点”呢？这 是因为在平面坐标系下，ox+^y+c=0是一条直线的方程。

10.1.4 同余与模算术

你需要花多少时间做下面这道题目呢？

123456789*987654321=( )

A．121932631112635266

B．121932631112635267

C．121932631112635268

D．121932631112635269

既然是选择题，不必费力把答案完整地计算出来——4个选项的个位数都不相同，因此

只需要计算出答案的最后一位即可。不难得出，它等于 1*9=9。把刚才的解题过程抽象出来

就是下面的式子：

123456789*987654321 mod10=((123456789 mod10)*(987654321 mod10)) mod10

其中 mod 表示除以的余数，C语言表达式是 a °% ^。在本章中，一定是正整数，尽 管办＜ 0时表达式 a °% b也是合法的(但 b=0时会出现除零错)。

不难得到下面的公式：

(ei + b) mod n = ((a mod /?) + (/; mod /?)) mod/?

( a - b) mod n =    — (Z)mod/?) + n) mod n

abniod n = (amod n)(b mod n)mod/?

注意在减法中，由于 mod n可能小于 b mod n ，需要在结果加上 n ，而在乘法中，需要注 意 a mod n和 b mod n相乘是否会溢出。例如，当 n=109时，ab mod n—定在 int 范围内，但 a mod n和 b mod n的乘积可能会超过 int。需要用 long long保存中间结果，例如：

int mul_mod(int a, int b, int n) {

return (int)((long long)a * b % n);

}

当然，如果《本身超过 int 但又在 long long范围内，上述方法就不适用了。在这种情况下，

建议初学者使用高精度乘法——尽管有办法可以避免，但技巧性很强，不推荐初学者学习。

大整数取模。输入正整数《和讲，输出《 mod m的值。«<10100，m<109。

【分析】

首先，把大整数写成“自左向右”的形式： 1234=((1*10+2)*10+3)*10+4，然后用前面的公 式，每步取模，例如：

| scanf(" | %s%d", n, &m);  |                      |            |
| ------- | --------------- | -------------------- | ---------- |
| int len | = strlen(n);    |                      |            |
| int ans | = 0;            |                      |            |
| for(int | i = 0; i < len; | i++)                 |            |
| ans     | = (int)(((long  | long)ans*10 + n[i] - | '0') % m); |
| printf( | "%d\n",ans);    |                      |            |

当然，也可以把 ans 声明成 long long类型的，然后在输出时临时转换为 int，但要注意乘法 溢出的问题。

幕取模。输入正整数“、《和讲，输出 mod m的值。久《，m<109。

【分析】

很容易写出下面的代码：

int pow_mod(int a, int n, int m) { int ans = 1;

for(int i = 0; i < n; i++) ans = (int)((long long)ans * n % m);

这个函数的时间复杂度为 0(«)，当《很大时速度很不理想。有没有办法算得更快呢？可

以利用分治法：

int pow_mod(int a, int n, int m) { if(n == 0) return 1; int x = pow_mod(a, n/2, m); long long ans = (long long)x * x % m; if (n%2 == 1) ans = ans * a % m; return (int)ans;

}

例如， “29=(“14)2*“，而“14=(“7)2， “7=(“3)2*“， “3=“2*“，一共只做了 7 次乘法。不知读者

有没有发现，上述递归方式和二分查找很类似——每次规模近似减小一半。因此，时间复杂 度为 O(log«)，比 0(«)好了很多。

模线性方程组。输入正整数 b, «，解方程似三 b(mod «)。“, b, «<109。

【分析】

本题中出现了一个新记号：同余。辰 b(mod «)的含义是““和 b 关于模《同余”，即“ mod « = b mod n。 不难得出，^=b(mod «)的充要条件是：“-6是《的整数倍。

提示 10-3 : aEb(mod n)的含义是“a和 b 除以 n 的余数相同〃，其充要条件是“a-b是 n 的整 数倍”。

这样，原来的方程就可以理解成：似功是《的正整数倍。设这个“倍数”为 y，则似-b=吵， 移项得 fla-«y=b，这恰好就是 10.1.3节介绍的不定方程(“，《，b是已知量，和 y 是未知数)！ 接下来的步骤不再介绍。唯一需要说明的是，如果^是方程的解，满 feEy( mo d «)的其他整 数 y 也是方程的解。因此，当谈到同余方程的一个解时，其实指的是一个同余等价类。

尽管算法已无须继续讨论，有一个特殊情况需要引起读者重视。b=1时，似三 1(mod«)的 解称为“关于模《的逆( inverse) ，它类似于实数运算中“倒数”的概念。什么时候“的逆存在 呢？根据上面的讨论，方程 ox-«y=1要有解。这样，1必须是 gcd(a，《)的倍数，因此“和《必须互 素(即 gcd(^，《)=1 )。在满足这个条件的前提下，ox=1(mod «)只有唯一解。注意，同余方程 的解是指一个等价类。

提示 10-4 :方程 axEl(mod n)的解称为 a 关于模 n 的逆。当 gcd(a,n)=1时，该方程有唯 一解；否则，该方程无解。

10.1.5 应用举例

例题 10-1 巨大的斐波那契数！( Colossal Fibonacci Numbers!, UVa11582 )

输入两个非负整数仏办和正整数《 ( 0<a，b<264，1<«<1000 )，你的任务是计算/(ab)除 以《的余数。其中/(0)=/(1)=1，且对于所有非负整数/，f(i+2)=f(i+1)+f(i)。

【分析】

所有计算都是对《取模的，不妨设 F(i)=f：i) mod «。不难发现，当二元组(F(i), F(i+1))出现 重复时，整个序列就开始重复。例如，《=3，序列 F(i)的前 10 项为 1，1，2,0,2,2，1，0，1，1，第 9、10 项和前两项完全一样。根据递推公式，第 11 项会等于第 3 项，第 12 项等于第 4 项……

多久会出现重复呢？因为余数最多《种，所以最多《2项就会出现重复。设周期为 M，则 只需计算出汽 0)〜汽《2)，然后算出汽 ab)等于其中的哪一项即可。

例题 10-2 不爽的裁判(Disgruntled Judge, NWERC 2008, UVa12169 )

有个裁判出的题太难，总是没人做，所以他很不爽。有一次他终于忍不住了，心 想： “反正我的题没人做，我干嘛要费那么多心思出题？不如就输入一个随机数，输出一个

随机数吧。 ”

于是他找了 3 个整数^、a和 b，然后按照递推公式 x^axw+b) mod 10001计算出了一个长 度为 27 的数列，其中 7 是测试数据的组数。然后，他把 7 和卩 x3，…，x2F-i写到输入文件中，x2, x4，…，x27写到了输出文件中。

你的任务就是解决这个疯狂的题目：输入 7,    x3，…，x27-1，输出 x2, x4，…，x2T。输入保

证 7<100，且输入的所有 x 值为 0〜10000的整数。如果有多种可能的输出，任意输出一个即 可。

如果知道了 a ，就可以计算出_x2 ，进而根据■Xg^ax^+b) mod 10001算出 b。有了 a 和 b ,

就可以在 0(7)时间内计算出整个序列了。如果在计算过程中发现和输入矛盾，则这个 a 是非 法的。由于 a 是 0〜10000的整数(因为递推公式对 10001 取模)，即使枚举所有的 a ，时间效

率也足够高。

例题 10-3 选择与除法(Choose and Divide, UVa10375 )

已知 C(m，n)    = m!/(n!(m-n)!)，输入整数几    r,    (p>q , r>s , p，q，r，s^10000 )，计

算 C(p，q)/C(r，s)。输出保证不超过 108 ，保留 5 位小数。

【分析】

本题正是唯一分解定理的用武之地。组合数 C(m，n)的性质将在 10.2.1节中介绍，本题只 需要用到它的定义。

首先，求出 10000 以内的所有素数 primes ，然后用数组 e 表示当前结果的唯一分解式中各 个素数的指数。例如，e={1，0，2，0，0，0，...}表示 21*52=50。主程序如下：

while(cin >> p >> q >> r >> s) { memset(e, 0, sizeof(e)); add_factorial(p, 1); add_factorial(q, -1); add_factorial(p-q, -1); add_factorial(r, -1); add_factorial(s, 1); add_factorial(r-s, 1); double ans = 1;

for(int i = 0; i < primes.size(); i++) ans *= pow(primes[i], e[i]);

printf("%.5lf\n", ans);

}

其中 add_factorial(n，d)表示把结果乘以(n!)d ，它的实现如下：

//乘以或除以 n. d=0表示乘，d=-1表示除

void add_integer(int n, int d) { for(int i = 0; i < primes.size(); i++) {

while(n % primes[i] == 0) { n /= primes[i]; e[i] += d;

}

if(n == 1) break; // 提前终止循环，节约时间

}

}

void add_factorial(int n, int d) { for(int i = 1; i <= n; i++)

add_integer(i, d);

}

例题 10-4最小公倍数的最小和(Minimum Sum LCM, UVa10791 )

输入整数《 ( 1<n<231 )，求至少两个正整数，使得它们的最小公倍数为 n，且这些整数 的和最小。输出最小的和。

【分析】

本题再次用到了唯一分解定理。设唯一分解式"二“/1^/2..，不难发现每个“广作为一个 单独的整数时最优。

如果就这样匆匆编写程序，可能会掉入陷阱。本题有好几个特殊情况要处理：n=1时答 案为 1+1=2 ; n只有一种因子时需要加个 1，还要注意 n=231-1时不要溢出。

例题 10-5 GCD等于 XOR ( GCD XOR, ACM/ICPC Dhaka 2013, UVa12716 )

输入整数打(1<n<30000000 )，有多少对整数(“，b)满足：1<b<a<n，且 gcd(a，b)=“ XOR b。例如 n=7时，有 4 对：(3,2)，(5,4)，(6,4)，(7,6)。

本题看上去很难找到简洁的数学公式，因为 gcd 和 xor 看上去似乎毫不相干。不过 xor 的好 处是：a xor b = c，则 a xor c = b，所以可以枚举 a 和 c，然后算出 6=0! xor c，最后验证一下是 否有 gcd（a，b）=c。时间复杂度如何？因为 c 是 a 的约数，所以和素数筛法类似，时间复杂度 为《/1+«/2+...+«/«=0（«log^）。再加上 gcd 的时间复杂度为 0（log«），所以总的时间复杂度 为 O（n（logn）2）。

我们还可以做得更好。上述程序写出来之后，可以打印一些满足 gcd（a，b）=a xor b=c的三 元组（a，b，c），然后很容易发现一个现象 ： c=a-b。

证明如下：不难发现 a-b^a xor b，且 a-b^c。假设存在 c 使得 a-b>c，则 c<a-b^a xor b， 与 c=a xor b矛盾。

有了这个结论，还是沿用上述算法，枚举 a 和 c，计算 b=a-c，则 gcd（a，b）=gcd（a，a-c）=c， 因此只需验证是否有 c = a xor b，时间复杂度降为了 0（«log«）。

###### 10.2 计数与概率基础

排列与组合是最基本的计数技巧。本节介绍一些基本的相关知识和方法，供读者参考 加法原理。做一件事情有 n 个办法，第/个办法有 p/种方案，则一共^i+p^u+PM种方

案。

乘法原理。做一件事情有 n 个步骤，第/个步骤有 p^方案，则一共有 p1p2...pn种方案。

乘法原理是加法原理的特殊情况（按照第一步骤进行分类），二者都可用于递推。注意

应用加法原理的关键是分类：各类别之间必须没有重复、没有遗漏。如果有重复，可以使用

容斥原理。

容斥原理。假设班里有 10 个学生喜欢数学， 15个学生喜欢语文， 21个学生喜欢编程，

一共有多少个学生呢？是 10+15+21=46个吗？不是的，因为有些学生可能同时喜欢数学和语

文，或者语文和编程，甚至还可能有三者都喜欢的。为了叙述方便，将喜欢语文、数学、编

程的学生集合分别用或 5, C表示，则学生总数等于|^U5UC|。刚才已经说了，如果把这 3 个集 合的元素个数凶、网、|C|直接加起来，会有一些元素重复统计了，因此需要扣掉 4 门 5|、

|mC|、|Cn^|，但这样一来，又有一小部分多扣了，需要加回来：i^amCi。这样，就得到了 一个公式：

|AU5UC|=|A|+|5|+|C|-|An5|-|5nC|-|CnA|+|An5nC|

一般地，对于任意多个集合，都可以列出这样一个等式，其中左边是所有集合的并的元

素个数，右边是这些集合的“各种搭配”。每个“搭配”都是若干个集合的交集，且每一项前面

的正负号取决于集合的个数——奇数个集合为正，偶数个集合为负。

有重复元素的全排列。有&个元素，其中第/个元素有^个，求全排列个数。

【分析】

令所有 nz 之和为 n，再设答案为 X。首先做全排列，然后把所有元素编号，其中第 s 种元素

编号为 1 ~ns （例如，有 3 个 a，两个 b，先排列成 aabba，然后可以编号为 ap^^a］）。这样

做以后，由于编号后所有元素均不相同，方案总数为 n 的全排列数 n!。根据乘法原理，得到 了一个方程 :n1!n2!n3!...nkX!=n!， 移项即可。

可重复选择的组合。有 n 个不同元素，每个元素可以选多次，一共选&个元素，有多少 种方法？例如，n=3，A=2时有 6 种:(1,1)，(1,2)，(1,3)，(2,2)，(2,3)，(3,3)。

【分析】

设第/个元素选'个，问题转化为求方程^+x2+...+_xn4的非负整数解的个数。令 yz=xz+1，

则答案 Sy1+y2+...+yn=^+n的正整数解的个数。想象有奸 1 个数字“1”排成一排，则问题等价

于：把这些“1”分成 n 个部分，有多少种方法？这相当于在奸 n-1个“候选分隔线”中选 n-1个， 即 C(k+n-1，n-1 )=C(n+k- 1，k)。

10.2.1 杨辉三角与二项式定理

组合数(。在组合数学中占有重要地位。与组合数相关的最重要的两个内容是杨辉三角和

n

二项式定理。如图 10-1所示就是一个杨辉三角

13 3 1 14 6 4 1 1 5 10 W 5 1 1 6 15 20 15 6 1

图 10-1 杨辉三角

另一方面，把(a+b)n展开，将得到一个关于的多项式：

(a + /))[’= 1

(a + b)x =a + b

(a + b )2 =a2 + 2ab + h2

(a + bY =a:' + 3a~b + 3a b:' +b:'

(a + hf =a + 4a b + 6a2b" + 4ab^ + //

系数正好和杨辉三角一致。一般地，有二项式定理：

Jt=O

这不难理解：^+6)"是《个括号连乘，每个括号里任选一项乘起来都会对最后的结果有一

个贡献。如果选了&个 a，就一定会选《-&个 b，最后的项自然就是 aw-^b^。而从《个“里选女个 (同时也相当于《个 6 里选个)有{:种方法，这也是组合数的定义。

给定《，如何求出(a+b)"中所有项的系数呢？ 一个方法是用递推，根据杨辉三角中不难发 现的规律，可以写出如下程序：

memset(C, 0, sizeof(C));

for(int i = 0; i <= n; i++) {

C[i][0] = 1;

for(int j = 1; j <= i; j++) C[i][j] = C[i-1][j-1] + C[i-1][j];

}

但遗憾的是，这个算法的时间复杂度是 0("2)——尽管只用了杨辉三角的第"行的"+1个 元素，却把全部"行的 0("2)个元素都计算了 一遍。

![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-195.jpg)



另一个方法是利用等式，    ，从 O 开始从左到右递推，例如：

C[0] = 1;

for(int i = 1;



n; i++) C[i] = C[i-1]*(n-i+1)/i;

注意，应该先乘后除，因为 C[i-1]/i可能不是整数。但这样一来增加了溢出的可能 性 ——即使最后结果在 int 或 long long范围之内，乘法也可能溢出。如果担心这样的情况出现， 可以先约分，不过一般来说是不必要的。

尽管等式,_ "    -的“实际意义”不是很明显，却很容易用组合数公式< -

"    a "    "    A!(/7-A-)!

证明，读者不妨一试。

例题 10-6 无关的元素(Irrelevant Elements, ACM/ICPC NEERC 2004, UVa1635 )

对于给定的 n 个数 ah a2，…，an，依次求出相邻两数之和，将得到一个新数列。重复上述

操作，最后结果将变成一个数。问这个数除以 m 的余数与哪些数无关？例如 n=3，m=2时，第 一次求和得到 a^a2，a2+a3，再求和得到 ai+2a2+a3，它除以 2 的余数和“2无关。

1<n<105，2<m<109。

【分析】

显然最后的求和式是 aha2，…，an的线性组合。设“2的系数为/(/)，则和式除以 m 的余数 与口，无关，当且仅当/(/)是 i 的倍数。不妨看一个简单的例子：

![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-196.jpg)



<7j + 2<72 + a3 cix + 3<72 + 3“3 + “4 + 4队 + 6<73 + 4c/4 + a5

看到最后的结果，你想到了什么？没错， “1 4 6 4 1”正是杨辉三角的第 5 行！不难证明， 在一般情况下，最后 az 的系数是这样，问题就变成了 C r _中有哪些是 m 的 倍数。

还记得二项式展开的方法吗？理论上，利用此方法可以递推出所有 e -，但它们太大了， 必须用高精度才能存得下。但此问题中所关心的只是“哪些是 m 的倍数”，受到数论部分中的 启发，只需要依次计算 m 的唯一分解式中各个素因子在(_中的指数即可完成判断。这些指数 仍然可以用，    递推，并且不会涉及高精度。有的读者可能会尝试直接递推每个

系数除以 m 的余数，但遗憾的是，递推式中有除法，而模 m 意义下的逆并不一定存在。

10.2.2 数论中的计数问题

约数的个数。给出正整数 n 的唯一分解式/, & /, ...＜，求 n 的正约数的个数。

【分析】

不难看出，n的任意正约数也只能包含'A，巧，等素因子，而不能有新的素因子出现。对 于 n 的某个素因子 A，它在所求约数中的指数可以是 0，1, 2,…，a^az+1种情况，而且不同的素 因子之间相互独立。根据乘法原理，n的正约数个数为：

k

XI + 1) = (^1 + 1)(^2 + I)…(叫 + 1)

/=]

小于《且与《互素的整数个数。给出正整数 n 的唯一分解式-    ，求 1, 2, 3,

…，n中与 n 互素的数的个数。

【分析】

用容斥原理。首先从总数 n 中分别减去是 A， p2，…，pk的倍数的个数(对于素数 p 来

说，“与 p 互素”和“不是 p 的倍数”等价)，即    ，然后加上“同时是两个素因子

P' P2 Pk

的倍数”的个数    ，再减去“同时是 3 个素因子的倍数”——写成一个“学术

P'Pl P'P3 Pk-xPk

味比较浓”的公式就是：

P⑻

Pi

StP2 >'

■，pU

这里引入的新记号列"）就是题目中所求的结果，称为欧拉函数。强烈建议初学者花一些 时间理解这个公式。对于（A，巧，…，&｝的任意子集^，“不与其中任何一个互素”的元素个数 是^。不过这一项的前面是加号还是减号呢？这取决于中的元素个数——奇数个就是“减

P^s

号”，偶数个就是“加号”。

公式已得出，可计算起来很不方便。如果直接根据公式，需要计算多达 2&项的代数和， 甚至可能比“暴力枚举（依次判断 1〜"中每个数是否与"互素）”还要慢。

下一步并不显然。上述公式可以变形成如下的形式：

（p、n、二 w（l--（I--）*，，（1--）

Pi Pk

从而只需要 0（幻的计算时间，在刚才的基础上大大提高了效率。为什么这个式子和上一 个等价呢？直接考虑新公式的“展开方式”即可。展开式的每一项是从每个括号各选一个（选 1或者-丄），全部乘起来以后再乘以"得到。这不正是最初的推导过程吗？

Pi

如果没有给出唯一分解式，需要用试除法依次判断^内的所有素数是否是"的因子。这 样，则需要先生成▲内的素数表。但其实并不用这么麻烦：只需要每次找到一个素因子之后 把它“除干净”，即可保证找到的因子都是素数（想一想，为什么）。

int euler_phi(int n) { int m = (int)sqrt(n+0.5); int ans = n;

for(int i = 2; i <= m; i++) if(n % i == 0) { ans = ans / i * (i-1); while(n % i == 0) n /= i;

}

if(n > 1) ans = ans / n * (n-1); return ans;

}

1〜《中所有数的欧拉 phi 函数值。并不需要依次计算。可以用与筛法求素数非常类似的 方法，在 O（nloglogn）时间内计算完毕，例如（原理请读者体会）：

| void phi_ | table(int | n,   | int* phi) {         |
| --------- | --------- | ---- | ------------------- |
| for(int   | i = 2; i  | <=   | n; i++) phi[i] = 0; |
| phi[1]    | = 1;      |      |                     |
| for(int   | i = 2; i  | <=   | n; i++) if(!phi[i]) |

for(int j = i; j <= n; j += i) {

if(!phi[j]) phi[j] = j; phi[j] = phi[j] / i * (i-1);

例题 10-7 交表(Send a Table, UVa10820 )

有一道比赛题目，输入两个整数 x、y （ 1<x，y<n ），输出某个函数/（x，y）。有位选手想交 表（即事先计算出所有的 Xx，y），写在源代码里），但是表太大了，源代码超过了比赛的限 制，需要精简。

好在那道题目有一个性质，使得很容易根据/（x，y）算出 Xx*k，    y*k）（其中 k 是任意正整

数），这样有一些/（x，y）就不需要存在表里了。

输入 n （ n<50000 ），你的任务是统计最简的表里有多少个元素。例如，n=2时有 3 个： （1，1）， （1，2）， （2，1）。

【分析】

本题的本质是：输入 n，有多少个二元组（x，y）满足：1<x，y<n，且 x 和 y 互素。不难发现除 了（1,1）之外，其他二元组（x，y）中的 x 和 y 都不相等。设满足 x<y的二元组有 Xn）个，那么答案就 是 2f（n）+1。

对照欧拉函数的定义，可以得至!j/(n)=phi(2)+phi(3)+...+phi(n)，时间复杂度

为 O(nloglogn)。

10.2.3 编码与解码

两个 a、一个和一个 c 组成的所有串可以按照字典序编号为： aabc(1)、 aacb(2)、 abac(3)、 . 、 cbaa(12)

任给一个字符串，能否方便地求出它的编号呢？例如，输入 aca^，则应输出 5。

下面直接求解一般情况的问题(并不限定字母的种类和个数)。设输入串为^，记硪 5)

为 S 的各个排列中，字典序比 5 小的串的个数，则可以用递推法求解硪 5)，如图 10-2所示。

其中边上的字母表示“下一个字母”，/(>)表示多重集^的全排列个数。例如，根据第一个 字母，可以把字典序小于 ca^a的字符串分为 3 种：以 a 开头的，以开头的，以 c 开头的，分别 对应成 ca^a)的 3 棵子树。以 a 开头的所有串的字典序都小于 ca^a，所以剩下的字符可以任意排 列，个数为 Xc^a)；同理，以开头的所有串的字典序也都小于 ca^a，个数为 Xcaa)；以 c 开头 的串字典序不一定小于 ca^a，关键要看后 3 个字符，因此这部分的个数为硪 a^a)，还需要继续 往下分。

至于/函数的求解，大部分组合数学书籍中均有介绍：设字符一共有 k 类，个数分别为 nh n2，…，nk，则这个多重集的全排列个数为

不难算出，，,=11'；二--二:，其他/值分别为/(c办 a)=6，/(b)=1，故 d(caba)=/(cba)+ /(caa)+/(b)=3+6+1=10。既然“比它小”的个数是 10，序号自然就是 11 了。

“给物体一个编号”称为编码，同理也有“解码”，即根据序号构造出这个物体。这个过程

和刚才的很接近：依次确定各个位置上的字母即可。例如，要求出序号为 8(因此有 7 个比它

小)的字符串，推理过程如图 10-3所示。

![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-198.jpg)



d(ba)



![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-199.jpg)



f(b) d(a)



图 10-3 字符串解码的递推过程



图 10-2 字符串编码的递推过程



例题 10-8 密码(Password, ACM/ICPC Daejon 2010, UVa1262 )

给两个 6 行 5 列的字母矩阵，找出满足如下条件的“密码”：密码中的每个字母在两个矩阵 的对应列中均出现。例如，左数第 2 个字母必须在两个矩阵中的左数第 2 列中均出现。例如， 图 10-4中，COMPU和 DPMAG 都满足条件。

![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-201.jpg)



![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-202.jpg)



字典序最小的 5 个满足条件的密码分别是：ABGAG、ABGAS、ABGAU、ABGPG和 ABGPS。给定 k( 1<k<7777 )，你的任务是找出字典序第 k 小的密码。如果不存在，输出

NO。

【分析】

本题是一个经典的解码问题。首先把不可能出现在答案中的字母排除。例如在上面的例 子中，第 1 个字母只能是｛A，C，D，W｝，第 2 个字母只能是｛B，O，P｝，第 3 个字母只能是 ｛G，M，O，X｝，第 4 个字母只能是｛A，P｝，第 5 个字母只能是｛G，S，U｝。

不管第 1 个字母是多少，后 4 个字母都有 3*4*2*3=72种可能，因此当 k<72时，第 1 个字母 是 A，当 72<k<144时第 1 个字母是 C，如此等等。再用同样的方法确定第 2，3，4，5个字母即 可。

由于 k<7777，本题还有一个取巧的方法：直接按照字典序从小到大的顺序递归一个一个 的枚举。虽然代码比递推法要长，但是由于思维难度小，往往能在更短的时间内写完、写 对。

10.2.4 离散概率初步

关于概率有一套很深的理论，不过很多和概率相关的问题并不需要特别的知识，熟悉排

列组合就够了。

第 1 个例子是：连续抛 3 次硬币，恰好有两次正面的概率是多少？用 H 和 T 来表示正面和 背面(取自英文单词 head 和 tail )，则一共有 8 种可能的情况：HHH、HHT、HTH、HTT、

THH、THT、TTH、TTT。根据我们对硬币的认识，这 8 种情况出现的可能性相同，概率各为 1/8。用概率论的专业术语说，这里的｛HHH、HHT、HTH、HTT、THH、THT、TTH、TTT｝ 称为样本空间(Sample Space )。所求的是“恰好有两次正面”这个事件(Event)的概率。借 助于集合的记号，这个事件可以表示为｛HHT，HTH，THH｝，其概率为 3/8。

提示 10-5 :如果样本空间由有限个等概率的简单事件组成，事件 E 的概率可以用组合计

数的方法得到：/    。

第 2 个例子是：如果一间屋子里有 23 个人，那么“至少有两个人的生日相同”的概率超过

50%。为了简单起见，假定已知每个人的生日都不是 2 月 29 日。

尽管看上去复杂了许多，其实这个例子和抛硬币是类似的。每个人的生日是 365 天中等 概率随机选择的，因此样本空间大小冏=36523。接下来需要计算“至少有两个人生日相同”的 情况有多少种。这个数目不太好直接统计，所以统计“任何两个人的生日都不相同”的数目， 然后用总数减去它即可。公式不难得到：

![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-203.jpg)



不管是/，还是 36523 都无法储存在 mt 或者 lo



ng long中，但概率是实数，并且此处并不需



要太高的精度，所以可以直接计算，例如：

double P(int n, int m) {

double ans = 1.0; for(int i = 0; i < m; return ans;

}

double birthday(int n, double ans = P(n, m); for(int i = 0; i < m; return 1 - ans;



i++) ans *= (n-i);



int m) {



i++) ans /= n;



函数 birthday(365,23)的返回值为 0.5073，即 50.73°%。别高兴得太早，我们来算一算 birthday(365,365)。直观上，365个人中几乎肯定会有两个人的生日相同，因此 birthday(365,365)应该返回一个很接近 1 的值。可结果呢？很不幸，返回值为-1.#INF0000 连 double 都溢出了。

解决方案是边乘边除，而不是连着乘 m 次，然后再连着除 m 次。例如：

double birthday(int n, int m) { double ans = 1.0;

for(int i = 0; i < m; i++) ans *= (double)(n-i) / n;

本例说明：正如数论和组合计数中要注意 mt 和 long long溢出一样，在概率计算中要注意 double溢出。顺便说一句，这个“改进版”程序其实有个直接的概率意义：

n n n    n

其中，乓表示“第/个人的生日不和前面的人重复”这个事件。上面的公式用到了这样一个

结论：如果有 n 个相互独立的事件，则它们同时发生的概率是每个事件单独发生的概率的乘

积，像计数中的乘法原理一样。看上去很直观吧？但严格的定义需要用到“条件概率”的知

识。

条件概率。在概率计算中，条件概率扮演了重要的作用。公式如下：

P(A|B) = P(AB) | P(B)

这里，P(4B)是指，在事件 5 发生的前提下，事件乂发生的概率，而 P(45)是指两个事 彳件 4 和 5 同时发生的概率。前面所说的两个事件 M 独立就是指 P(45)=PG4)PCB)。

条件概率中还有一个重要的公式，即贝叶斯公式： P(A|5)=P(5|A) * P(A)/P(5)

全概率公式。计算概率的一种常用方法是：样本空间 5 分成若干个不相交的部分 51， 52， …，Bn，则尸(4)=P(摩 1)*尸(51) + P(4|52)*P(52)+…+P(4|5n)*P(5n)。

公式看上去复杂，但其实思路很简单。例如，参加比赛，得一等奖、二等奖、三等奖和 优胜奖的概率分别为 0.1、 0.2、 0.3和 0.4，这 4 种情况下，你会被妈妈表扬的概率分别为 1.0、 0.8、 0.5、 0.1，则你被妈妈表扬的总概率为 0.1*1.0+0.2*0.8+0.3*0.5+0.4*0.1=0.45。使用全概 率公式的关键是“划分样本空间”，只有把所有可能情况不重复、不遗漏地进行分类，并算出 每个分类下事件发生的概率，才能得出该事件发生的总概率。

例题 10-9 决斗(Headshot, ACM/ICPC NEERC 2009, UVa1636 )

首先在手枪里随机装一些子弹，然后抠了一枪，发现没有子弹。你希望下一枪也没有子 弹，是应该直接再抠一枪(输出 SHOOT )呢，还是随机转一下再抠(输出 ROTATE )？如果

两种策略下没有子弹的概率相等，输出 EQUAL。

手枪里的子弹可以看成一个环形序列，开枪一次以后对准下一个位置。例如，子弹序列 为 0011 时，第一次开枪前一定在位置 1 或 2（因为第一枪没有子弹），因此开枪之后位于位置 2或 3。如果此时开枪，有一半的概率没有子弹。序列长度为 2〜100。

【分析】

直接抠一枪没子弹的概率是一个条件概率，等于子串 00 的个数除以 00 和 01 总数（也就是

0的个数）。转一下再抠没子弹的概率等于 0 的比率。

设子串 00 的个数为^，0的个数为^，则两个概率分别是和^n。问题就是比较⑽和办 2。 前者大就是 SHOOT，后者大就是 ROTATE。

例题 10-10 奶牛和轿车(Cows and Cars, UVa10491 )

有这么一个电视节目：你的面前有 3 个门，其中两扇门里是奶牛，另外一扇门里则藏着

奖品——一辆豪华小轿车。在你选择一扇门之后，门并不会立即打开。这时，主持人会给你

个提示，具体方法是打开其中一扇有奶牛的门（不会打开你已经选择的那个门，即使里面是

牛）。接下来你有两种可能的决策：保持先前的选择，或者换成另外一扇未开的门。当然，

你最终选择打开的那扇门后面的东西就归你了。

在这个例子里面，你能得到轿车的概率是 2/3（难以置信吧！），方法是总是改变自己 的选择。 2/3这个数是这样得到的：如果选择了两个牛之一，你肯定能换到车前面的门，因 为主持人已经让你看了另外一个牛；而如果你开始选择的就是车，就会换成剩下的牛并且输 掉奖品。由于你的最初选择是任意的，因此选错的概率是 2/3。也正是这 2/3的情况让你能换 到那辆车（另外 1/3的情况你会从车切换到牛）。

现在把问题推广一下，假设有头牛，M两车（门的总数为^+^ ），在最终选择前主持人 会替你打开 c 个有牛的门（1<^<10000，1<^<10000，0<c<^），输出“总是换门”的策略下，赢 得车的概率。

【分析】

使用全概率公式。打开 c 个牛门后，还剩^-c头牛，未开的门总数是好卜 c，其中有好卜 c-1个门可以换（称为“可选门”），换到门的概率就是“可选门”的总数除以“可选门中车门的个

数”。

情况 1: 一开始选了牛(概率^ / (好幻)，则可选门中车门有个。这种情况的总概率

为 a/(a+b) * b/(a+b-c-1)。

情况 2 :—开始选了车(概率为 W (a+b))，则可选门中车门只有 b-1个，概率为 b/(a+b) * (b-1)/(a+b-c-1)。

加起来得(ab+b(b-1)) / ((a+b)(a+b-c-1))。

例题 10-11 条件概率(Probability|Given, UVa11181 )

有《个人准备去超市逛，其中第/个人买东西的概率是 Pz。逛完以后你得知有 r 个人买了东

西。根据这一信息，请计算每个人实际买了东西的概率。输入《 ( 1分 $20 )和〃(0<r<n )， 输出每个人实际买了东西的概率。

【分析】

“r个人买了东西”这个事件叫冗，“第/个人买东西”这个事件为馬，则要求的是条件概 率 P(EE)。根据条件概率公式，P(EE) = P(EE) / P(E)。

P(E)依然可以用全概率公式。例如，n=4，r=2，有 6 种可能：1100, 1010, 1001, 0110, 0101, 0011，其中 1100 的概率为 Pi*P2*(1-P3)*(1-P4)，其他类似，设置 4 幻表示第女个人是否买 东西(1表示买，0表示不买)，则可以用递归的方法枚举恰好有 r 个 4 幻=1的情况。

如何计算 P(EE)呢？方法一样，只是枚举的时候要保证第 4i]=1。不难发现，其实可以

用一次枚举就计算出所有的值。用 tot 表示上述概率之和，sum[i]表示 4i]=1的概率之和，则答 案为 P(Ei)/P(E)=sum[i]/tot。

例题 10-12 纸牌游戏(Double Patience, NEERC 2005, UVa1637 )

36张牌分成 9 堆，每堆 4 张牌。每次可以拿走某两堆顶部的牌，但需要点数相同。如果有 多种拿法则等概率的随机拿。例如，9堆顶部的牌分别为 KS, KH, KD, 9H, 8S, 8D, 7C, 7D, 6H，则有 5 种拿法(KS,KH), (KS,KD), (KH,KD), (8S,8D), (7C,7D)，每种拿法的概率均为 1/5。 如果最后拿完所有牌则游戏成功。按顺序给出每堆牌的 4 张牌，求成功概率。

分析】

用 9 元组表示当前状态，即每堆牌剩的张数，状态总数为 59=1953125。设 d[/]表示状 态/对应的成功概率，则根据全概率公式，d[/]为后继状态的成功概率的平均值，按照动态规 划的写法计算即可。

###### 10.3 其他数学专题

10.3.1 递推

汉诺塔问题。假设有 A、B、C 3个轴，有 n 个直径各不相同、从小到大依次编号为 1, 2, 3，...，n的圆盘按照上小下大的顺序叠放在 A 轴上。现要求将这 n 个圆盘移至 B 轴上并仍按同样 顺序叠放，但圆盘移动时必须遵循下列规则：

□每次只能移动一个圆盘，它必须位于某个轴的顶部。

□圆盘可以插在 A、B、C中的任一轴上。

□任何时刻都不能将一个较大的圆盘压在较小的圆盘之上。

【分析】

这个问题看上去很容易，但当 n 稍大一点时，手工移动就开始变得困难起来。下面直接 给出递归解法：首先，把前 n-1个圆盘放到 C 轴；接下来把 n 号圆盘放到 B 轴；最后，再把前 n-1个盘子放到 B 轴，如图 10-5所示。

图 10-5 根据递归解法建立汉诺塔的递推关系

图 10-4中还给出了 n 个圆盘所需步数 Xn)的递推式：f(n)=2/(n-1)+1。如果把 f(n)的值从小 到大列出来，即 1,3,7,15,31,63,127,255...，你会发现其实有一个简单的表达式：f>)=2n-1。

用数学归纳法不难证明：f(1)=1满足等式。假设 n=k满足等式，即 f(k)=2k-1，则 n=k+1

时，fk+1)=2f；k)+1=2(2k-1)+1=2k+1-2+1=2k+1-1。因此 n=k+1 也满足等式。由数学归纳法可 知，n取任意正整数均成立。

如果还不熟悉数学归纳法，其实从上面的证明过程已经能看出来其基本原理——其实它 正是一种递归证明。只要边界处理好(f(1)=1满足)，递归时缩小规模(用 k 来证明 k+1 )， 然后在“相信递归”(假设 n=k成立)的前提下证明即可。

提示 10-6：数学归纳法是一种利用递归的思想证明的方法。如果要讨论的对象具有某 种递归性质(如正整数)，可以考虑用数学归纳法。

Fibonacci数列。先来考虑一个简单的问题：楼梯有 n 个台阶，上楼可以一步上一阶，也 可以一步上两阶。一共有多少种上楼的方法？

这是一道计数问题。在没有思路时，不妨试着找规律。n=5时，一共有 8 种方法：

5=1+1+1+1+1

5=2+1+1+1

5=1+2+1+1

5=1+1+2+1

5=1+1+1+2

5=2+2+1

5=2+1+2

5=1+2+2

其中有 5 种方法第 1 步走了 1 阶(灰色)， 3种方法第 1 步走了 2 阶。没有其他可能了。假 设 An)为 n 个台阶的走法总数，把 n 个台阶的走法分成两类。

第 1 类：第 1 步走 1 阶。剩下还有 n-1阶要走，有?(n-1)种方法。

第 2 类：第 1 步走 2 阶。剩下还有 n-2阶要走，有 Xn-2)种方法。

这样，就得到了递推式：/(n)=/(n-1)+/(n-2)。不要忘记边界情况：f(1)=1，f(2)=2。当 然，也可以认为边界是 f(0)=/(1)=1。把 f(n)的前几项列出：1, 1,2, 3, 5, 8，...。

再例如，把雌雄各一的一对新兔子放入养殖场中。每只雌兔从第 2 个月开始每月产雌雄

各一的一对新兔子。试问第 n 个月后养殖场中共有多少对兔子？

还是先找找规律。

第 1 个月：一对新兔子 h。用小写字母表示新兔子。

第 2 个月：还是一对新兔子，不过已经长大，具备生育能力了，用大写字母表示。

第 3 个月：尺 1 生了一对新兔子 r2，—共两对。

第 4 个月：尺 1 又生一对 r3，—共 3 对。另外，^长大了，变成 R2。

第 5 个月：R^R2各生一对，记为『4和^，共 5 对。此外，r3长成 R3。

第 6 个月：Rp R,R3各生一对，记为 r6~r8，共 8 对，同时 r4 到 r5 长大。

把这些数排列起来：1, 1, 2, 3, 5, 8,...，和刚才的一模一样！事实上，可以直接推导出递 推关系/(n)=/(n-1)+/(n-2):第 n 个月的兔子由两部分组成，一部分是上个月就有的老兔子，一 部分是上个月出生的新兔子。前一部分等于八 n-1)，后一部分等于八 n-2)(第 n-1个月时具有生 育能力的兔子数就等于第 n-2个月的兔子总数)。根据加法原理，/(n)=/(n-1)+/(n-2)。

提示 10-7 :满足 FfF^l，Fn=Fn-1+Fn-2的数列称为 Fibonacci 数列，它的前若干项是 1, 1, 2, 3, 5, 8, 13, 21, 34, 55,…。

再例如，有 2 行 n 列的长方形方格，要求用 n 个 1*2的骨牌铺满。有多少种铺法？

考虑最左边一列的铺法。如果用一个骨牌直接覆盖，则剩下的 2*(n-1)方格有/(n-1)种铺 法；如果是用两个横向骨牌覆盖，则剩下的 2*(n-2)方格有>-2)种方法，如图 10-6所示。不 难发现：第一列没有其他铺法，因此/>)=>-1)+>-2)。边界/(0)=1,/(1)=1，恰好是 Fibonacci 数列。

这就是多数课本上讲解这道题目的方法，无须多说，因为重点并不在此。笔者曾想到过 另一个解法，与各位读者分享：设第 i 列是纵向骨牌，则左边 i-1列和右边 n-i列各有/(/-1)

和/(n-i)种铺法。根据乘法原理，一共有/(i-1)/(n-i)种铺法。然后把 i=1,2,3，...，n的情形全部加 起来，根据加法原理，有：

/(n)=/(0)/(n-1) + /(1)/(n-2)+.+/(n-1)/(0)

这个递推式对不对呢？聪明的读者也许已经看出，这个解法存在两个问题：

(1 )有遗漏。只考虑了第 1,2,3，...，n列是纵向骨牌的情形，但实际上可能所有的骨牌都 是横向的。当且仅当 n 为偶数时，恰好有一种这样的方案。

(2)有重复。根据“第/列有骨牌”对所有方案进行了分类，但其实这些方案是有重叠 的。例如，第 1 列和第 2 列完全可以同时有骨牌。这些方案在递推式中被重复计算了。

既然如此，这个思路是不是走入死胡同了呢？不是的！只要把刚才的推理变得严密起 来，同样可以得到一个正确的递推式：根据从左到右第一条纵向骨牌的列编号分类。如果不 存在，当且仅当 n 为偶数时有一种方案；当第一条纵向骨牌的列编号为/时，意味着左边/-1列 必须全部是横向骨牌——当/为奇数时恰好有一个方案。而右边 n-/列则可以用任意铺法，

共 An々)种。换句话说：

n为偶数时，»=>-1)+>-3)+>-5)…+f(1)+1 (最后加上的就是“没有纵向骨牌”的情 形)。

n为奇数时，f(n)=f(n-1)+/(n-3)+/(n-5)... +f(2)+f(0)。

边界是 f(0)=f(1)=1。我们已经知道，问题的答案应该是 Fibonacci 数列，自然会对这个复 杂的递推式产生怀疑：它真的是正确的吗？

带着这个疑问，笔者写了一个程序。结果出乎意料：居然和 Fibonacci 数列一样！事实 上，它确实是 Fibonacci 数列。Fibonacci数列拥有很多有趣的性质，有兴趣的读者可以在网上 搜索更多相关资料。不管怎样，这个“旧题新解”至少说明了两点：

( 1)一个数列可能有多个看上去完全不同的递推式。

( 2)即使是漏洞百出的解法也有可能通过“打补丁”的方式修改正确。

Catalan数。给一个凸 n 边形，用 n-3条不相交的对角线把它分成 n-2个三角形，求不同的 方法数目。例如，n=5时，有 5 种剖分方法，如图 10-7所示。

分析】

设答案为 fn)。按照某种顺序给凸多边形的各个顶点编号为^，72，…，匕。既然分成的是 三角形，边在最终的剖分中一定恰好属于某个三角形，所以可以根据 k 进行分 类。不难看出，三角形的左边是一个 k 边形，右边是一个 n-k+1边形(如图 10-8 ( a )所 示)。根据乘法原理，包含三角形的方案数为 f(k)/(n-k+1)；根据加法原理有：

f(n)=f(2)f(n-1) + f(3)f(n-2) +…+ f(n-1)f(2)

边界是 f(2)=/(3)=1。不难算出从 f(3)开始的前几项/值依次为：1、2、5、14、42、132、 429、 1430、 4862、 16796。

提示 10-8 ：在建立递推式时，经常会用到乘法原理，其核心是分步计数。如果可以把 计数分成独立的两个步骤，则总数量等于两步计数之乘积。

另一种思路是考虑匕连出的对角线。对角线把凸 n 边形分成两部分，一部分是 k 边 形，另一部分是 n-k+2边形(如图 10-8 ( b )所示)。根据乘法原理，包含对角线的凸多 边形有/(kf(n-k+2)个。根据对称性，考虑从 F2、F3、…、匕出发的对角线也会有同样的结 果，因此一共有 nf(3)/(n-1)+/(4)/(n-2)+...+>-1)/(3))个部分。

A边形

n~k+1边形



![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-208.jpg)



但这并不是正确答案，因为同—个剖分被重复计算了多次！不过这次不必去消除重复 了，因为这些重复很有规律：每个方案恰好被计算了 2n-6次——有 n-3条对角线，而考虑每 条对角线的每个端点时均计算了一次。这样，得到了/(n)的第 2 个递推式：

/(n) = (/(3)(n-1)+/(4)/(n-2)+…+/(n-1)/(3)>n/(2n-6)

它和第一个递推式有几分相似，但又不同。把 n+1代入第 1 个递推式后得到：

/(n+1)=/(2)/(n) + /(3)/(n-1) + /(4)/(n-2) +…+ /(n-1)/(3) + /(n)/(2)

灰色部分是相同的！根据第 2 个递推式，它等于/(n)*(2n-6)/n，把它和/(2)=1—起代入上 式得：

,("+ 1卜/⑻ + /(") • (2" -6) / " + j(n) =    6,⑻

n

这个递推式和前两个相比就简单多了。这个数列称为 Catalan 数，也是常见的计数数列。

例题 10-13 危险的组合(Critical Mass, UVa580 )

有一些装有铀(用 U 表示)和铅(用 L 表示)的盒子，数量均足够多。要求把 n ( n<30) 个盒子放成一行，但至少有 3 个 U 放在一起，有多少种放法？例如，n=4, 5, 30时答案分别为 3, 8和 974791728。

【分析】

设答案为/(n)。既然有 3 个 U 放在一起，可以根据这 3 个 U 的位置分类——对，根据前面的 经验，要根据“最左边的 3 个 U”的位置分类。假定是 i、i+1和 i+2这 3 个盒子，则前 i-1个盒子不 能有 3 个 U 放在一起的情况。设 n 个盒子“没有 3 个 U 放在一起”的方案数为 g(n)=2n-/(n)，则前 i-1

个盒子的方案有 g(i-1)种。后面的 n-i-2个盒子可以随便选择，有 2n-i-2种。根据乘法原理和加

法原理，、.，-乙，乂 。

1=1

遗憾的是，这个推理是有瑕疵的。即使前 i-1个盒子内部不出现 3 个 U，仍然可能和 i、i+1 和 i+2组成 3 个 U。正确的方法是强制让第 i-1个盒子(如果存在)放 L，则前 i-2个盒子内部不

能出现连续的 3 个 U。因此；    「，边界

/-2

是 f(0)=f(1)=f(2)=0。g(0)=1，g(1)=2，g(2)=4。注意上式中的 2n-3对应于/=1 的情况。

例题 10-14 比赛名次(Race, UVa12034 )

A、B两人赛马，最终名次有 3 种可能：并列第一；A第一 B 第二；B第一 A 第二。输 入 n ( 1<n<1000 )，求 n 人赛马时最终名次的可能性的个数除以 10056 的余数。

【分析】

设答案为 f(n)。假设第一名有/个人，有 C(n，/)种可能性，接下来有 f>/)种可能性，因此 答案为 ZC(n，/f(n-/)。

例题 10-15 杆子的排列(Pole Arrangement, ACM/ICPC Daejeon 2012, UVa1638 )

有高为 1, 2, 3,…，n的杆子各一根排成一行。从左边能看到/根，从右边能看到 r 根，求有 多少种可能。例如，图 10-9中的两种情况都满足 Z=1，r=2 ( 1</，r<n<20 )。

图 10-9 杆子的排列

【分析】

设亦，M)表示让高度为卜/根杆子排成一行，从左边能看到/根，从右边能看到&根的方 案数。为了方便起见，假定&2。如何进行递推呢？首先尝试按照从小到大的顺序按照各个 杆子。假设已经安排完高度为 1〜/-1的杆子，那么高度为/的杆子可能会挡住很多其他杆子， 看上去很难写出递推式。

那么换一个思路：按照从大到小的顺序安排各个杆子。假设已经安排完高度为 2〜/的杆 子，那么高度为 1 的杆子不管放哪里都不会挡住任何一根杆子。有如下 3 种情况。

情况 1 ：插到最左边，则从左边能看到它，从右边看不见（因为^2 ）。

情况 2：如果插到最右边，则从右边能看到它，从左边看不见。

情况 3 （有/-2个插入位置）：插到中间，则不管从左边还是右边都看不见它。

在第一种情况下，高度为 2〜/的那些杆子必须满足：从左边能看到/-1根，从右边能看 到 k 根，因为只有这样，加上高度为 1 的杆子之后才是“从左边能看到/根，从右边能看 到 k 根”。虽然状态成/J，k）表示的是“让高度为卜/的杆子……”，而现在需要把高度为 2〜/+1 的杆子排成一行，但是不难发现：其实杆子的具体高度不会影响到结果，只要有/根高度各 不相同的杆子，从左从右看分别能看到/根和 k 根，方案数就是硪/，/，k）。换句话说，情况 1 对应 的方案数是硪/-1J-1，k）。类似地，情况 2 对应的方案数是硪/-1J，k-1），而情况 3 对应的方案数 是成/-1J，k）*（/-2）。这样，就得到了如下递推式：

d（i，j，k） = d（i-1，j-1，k） + d（i-1，j，k-1） + d（i-1，j，k）*（i-2）

10.3.2 数学期望

数学期望。简单地说，随机变量 X 的数学期望£¥就是所有可能值按照概率加权的和。例 如，一个随机变量有 1/2的概率等于 1， 1/3的概率等于 2， 1/6的概率等于 3，则这个随机变量 的数学期望为 1*1/2+2*1/3+3*1/6=5/3。在非正式场合中，可以说这个随机变量“在平均情况 下”等于 5/3。在解决和数学期望相关的题目时，可以先考虑直接使用数学期望的定义求解： 计算出所有可能取值，以及对应的概率，最后求加权和，如果遇到困难，则可以考虑使用下 面两个工具：

期望的线性性质。有限个随机变量之和的数学期望等于每个随机变量的数学期望之 和。例如，对于两个随机变量 x 和 y，所 x+r）=£A+ey。

全期望公式。类似全概率公式，把所有情况不重复、不遗漏地分成若干类，每类计算

数学期望，然后把这些数学期望按照每类的概率加权求和。

例题 10-16 过河(Crossing Rivers, ACM/ICPC Wuhan 2009, UVa12230 )

你住在村庄 A，每天需要过很多条河到另一个村庄 B 上班。B在 A 的右边，所有的河都在 中间。幸运的是，每条河上都有匀速移动的自动船，因此每当到达一条河的左岸时，只需等 船过来，载着你过河，然后在右岸下船。你很瘦，因此上船之后船速不变。

日复一日，年复一年，你问自己：从 A 到 B，平均情况下需要多长时间？假设在出门时

所有船的位置都是均匀随机分布。如果位置不是在河的端点处，则朝向也是均匀随机。在陆

地上行走的速度为 1。

输入 A 和 B 之间河的个数 n、长度 D ( 0<n<10，1<D<1000 )，以及每条河的左端点坐标离 A的距离^，长度 Z 和移动速度 v ( 0<p<D，0<L<D，1<v<100 )，输出 A 到 B 时间的数学期望。 输入保证每条河都在 A 和 B 之间，并且相互不会重叠。

【分析】

用数学期望的线性。过每条河的时间为 L/v到 3L/v的均勻分布，因此期望过河时间为 2L/v。把所有 2L/v加起来，再加上 D-sum(L)即可。

例题 10-17 糖果(Candy, ACM/ICPC Chengdu 2012, UVa1639 )

有两个盒子各有打(n<2*105 )个糖，每天随机选一个(概率分别为 p，1-p )，然后吃一 颗糖。直到有一天，打开盒子一看，没糖了！输入 n, p，求此时另一个盒子里糖的个数的数 学期望。

【分析】

根据期望的定义，不妨设最后打开第 1 个盒子，此时第 2 个盒子有/颗，则这之前打开 过 n+(n-/)次盒子，其中有 n 次取的是盒子 1，其余 n-/次取的盒子 2，概率为 C(2n-/，    n)pn+1

(1-p)n-/。注意 p 的指数是 n+1，因为除了前面打开过 n 次盒子 1 之外，最后又打开了一次。

这个概率表达式在数学上是正确的，但是用计算机计算时需要小心：n可能高达 20 万，

因此 C(2n-/，n)可能非常大，而，*1和(1-p)n-/却非常接近 0。如果分别计算这 3 项再乘起来，会 损失很多精度。一种处理方式是利用对数，设 v1(/) = ln(C(2n-/，n)) + (n+1)ln(p) + (n-/)ln(1-p)，则“最后打开第 1 个盒子”对应的数学期望为 ev1(/)。

同理，当最后打开的是第 2 个盒子，对数为 v2(/) = ln(C(2n-/， n)) + (n+1)ln(1-p) + (n-i)ln(p)，概率为 ev2(/)。根据数学期望的定义，最终答案为 sum{/(ev1(/)+ev2(/))}。

例题 10-18 优惠券(Coupons, UVa10288 )

大街上到处在卖彩票，一元钱一张。购买撕开它上面的锡箔，你会看到一个漂亮的图 案。图案有 n 种，如果你收集到所有 n ( n<33 )种彩票，就可以得大奖。请问，在平均情况 下，需要买多少张彩票才能得到大奖呢？如 n=5时答案为 137/12。

【分析】

已有 k 个图案，令 5=^，拿一个新的需要 Z 次的概率：st-1(1-s)；因此平均需要的次数为(1-s) (1 + 2s + 3s2 + 4s3 + …)=(1-s)^，而 s^ = s + 2s2 + 3s3 + ... = ^-(1+s+s2+…)，移项得

(1-s)£=1+s+s2+...=1/(1-s) = n/(n-k)

换句话说，已有 k 个图案：平均拿 n/(n-k)次就可多搜集一个，所以总次数为：

n(1/n+1/(n-1)+1/(n-2)+. +1/2+1/1)

10.3.3 连续概率

连续概率。简单地说，随机变量 X 的数学期望£¥就是所有可能值按照概率加权的和。例 如，一个随机变量有 1/2的概率等于 1， 1/3的概率等于 2， 1/6的概率等于 3，则比变量随机。

例题 10-19 概率(Probability, UVa11346 )

在[-¥]*[-¥]区域内随机取一个点 P，求以(0，0)和 P 为对角线的长方形面积大于 S 的概率 (a，b>0，5>0 )。例如 a=10，b=5，S=20，答案为 23.35%。

【分析】

根据对称性，只需要考虑[0，a]*[0，b]区域取点即可。面积大于 S，即吵>S。吵=5是一条双 曲线，所求概率就是[0，a]*[0，b]中处于双曲线上面的部分。为了方便，还是求曲线下面的面 积，然后用总面积来减，如图 10-10所示。

图 10-10 双曲线所围面积

设双曲线和区域［0，列*［0力］左边的交点 P 是(5/h幻，因此积分就是：

查得 1AS 的原函数是 ln⑶，因此积分部分就是 ln⑷-ln(5^)= ln⑽/5)。设面积为 m，则答案

为 (m - s - s *ln(m/s)) / m。

注意这样做有个前提，就是双曲线和所求区域相交。如果 5〉冰，则概率应为 0 ；而如 果太接近 0，概率应直接返回 1，否则计算 ln(m/5)时可能会出错。

例题 10-20 你想当 2n 元富翁吗？( So you want to be a 2n-aire?, UVa10900 )

在一个电视娱乐节目中，你一开始有 1 元钱。主持人会问你 n 个问题，每次你听到问题后 有两个选择：—是放弃回答该问题，退出游戏，拿走奖金；二是回答问题。如果回答正确， 奖金加倍；如果回答错误，游戏结束，你一分钱也拿不到。如果正确地回答完所有 n 个问 题，你将拿走所有的 2n 元钱，成为 2"元富翁。

当然，回答问题是有风险的。每次听到问题后，你可以立刻估计出答对的概率。由于主 持人会随机问问题，你可以认为每个问题的答对概率在 Z 和 1 之间均勻分布。输入整数 n 和实 数 t（ 1<n<30，0<t<1 ），你的任务是求出在最优策略下，拿走的奖金金额的期望值。这里的 最优策略是指让奖金的期望值尽量大。

【分析】

假设你刚开始游戏，如果直接放弃，奖金为 1；如果回答，期望奖金是多少呢？不仅和 第 1 题的答对概率相关，而且和答后面的题的情况相关。即：

选择“回答第 1 题”后的期望奖金 = p * 答对 1 题后的最大期望奖金

注意，上式中“答对 1 题后的最大期望奖金”和这次的无关，这提示我们用递推的思想， 用叫 i]表示“答对 i 题后的最大期望奖金”，再加上“不回答”时的情况，可以得到：若第 1 题答对 概率为^，期望奖金的最大值=max{20, p*d[1]}

这里故意写成 20，强调这是“答对 0 题后放弃”所得到的最终奖金。

上述分析可以推广到一般情况，但是要注意一点：到目前为止，一直假定 p 是已知的，

而 p 实际上并不固定，而是在 t〜1内均勻分布。根据连续概率的定义，d[i]在概念上等于

max{2z^ p*d[i+1]}在 p=t~ 1上的积分。不要害怕“积分”二字，因为虽然在概念上这是一个积 分，但是落实到具体的解法上，仍然只需要基础知识。

因为有 max 函数的存在，需要分两种情况讨论，即 p*d[i+1]<2^p*d[i+1]^2俩种情况。

令 p0=max{t, 2Vd[i+1]}（加了一个 max 是因为根据题目，p^t），则：

□ p<p0时，p*d[i+1]<2z，因此“不回答”比较好，期望奖金等于 2Z。

p改 0 时，“回答”比较好，期望奖金等于 d[i]乘以 p 的平均值（d[i]作为常数被“提出

来” 了)，即(1+^0)/2 * 叫 z+1]。

在第一种情况中，，p的实际范围是似 0)，因此概率为 W=b0-t)/(1-t)。根据全期望公 式， d[i] = 2i * p1 + (1+p0)/2 * d[i+1] * (1-p1)。

边界是破 n] =2n，逆向递推出破 0]就是本题的答案。

例题 10-21 多边形(Polygon, UVa11971 )

有一根长度为 n 的木条，随机选 k 个位置把它们切成 k+1段小木条。求这些小木条能组成 一个多边形的概率。

【分析】

不难发现本题的答案与 n 无关。在一条直线上切似乎难以处理，可以把直线接成一个 圆，多切一下，即在圆上随机选 k+1个点，把圆周切成 k+1段。根据对称性，两个问题的答案 相同。

新问题就要容易处理得多了： “组不成多边形”的概率就是其中一个小木条至少跨越了半 个圆周的概率。设这个最长的小木条从点/开始逆时针跨越了至少半个圆周，则其他所有点 都在这半个圆周之外，如图 10-11所示的灰色部分。

图 10-11 木条逆时针跨越所成形状

除了点 i 之外其他每个点位于灰色部分的概率均为 1/2，因此总概率为 1/2\点 i 的取法 有奸 1 种，因此“组不成多边形”的概率为（奸 1）/2\能组成多边形的概率为 1-（奸 1）/2\

###### 10.4 竞赛题目选讲

例题 10-22 统计问题(The Counting Problem, ACM/ICPC Shanghai 2004, UVa1640 )

给出整数“、办，统计“和办(包含“和办)之间的整数中，数字 0，1,2,3,4,5,6,7,8,9分别出现 了多少次。1<^，^<108。注意，有可能大于办。

【分析】

解决这类题目的第一步一般都是：令/x«)表示 01-1中数字出现的次数，则所求的就 是 fd(b+1)-fd(a)。例如，要统计 0〜234中 4 的个数，可以分成几个区间，如表 10-2所示。

表 10-2 0~ 234所划区间

| 范围      | 模板集                      |
| --------- | --------------------------- |
| 0〜9      | *                           |
| 10 〜99   | **                          |
| 100〜199  | 1**                         |
| 200 〜229 | 20*， 21*， 22*             |
| 230〜234  | 230， 231， 232， 233， 234 |

表 10-2中的“模板”指的是一些整数的集合，其中字符“*”表示“任意字符”。例如， 1**表 示以 1 开头的任意 3 位数。因为后两个数字完全任意，所以“个位和十位”中每个数字出现的次 数是均等的。换句话说，在模板 1**所对应的 100 个整数的 200 个“个位和十位”数字中，0〜9 各有 20 个。而这些数的百位总是 1，因此得到：模板 1**对应的 100 个整数包含数字 0，2〜9各 20个，数字 1 有 120 个。

这样，只需把 0~«分成若干个区间，算出每个区间中各个模板所对应的整数包含每个数 字各多少次，就能解决原问题了，细节留给读者思考。

例题 10-23 多少块土地( How Many Pieces of Land?, UVa10213)

有一块椭圆形的地。在边界上选《 ( 0<n<231 )个点并两两连接得到 n(n-1)/2条线段。它们 最多能把地分成多少个部分？如图 10-12所示，n=6时最多能分成 31 份。

图 10-12 n=6时所划分的土地

【分析】

本题需要用到欧拉公式：在平面图中，V-E+F=2，其中 V 是顶点数，E是边数，F是面 数。因此，只需要计算 V 和 E 即可(注意还要减去外面的“无限面”)。

不管是顶点还是边，计算时都要枚举一条从固定点出发(所以最后要乘以 n )的对角 线，它的左边有/个点，右边有 n-2-/个点。左右点的连线在这条对角线上形成 i(n-2-/)个交 点，得到/(n-2-/)+1条线段。每个交点被重复计算了 4 次，每条线段被重复计算了 2 次。

本题还有一个有趣之处：n=1〜n=6时答案分别为 1、2、4、8、16、31。如果根据前 5 项“找规律”得到“公式”2n-1，即就错了。

例题 10-24 ASCII面积(ASCII Area, NEERC 2011, UVa1641 )

在一个铲 w ( 2<力，w<100 )的字符矩阵里用“”、“\”和“/”画出一个多边形，计算面积。 如图 10-13所示，面积为 8。

图 10-13 ASCII 面积

【分析】

这是一道和几何相关的题目，不过不需要高深的几何知识。每个格子要么全白，要么全

黑，要么半白半黑，只要能准确地判断出来即可。字符“\”和“/”都是半白半黑，问题在

于“.”到底是全白还是全黑。

解决方法是从上到下从左到右处理，沿途统计“/”和“\”。当这两个字符出现偶数次时说

明接下来的格子在多边形外；奇数次则说明接下来的格子在多边形内。

例题 10-25 约瑟夫的数论问题( Joseph's Problem, NEERC 2005, UVa1363)

输入正整数 n 和女(1<n，k<109 )，计算 k mod

?=i

【分析】

被除数固定，除数逐次加 1，直观上余数也应该有规律。假设 k/i的整数部分等于 p，则 k mod i = k-i*p。因为 k/(i+1)和 k/i差别不大，如果 k/(i+1)的整数部分也等于 p，则 k mod (i+1) = k-(i+1)*p = k-i*p -p = k mod i -p。换句话说，如果对于某一个区间 i, i+1, i+2,…,j，k除以它们 的商的整数部分都相同，则 k 除以它们的余数会是一个等差数列。

这样，可以在枚举 i 时把它所在的等差数列之和累加到答案中。这需要计算满足[k/j]=

[w]=/»的最大/。

□当^=0时这样的 J 不存在，所以等差序列一直延续到序列的最后。

□当/»〉0时/为满足的•改的最大/，即 j<k/p。除了首项之外的项数 j-/<(k-/*p)/p =抑。

例题 10-26 帮帮 Tomisu ( Help Mr. Tomisu, UVa11440 )

给定正整数#和似，统计 2 和 M 之间有多少个整数满足：的所有素因子都大

于 M( 2<N<107，1<M<N，N-M<105 )。输出答案除以 100000007的余数。例

如，N=100，M=10时答案为 43274465。

【分析】

因为 M<N，所以 N!是 M!的整数倍。“所有素因子都大于 M”等价于和 M!互素。另外，根据 最大公约数的性质，对于 k〉M!，k与 M!互素当且仅当 k    mod M!与 M!互素。这样，只需要求

出“不超过 M!且与 M!互素的正整数个数”，再乘以 N!/M!即可。这样，问题的关键就是求出 phi(M!)。因为有多组数据，考虑用递推的方法求出所有的 phifac(n)=phi(n!)。由 phi 函数的公 式：

###### 炉⑷=/7(1-丄)(1_丄)…(I -丄)

Pl Pl    Pk

如果 n 不是素数，那么 n!和(n-1)!的素因子集合完全相同，因此 phifac(n)=phifac(n-1)*n ; 如果 n 是素数，那么还会多一项(1-1/n)，即(n-1)/n，约分得 phifac(n)=phifac(n-1)*(n-1)。

核心代码如下(请读者注意其中的细节，如 rn=1的情况)：

int main() { int n, m;

sieve(10000000); //筛法求素数

phifac [1] = phifac [2] = 1; //请读者思考，为什么 phifac[1]等于 1 而不是 0 for (int i = 3; i <= 10000000; i + +)    //递推 phifac[i]=phi(i!)%MOD

phifac [i] = (long long) phifac [i-1]    * (vis [i]    ? i : i-1)    % MOD; //vis[i]为真^> i 不

int ans = phifac[m];

for(int i = m+1; i <= n; i++) ans = (long long)ans * i % MOD; printf("%d\n", (ans-1+MOD)%MOD); //注意这里要减 1，因为题目从 2 开始统计

}

return 0;

}

例题 10-27 树林里的树(Trees in a Wood, UVa10214 )

在满足（^<2000，b<2000000 ）的网格中，除了原点之外的整点（即坐标 均为整数的点）各种着一棵树。树的半径可以忽略不计，但是可以相互遮挡。求从原点能看 到多少棵树。设这个值为尺，要求输出尺从，其中#为网格中树的总数。如图 10-14所示，只 有黑色的树可见。

【分析】

显然 4 个坐标轴上各只能看见一棵树，所以可以只数第一象限（即 x〉0，y〉0 ），答案乘 以 4 后加 4。第一象限的所有人 y 都是正整数，能看到（x，y），当且仅当 gcd（x，y）=1。

由于范围比较小，b范围比较大，一列一列统计比较快。第列能看到的树的个数等于 0<y<b的数中满足 gcd（^，y）=1的 y 的个数。可以分区间计算。

□    1<y<x :有 phi（v）个，这是欧拉函数的定义。

□    .x+1<y<2.x :也有 phi（x）个，因为 gcdCx+/，_x）=gcdCx，/）。

□    2_x+1<y<3_x ：也有 phi（x）个，因为 gcd（2_x+/，x）=gcdCx，/）。

□ kx+1<y<b :直接统计，需要□&）时间。

换句话说，每次需要计算 phi⑻和进行 0⑻次直接判断，计算 phi⑻需要 0（'2）时间，而 直接判断只需要 0（1）时间。再加上枚举的所有种可能，总时间为 C^2）。

例题 10-28 (问题抽象)高速公路( Highway, ACM/ICPC CERC 2006, UVa1393)

有一个 n 行讲列（1<n，rn<300 ）的点阵，问：一共有多少条非水平非竖直的直线至少穿过 其中两个点？如图 10-15所示，n=2，rn=4时答案为 12，n=rn=3时答案为 14。

图 10-14 树林里的树



图 10-15n行 m 列点阵



【分析】

不难发现两个方向是对称的，所以只统计“\”型的，然后乘以 2。方法是枚举直线的包围 盒大小^*&，然后计算出包围盒可以放的位置。首先，当 gcd(^力)〉1时肯定重复了，如图 10-16(a)所示，大包围盒^*办满足 gcd(^)〉1，在它的对角线和的对角线是同一条直线

(其中 a'=a/gcd(a,b)， b'=b/gcd(a,b))。

其次，如果放置位置不够靠左，也不够靠上，则它和它“左上方”的包围盒也重复了，如 图 10-16 ( b )所示。

(a)    (b)

图 10-16 gcd(a,b)>1 时示意图



假定左上角坐标为(0,0)，则对于左上角在(^y)的包围盒，其“左上方”的包围盒的左上角 为(i^y-办)。这个“左上角”合法的条件是论 0 且 y-^0。

包围盒本身不出界的条件是^+^<m-1 ,y+^<n-1，一共有(m-^)(n-6)个，而“左上方”有包围 盒的情况，即“<^<讲皆 1 且办<>^-办-1，有 c = max(0, m-2a) * max(0, n-2幻种放法。相减得 到：^*办的包围盒有(rn-^)(n-办)-c种放法。

另外要注意应预处理保存所有 gcd，而不是边枚举边算，否则会超时。

例题 10-29 魔法 GCD （ Magical GCD, ACM/ICPC CERC 2013, UVa1642 ）

输入一个 n ( n<100000 )个元素的正整数序列    …    ，，求一个连续子序

列，使得该序列中所有元素的最大公约数与序列长度的乘积最大。例如，5个元素的序列 30，

60，20，20，20的最优解为｛60，20，20，20｝，乘积为 gcd(60，20，20，20)*4=80。

【分析】

本题看上去和第 8 章介绍的一些“传统算法题”很像，所以可试着沿用这样一个常见的框 架：从左到右枚举序列的右边界/，然后快速求出左边界/<•，使得 MGCD(/J)最大，其中

定义为_ h1    。

如何快速求出 i 呢？好像那些“传统方法”(单调队列等)都用不上，因为 gcd 函数并没有 很多“好用”的代数性质。怎么办？还是从数论的角度入手吧。考虑序列 5, 8, 6, 2, 6, 8，当 j=5 时需要比较 i=1, 2, 3, 4, 5时的 MGCD(ij)，如表 10-3所示。

表 10-3 j=5时比较的 MGCD(i,j)

| i    | gcd表达式          | gcd值 | 序列长度 |
| ---- | ------------------ | ----- | -------- |
| 1    | gcd(5，8，6，2，6) | 1     | 5        |
| 2    | gcd（8，6，2，6）  | 2     | 4        |
| 3    | gcd（6，2，6）     | 2     | 3        |
| 4    | gcd（2，6）        | 2     | 2        |
| 5    | gcd（6）           | 6     | 1        |

从下往上看，gcd表达式里每次多一个元素，有时 gcd 不变，有时会变小，而且每次变小 时一定是变成了它的某个约数(想一想，为什么)。换句话说，不同的 gcd 值最多只有 log2/种！当 gcd 值相同时，序列长度越大越好，所以可以把表 10-3简化成表 10-4中的形式。

表 10-4 简化表 10-3

| gcd值 | 1    | 2    | 6    |
| ----- | ---- | ---- | ---- |
|       |      |      |      |

因为表里只有 log2/个元素，所以可以依次比较每一个 i 对应的 MGCD(ij)，时间复杂度为

O(logj-)。下面考虑/从 5 变成 6 时，这个表会发生怎样的变化。首先，上述所有 gcd 值都要再 和“6=8取 gcd，即表 10-4中第一行的 1, 2, 6分别变成 gcd(1,8)=1，gcd(2,8)=2，gcd(6,8)=2。然后

要加入 i=6的序列，gcd值为 8。由于相同的 gcd 值只需要保留 i 的最小值，所以 i=5被删除，最 终得到如表 10-5所示结果。

表 10-5 i=5被删除后的结果

| gcd值 | 1    | 2    | 6    |
| ----- | ---- | ---- | ---- |
| i     | 1    | 2    | 8    |

上述过程需要删除 gcd 相同的重复元素，但因为元素个数只有 O(logj)个，即使用二重循 环比较，时间效率也是很高的，每次修改表 10-5的时间复杂度为 O((log/)2)，总时间复杂度 为 O(n(logn)2)。但因为很难构造出每次表里都有接近 log2/个元素的数据，实际运行时间和时 间复杂度为 O(nlogn)的算法相当。



###### 10.5 训练参考

数学题目的特点是：思维难度往往远大于编程难度。尽管如此，也有一些程序实现细节

不容忽视，例如，整数溢出和精度误差。本章的例题很多，不过多数题目的难度不大，重点

在于帮助读者巩固相关的知识点。建议读者先学会所有不加星号的例题，然后逐步弄懂有星

号的例题。本章例题列表如表 10-6所示。

表 10-6 例题列表

| 类别       | 题号     | 题目名称（英文）           | 备注         |
| ---------- | -------- | -------------------------- | ------------ |
| 例题 10-1   | UVa11582 | Colossal FibonacciNumbers! | 模算术       |
| 例题 10-2   | UVa12169 | Disgruntled Judge          | 模算术       |
| 例题 10-3   | UVa10375 | Choose and Divide          | 唯一分解定理 |
| 例题 10-4   | UVa10791 | Minimum Sum LCM            | 唯一分解定理 |
| 例题 10-5   | UVa12716 | GCD XOR                    | 数论         |
| 例题 10-6   | UVa1635  | Irrelevant Elements        | 组合数       |
| 例题 10-7   | UVa10820 | Send a Table               | 欧拉 phi 函数  |
| 例题 10-8   | UVa1262  | Password                   | 编码解码问题 |
| 例题 10-9   | UVa1636  | Headshot                   | 离散概率     |
| 例题 10-10  | UVa10491 | Cows and Cars              | 离散概率     |
| 例题 10-11  | UVa11181 | Probability\|Given         | 离散条件概率 |
| 例题 10-12  | UVa1637  | Double Patience            | 离散概率     |
| 例题 10-13  | UVa580   | Critical Mass              | 递推         |
| 例题 10-14  | UVa12034 | Race                       | 递推         |
| *例题 10-15 | UVa1638  | Pole Arrangement           | 递推         |
|            |          |                            |              |

| 例题 10-16  | UVa12230 | Crossing Rivers              | 数学期望           |
| ---------- | -------- | ---------------------------- | ------------------ |
| 例题 10-17  | UVa1639  | Candy                        | 数学期望           |
| 例题 10-18  | UVa10288 | Coupons                      | 数学期望           |
| *例题 10-19 | UVa11346 | Probability                  | 连续概率           |
| *例题 10-20 | UVa10900 | So you want to be a 2n-aire? | 连续概率，数学期望 |
| *例题 10-21 | UVa11971 | Polygon                      | 连续概率           |
| 例题 10-22  | UVa1640  | The Counting Problem         | 数位统计           |
| 例题 10-23  | UVa10213 | How Many Pieces of Land?     | 欧拉公式、计数     |
| 例题 10-24  | UVa1641  | ASCII Area                   | 多边形面积         |
| 例题 10-25  | UVa1363  | Joseph's Problem             | 数论，数列求和     |
| *例题 10-26 | UVa11440 | Help Mr. Tomisu              | 欧拉 phi 函数        |
| 例题 10-27  | UVa10214 | Trees in a Wood              | 欧拉 phi 函数        |
| 例题 10-28  | UVa1393  | Highway                      | 分类统计           |
| 例题 10-29  | UVa1642  | Magical GCD                  | 综合题             |

本章的习题是本书中数量最多的，不过多数习题的难度不大，主要目的是巩固知识。因

为大多数题目的描述比较简单，建议读者阅读所有题目，并选择感兴趣的题目思考。

习题 10-1 砌砖( Add Bricks in the Wall, UVa11040) 45块石头按照如图 10-17所示的方式排列，每块石头上有一个整数。

255

10

o

!

3

5

2

rz

j:

I

1

1

1

图 10-17 45块石头排列方式

除了最后一行外，每个石头上的整数等于支撑它的两个石头上的整数之和。目前只有奇

数行的左数奇数个位置上的数已知，你的任务是求出其余所有整数。输入保证有唯一解。

习题 10-2 勤劳的蜜蜂( Bee Breeding, ACM/ICPC World Finals 1999, UVa808)

如图 10-18所示，输入两个格子的编号 a 和^ （久衫 10000 ），求最短距离。例如，19和 30 的距离为 5（一条最短路是 19-7-6-5-15-30）。

习题 10-3 角度和正方形( Angles and Squares, ACM/ICPC Beijing 2005, UVa1643)

如图 10-19所示，第一象限里有一个角，把 n （ n<10）个给定边长的正方形摆在这个角里 （角度任意），使得阴影部分面积尽量大。

」—\」一—\」一\ 厂'    /54\    /

/55 \    /    \

/    \_/5D\_/3D\_/32\_/5^\    /

\_/47\    /    /5&\

/.t\ /a5\    e\    /

'■■■    .<4\    / T-..    .-=G\ m.

/~\    /44\    /妇\    /7T\    _/

\_/70\^/43 \_^/2a \    /3?\    /62\

/    \    /42\    /4D\    /S3\    /

\」一\」研」ZT\」讯」一\ /    \」\_/S7\ 咕\」\_J

\」\」\    /6S\__/    \」\

图 10-18 勤劳的蜜蜂问题示意图



图 10-19 角度和正方形问题示意图



习题 10-4 素数间隔( Prime Gap, ACM/ICPC Japan 2007, UVa1644)

输入一个整数 n，求它后一个素数和前一个素数的差值。输入是素数时输出 0。n不超过 1299709 (第 100000个素数)。例如，n=27时输出 29-23=6。

习题 10-5 不同素数之和( Sum of Different Primes, ACM/ICPC Yokohama 2006, UVa1213)

选择尺个质数，使它们的和等于#。给出 A 和尺(K1120，K<14 )，问有多少种满足条件 的方案？例如，n=24，A=2时有 3 种方案:5+19=7+17=11+13=24。注意，1不是素数，因 此 n=A=1时答案为 0。

习题 10-6 连续素数之和( Sum of Consecutive Prime Numbe rs , ACM/ICPC Japan 2005, UVa1210)

输入整数打(2<n<10000 )，有多少种方案可以把 n 写成若干个连续素数之和？例如，41 可由 3 种方案： 2+3+5+7+11+13， 11+13+17和 41 写成。

习题 10-7 几乎是素数( Almost Prime Numbe rs , UVa10539)

输入两个正整数£、U(L<U<1012)，统计区间［L，U］的整数中有多少个数满足：它本身 不是素数，但只有一个素因子。例如，4、27都满足条件。

习题 10-8 完全 P 次方数(Perfect Pth Powers, UVa10622 )

对于整数 x ，如果存在整数使得 x=^ ，则说 x 是一个完全次方数。输入整数《 ，求出最 大的整数^ ，使得《是完全次方数。《的绝对值不小于 2 ，且《在 32 位带符号整数范围内。例

如， n=17， p=1；n=1073741824， p=30；n=25， p=2。

习题 10-9 约数( Divisors, UVa294)

输入两个整数 I、1<L<U<109 , U-L<10000 )，统计区间［L,U］的整数中哪一个的正约 数最多。如果有多个，输出最小值。

习题 10-10 统计有根树( Count, Chengdu 2012, UVa1645)

输入《 ( ^<1000 )，统计有多少个《结点的有根树，使得每个深度中所有结点的子结点数 相同。例如，《=4时有 3 棵，如图 10-20所示；《=7时有 10 棵。输出数目除以 109+7的余数。

图 10-20 n=4时的有根树

习题 10-11 圈图的匹配( Edge Case, ACM/ICPC NWERC 2012, UVa1646)

n ( 3<n<10000 )个结点组成一个圈，求匹配(即没有公共点的边集)的个数。例 如，n=4时有 7 个，如图 10-21 所示，n=100时有 792070839848372253127 个。

(a)    (b) M2 (c) M3    (d) A/4    (e) A/5    (f) M6 (g) M-,

图 10-21 n=4时匹配的个数

习题 10-12 汉堡( Burger, UVa557)

有 n 个牛肉堡和 n 个鸡肉堡给 2n 个孩子吃。每个孩子在吃之前都要抛硬币，正面吃牛肉 煲，反面吃鸡肉煲。如果剩下的所有汉堡都一样，则不用抛硬币。求最后两个孩子吃到相同 汉堡的概率。

习题 10-13 H(n)( H(n), UVa11526)

输入 n (在 32 位带符号整数范围内)，计算下面 c++函数的返回值：

long long H(int n){ long long res = 0;

for( int i = 1; i <= n; i=i+1 ){ res = (res + n/i);

}

return res;

}

例如，n=5、10时答案分别为 10 和 27。

习题 10-14 标准 差( Standard Deviation, UVa10886)

下面是一个随机数发生器。输入 seed 的初始值，你的任务是求出它得到的前 n 个随机数 标准差，保留小数点后 5 位( 1<n<10000000， 0<seed<264)。

unsigned long long seed;

long double gen()

{

static const long double Z = ( long double )1.0 / (1LL<<32); seed >>= 16;

seed *= seed; return seed * Z;

}

习题 10-15 零和一( Zeros and Ones, ACM/ICPC Dhaka 2004, UVa12063)

给出 n、女(n<64 , K100 )，有多少个打位(无前导 0 )二进制数的 1 和 0—样多，且值 为女的倍数？

习题 10-16 计算机变换( Comput e r Transformations, ACM/ICPC SEERC 2005, UVa1647)

初始串为—个 1，每—步会将每个 0 改成 10，每个 1 改成 01，因此 1 会依次变成 01, 1001, 01101001,..。输入 n(n<1000 )，统计 n 步之后得到的串中，“00”这样的连续两个 0 出现了多少 次。

习题 10-17 H-半素数(Semi-prime H-numbers, UVa11105 )

所有形如 4n+1 ( n为非负整数)的数叫 H 数。定义 1 是唯一的单位 H 数，H素数是指本身不 是 1 ，且不能写成两个不是 1 的 H 数的乘积。H-半素数是指能写成两个 H 素数的乘积的 H 数(这 两个数可以相同也可以不同)。例如，25是 H-半素数，但 125 不是。

输入一个 H 数力(^<1000001 )，输出 1〜力之间有多少个 H-半素数。

习题 10-18 —个研究课题( A Research Problem, UVa10837)

输入正整数 rn ( m<108 )，求最小的正整数 n ，使得 q(n)=rn。输入保证 n 小于 200000000。

习题 10-19 蹦极( Bungee Jumping, UVa10868)

James Bond为了摆脱敌人的追击，逃到了一座桥前。桥上正好有一条蹦极绳，于是他打 算把它拴到腿上，纵身跳下桥，落地后切断绳子，继续逃生。已知绳子的正常长度 为 l , Bond的体重为 w ，桥的高度为 5 ，你的任务是替 James Bond判断能否用这种方法逃生。

当从桥上跳下后，绳子綳紧前 Bond 将做自由落体运动(重力按 9.81w计)，而綳紧后绳 子会有向上的拉力，大小为 PA1 ，其中 Al 为绳子当前长度和正常长度之差。当且仅当 Bond 可

以到达地面，且落地速度不超过 10 米/秒时，才认为他安全着落。

输入每组数据包含 4 个非负整数屯 l, s, w（ s<200 ）。对于每组数据，如果可以安全着 地，输出“James Bond survices.”，如果到不了地面，输出“Stuck in the air.”，如果到达地面速 度太快，输出“Killed by the impact.”

习题 10-20 商业中心( Business Center, NEERC 2009, UVa1648)

商业中心是一幢无限高的大楼。在一楼有 m 座电梯，每座电梯只有两个键：上、下。对 于第/座电梯，每按一次“上”会往上走层楼，每按一次“下”会往下走或层楼。你的任务是从

一楼开始选一个电梯，恰好按 n 次按钮，到达一个尽量低（一楼除外）的楼层。中途不能换 乘电梯。1^n^1000000，1<m<2000，1<w/?^z<1000。

习题 10-21 二项式系数( Binomial coefficients, ACM/ICPC NWERC 2011, UVa1649)

输入 m （ 2<m<1015 ），求所有的（n，^）使得 C（n，女）=m。输出按照 n 升序排列，当 n 相同时女按 升序排列。

习题 10-22 飞机环球( Planes Around the World, UVa10640)

有一种飞机，加满油能环游地球圈。如果要使得一架飞机能够环游地球一圈，那么 必须要使用其他若干架同种飞机，在某处为它空中加油。

假设“=1，6 = 2，5架飞机可以环游。

首先 3 架飞机一起从 A 走到 C，飞机 3 给另外两架加满油，然后开始返程。当飞机 1 和 2 到 达 D 的同时飞机 3 回到 A。然后飞机 2 给飞机 1 加满油，回到 A 点。

接下来，飞机 4 和 5 逆时针出发，其中飞机 4 在 F 处等待，飞机 5 在 E 处等待，直到飞机 1 到 达 E。然后飞机 5 给飞机 1 加油，使得二者都能恰好飞到 F。然后飞机 4 给飞机 1 和飞机 5 加油， 三者都恰好飞回 A，如图 10-22所示。

图 10-22 飞机环球问题示意图

假设：

□只有飞机 1 环游地球。

□有 A 架飞机和飞机 1 同时出发，同向飞行，称为正向飞机。每艘正向飞机都在某个位置 处为其他飞机加油，然后折返。

□有 B 架飞机于不同时间反向出发，称为反向飞机。每架反向飞机会停在一个地方等待飞 机 1（及其他同行飞机）。等到之后为其他飞机加油，然后折返。

□除了飞机 1 之外的其他飞机恰好为其他飞机加一次油，使得每个其他飞机得到相同多的 油量。

输入仏^ ，输出最少需要时用多少架飞机才能完成环游地球。例如^ = 1 , ^ = 2时需要 5 架。无解输出-1。

习题 10-23 Hendrie序列(Hendrie Sequence, UVa10479 )

Hendrie序列是一个自描述序列，定义如下：

□ H（1）=0。

□如果把 H 中的每个整数 x 变成 x 个 0 后面跟着 x+1 ，则得到的序列仍然是 H （只是少了第一 个元素）。

因此，H序列的前几项为：0，1，0，2,1，0，0，3，0，2,1,1，0，0，0，4,1，0，0，3，0，……输入正整 数权（n<263 ），求 H（n）。

习题 10-24 幂之和( Sum of Powers, UVa766)

对于正整数^，可以定义&次方和：

可以把它写成下面的形式。当似取最小可能的正整数时，所有系数％都是确定的。

输入女(0<A<20)，输出 1 人卜冬…例如，A=2，输出 6, 2, 3, 1，0。

习题 10-25 因子( Factors, ACM/ICPC World Finals 2013, UVa1575)

算术基本定理：每一个大于 1 的正整数都有唯一的方式写成若干个素数的乘积。不过如

果允许把这些素数重排，就有多种表示方式：

10 = 2 * 5 = 5 * 2, 20 = 2 * 2 * 5 = 2 * 5 * 2 = 5 * 2 * 2

令 A 幻为正整数&的写法个数，如 f(10)=2，f(20)=3。对于正整数 n，可以证明一定有整 数女使得/(^)=n。你的任务是求出最小的^。n<263。

习题 10-26 方形花园( Square Garden, UVa12520)

在 Z*£ ( £<106 )网格里涂色 n ( n<L2 )个格子，要求涂色格子的轮廓线周长尽量大。例 如，图 10-22中为 L=3，n=8的两组解，图 10-23 ( a )的周长为 16，图 10-23 (办)的周长为 12。

(a)

图 10-23 L=3



(b)

n=8的两组解



习题 10-27 互联( Interconnect, ACM/ICPC NEERC 2006, UVa1390)

输入 n 个点 rn 条边的无向图 G ( n<30，rn^1000 )。每次随机加一条非自环的边(w，v)(加 完后可以出现重边)。添加每条边的概率是相等的，求使 G 连通的期望操作次数。

习题 10-28 数字串( Number String, ACM/ICPC Changchun 2011, UVa1650)

每个排列都可以算出一个特征，即从第二个数开始每个数和前面一个数相比是增加(I)还 是减少(D)。例如，｛3,1,2,7,4,6,5｝的特征是 DIIDID。输入一个长度为 n-1 ( 2<n<1001 )的字符 串(包含字符/，    D和？)，统计 1〜n有多少个排列的特征和它匹配(其中?表示 I 和 D 都符

合)。输出答案除以 1000000007 的余数。

习题 10-29 名次表的变化( Fantasy Cricket, UVa11982)

如图 10-24所示为一个足球比赛的名次表，给出了每个队伍相对上一轮的排名变化。例

如：

![img](97d5de5b65e8cf78082c24809 (97d57a2f0ee16f66de5b)-229.jpg)



这代表队伍 A 的名次提高了，B降低了，C提高了，D降低了。用 U 表示排名上升，D表示 降低，E表示不变，则上表可以用 UDUD 表示。经过计算可知，上一轮的名次表有两种可 能：BADC和 BDAC (假定本轮和上一轮的名次都没有并列)。

输入这样一个 UDE 组成的序列(长度不超过 1000 )，求上一轮名次有多少种可能。输出 答案除以 109+7的余数。

习题 10-30 守卫( Guard, ACM/ICPC Dhaka 2011, UVa12371)

在 n*n棋盘上放 2n 个守卫，使得每行每列均恰好有两个守卫，且一个格子里最多只有一 个守卫。如图 10-25所示是两种方法，其中图 10-25 ( a )的守卫形成一个大圈，图 10-25 ( b ) 中形成两个小圈。

(a)

图 10-25



两种守卫方法



输入 n、k ( 2<n<105 , 1<k<rnin(n，50))，输出恰好包含 k 个圈的方案总数。例 如，n=2 , k=1答案为 1 ; n=3 , k=1 ，答案为 6 ; n=4 , k=1 ，答案为 72 ; n=4 , k=2 ，答案为 18 。

习题 10-31 守卫 II ( Guards II, ACM/ICPC Dhaka 2012, UVa12590 )

在 n 行 rn 列的棋盘里放 k 个车，使得边界格子都被攻击到。输出方案总数除以 109+7的余 数。n，m，k<100。输入最多包含 20000 组数据。

习题 10-32 汉诺塔( Hanoi Towers, ACM/ICPC NEERC 2007, UVa1414)

Hanoi塔问题有一种构造解法：把 6 种移动(ABAQB^BQC^CB )排序后选择第一个能 用的操作，前提是不能连续移动同一个盘子。给出 n ( n<30 )和 6 种移动的顺序，求解 Hanoi 问题的步数。最终所有盘子可以都在 B 也可以都在 C。例如，对于 n=2，排序为 AB, BA, CA, BC, CB, AC，—共需要 5 步。

习题 10-33 二元运算( Binary Operation, ACM/ICPC NEERC 2010, UVa1651)

给定正整数 a<6，你的任务是计萬/®(a+l)®(“+2)® — ®(Z?-l) op 的值，其中的 计算方法是这样的：首先，如果和的位数不同，位数较少的一个前面补 0 ；然后逐位执行 ©操作。例如，当©表示“加起来模 10”时，    :。的计算方法如下：

操作符是左结合的，因此.    从左到右计算即可。

输入©的运算表(一个 10*10矩阵，表示 0©0, 0©1,…，9©9的结果，其中 0©0保证为 0 ) 和 a, b ( 0<a<办<1018 )的值，输出所求结果。

习题 10-34 记住 密码( Password Remembering, ACM/ICPC Dhaka 2009, UVa12212)

输入正整数 A 5 ( A<B<264 )，求有多少个整数 n 满足：n在 A 和 B 之间(即 A<n<B )，

且 n 翻转之后也在 A 和 B 之间。1203翻转以后为 3021，1050翻转以后是 501。

习题 10-35 Fibonacci单词(Fibonacci Word, ACM/ICPC World Finals 2012, UVa1282 )

0    if /7 = 0

F{n) — < 1    if a? = 1

F(w -1) + F(/7 - 2) if

输入非空 01 串^nn ( 0<n<100 )，求在 F(n)中出现几次。夕的长度不超过 100000。

习题 10-36 Fibonacci进制(Fibonacci System, ACM/ICPC NEERC 2008, UVa1652 ) 每个正整数都可以写成\彳厂-彳 i…-U|/'i，其中 an=1，^就是第 Z•个 Fibonacci 数

，然后用.■.    作为#的 Fibonacci 进制表示。规定不能出现两个连续的 1。例

如，卜 7的 Fibonacci 进制表示分别为：1, 10，100，101, 1000，1001, 1010。

把所有自然数的 Fibonacci 进制表示拼起来，会得到一个长长的串 110100101100010011010…。输入 n n ( n<1015 )，统计前 n 位有多少个 1。

习题 10-37 倍数问题( Yet Another Multiple Problem, Chengdu 2012, UVa1653)

输入一个整数 n ( 1<n<10000 )和 rn 个十进制数字，找 n 的最小倍数，其十进制表示中不 含这 m 个数字中的任何一个。

提示：需要建一张图，结点 i 代表除以 n 的余数等于 i。巧妙地利用第 6 章学过的 BFS 树可 以简洁地解决这个问题。

习题 10-38 正多边形( Regular Polygon, UVa10824)

给出圆周上的 n(n<2000 )个点，选出其中的若干个组成一个正多形，有多少种方法？ 输出每行包含两个整数和 F，表示有 F 种选法得到正边形。各行应按从小到大排序。

习题 10-39 圆周上的三角形( Circum Triangle, UVa11186)

在一个圆周上有打(n<500 )个点。不难证明，其中任意 3 个点都不共线，因此都可以组 成一个三角形。求这些三角形的面积之和。

习题 10-40    实验法计算概率( Probability Through Experiments, ACM/ICPC Hatyai

2012, UVa12535)

输入圆的半径和圆上 n ( n<20000 )个点的极角，任选 3 点能组成多少个锐角三角形？ 习题 10-41 整数序列( A Sequence of Numbers, ACM/ICPC Chengdu 2007, UVa1406)

输入 n 个整数，执行 2 个操作(n<105，2<200000 )。有两种操作：

□    ADD d :把所有数加上一个定值 d。

□    QUERY i :统计有多少个数的二进制表示法中第 i 位上是 1，并输出。

习题 10-42 网格中的三角形( Triangles in the Grid, UVa12508)

一个 n 行 m 列的网格有 n+1条横线和 m+1条竖线。任选 3 个点，可以组成很多三角形。其中 有多少个三角形的面积位于闭区间 W］内？ 1^n，m^200 , 0^AHnm。

习题 10-43 整数对( Pair of Integers, ACM/ICPC NEERC 2001, UVa1654)

考虑一个不含前导 0 的正整数把它去掉一个数字以后得到另外一个数 y。输入+!的

值#（ 1<^<109），输出所有可能的等式 1+!=#。例如，#=34有两个解：31+3=34 ; 27+7=34。

习题 10-44 选整数( K-Multiple Free Set, UVa11246)

给定正整数 k ，从 1〜n的整数中选出尽量多的整数，使得没有一个整数是另一个整数 的 k 倍。例如，n=10 , k=2 ，最多可以选 6 个：1,3,4,5,7,9。1<n<109 , 2<k<100。

习题 10-45 带符号二进制( Power Signs, UVa11166)

每个整数都可以写成二进制。现将二进制变一下：每个数位上可以是 0 和 1，还可以是-

1。例如， 13可以写成（1，0，0，-1，-1）=24-21-20。在这种进位制下，正整数的表示方法不唯一， 例如， 7可以写成（1，1，1）或者（1，0，0，-1）。你的任务是找一种非 0 数字最少的表示法。

输入每组数据第一行为用二进制表示的正整数 n（n<25000 ），保证不含前导 0。对于每组 数据，输出非 0 数字最小的表示法（ 0表示 0， +表示 1， -表示-1）。如果有多解，输出字典序 最小的。



习题 10-46 抽奖( Honorary Tickets, UVa11895)

在一次抽奖活动中，有 n （ 1<n<105 ）个抽奖箱，其中第/个箱子里有（ Zz〉0 ）个信封，

其中 li 个里面有奖。所有人依次抽奖（即自主选择一个抽奖箱，然后随机抽一个信封），每 次抽完后的空信封放回去。假设每个人都知道上述数据，并且足够聪明，求第 k 个人抽到奖 的概率（用最简分数表示，保证分子和分母都在 32 位带符号整数范围内）。注意，每个人抽 到奖之后只会默默地将它拿出，其他人并不会知道，因此不会改变既定的策略。

习题 10-47 随机数( Randomness, UVa11429)

你有一个随机数发生器（R#G ），可以得到 1〜及（2<R<1000 ）之间的随机整数（每个 整数的概率均为 1/R ）。现在你希望用它在#（ 2<#<1000 ）个事件中随机选择一个，使得事 件•的概率 Pz 等于给定的有理数 az/bz （ 1^az<bf1000 ）。你的任务是设计一个 RNG 使用算法， 使得对 RNG 的调用次数的数学期望尽量小。可以多次使用这个 RNG。

例如，当 R=2，N=4，厂，厂：广尸，U时，则只需调用两次 RNG，—共有 4 种可能的结 果，分别对应一个事件。

习题 10-48 考试( Exam, ACM/ICPC Chengdu 2012, UVa1655)

设/⑻为满足 ab|;v的（a,b）个数。输入 n （ 1<n<10Z1 ），求 f（ 1 ）+f（2）+…+f（n）。例如，/山 1 （即（1，1），（1，2），（2，1），（1，3），（3，1），（1，6），（6，1），（2,3），（3,2）），因此 n=6时输出 25。

习题 10-49 指数塔( Exponential Towers, ACM/ICPC NWERC 2013, UVa1656)

用“A”来表示指数运算，即 aAb=ab，例如，256=2A2A3=4A2A2 （注意“A”是右结合的，即

2A2A3表示 2^（2A3））。定义| \    - * -（卜这样的表达式为“高度为&的指数



八八，’八• • •、

塔”，其中女>1，且所有整数 az〉1。输入一个高度为 3 的指数塔 aAbAc （ 1<a,b,c<9585 ），统计有 多少个高度至少为 3 的指数塔的值等于 aAbAc。注意，9585这个常数可以保证输出小于 263。

习题 10-50 排列( Permutation, UVa11303)

输入一个长度为 m 的序列，每个元素均为 1〜n的正整数，并且不含相同元素。找出 1 〜n的排列中有哪些排列包含输入子序列（不一定连续出现），求出字典序第刎、的。例如， 若输入子序列为 1, 3, 2, n=4，则一共有 4 个排列：1,3,2,4 ; 1,3,4,2 ; 1,4,3,2 ; 4,1,3,2，它们的字 典序分别为第 1， 2， 3， 4小。 1<n<250， 1<m<n。

习题 10-51 游戏( Game, ACM/ICPC ACM/ICPC NEERC 2003, UVa1657)

有这样一^个游戏：裁判先公布一^个正整数打（2<n<200 ），然后在 1〜n中选两个不同的整 数和 y （ x<y ），把 x+y告诉 S 先生，把 x*y告诉 P 先生，然后依次循环 S 先生和 P 先生是否知道 这两个数是几（总是先问 S 先生）。例如：

裁判：n=10 （然后悄悄告诉 S : ^+y=9, ;v*y=18 ）。

S先生：不知道^和 y 是多少。

P先生:不知道^和 y 是多少。

S先生:不知道^和 y 是多少。

P先生：不知道^和 y 是多少。

S先生：知道了。 x=3，y=6。

两人一共说了 m 次“不知道”后，下一个人算出了答案。已知 S 和 P 都非常聪明且精于心 算，你的任务是根据《和讲(0<m<100)计算出所有可能的(x，y)。

例如，n=10，m=4时有 3 个解:(2,5), (3,6), (3,10)。
