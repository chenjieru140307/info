---
title: 04 合法的括号
toc: true
date: 2019-07-01
---
# 合法的括号

小朗朗学校的计算机课正在学习 racket 编程语言，这门语言是函数式编程语言。作为教学语言，它能够让我们学习函数式编程。所谓函数式编程，就是几乎所有的语句都是通过函数来完成的，例如在 racket 里没有循环，循环是通过递归调用函数来实现的，也就是说，代码里面充满了括号。老师每次在判作业的时候，都发现同学对于括号的运用没有掌握好，总是会有左右括号不匹配的问题。注意：函数是一个功能代码的集合，方便人们反复调用。

下面的代码就是一小段 racket 编程语言的代码，我们不用理解它的含义。

```
01（define（rainbow p）
02（map（lambda（color）
03（colorize p color））
04（list ＂red＂ ＂orange＂ ＂yellow＂ ＂green＂ ＂blue＂ ＂purple＂）））
05（rainbow（square 5））
```

## 问题求解

为了帮助老师更快地修改学生的括号匹配问题，小朗朗决定开发一个小程序，来寻找正确的小括号组合。我们对包含括号的合法的字符串并不陌生，字符串中的左右括号数应该相同，而且每个右括号左边一定有其对应的左括号。

给定一个包含括号的字符串，那么问题就变成了在一个给定的输入字符串中，移除掉最少量的错误括号，从而使得这个字符串变为有效的字符串，并且返回所有有效的字符串。

注意：字符串中除了（和）之外，还有字母和数字。

对于括号匹配的问题，最先想到的应该是用栈来解决。常规的处理操作是，在遇到左括号的时候入栈，遇见右括号的时候出栈。

但是，我们知道对于最短路径，广度优先遍历算法不仅可以找到合法字符串，还可以找到经过最少的变化就能得到的合法字符串，所以广度优先遍历算法更适合解决这个问题。

举一个例子，有一个学生写了这样一个字符串：（a）（b））（），我们的程序应该能够识别最长的合法字符串有两个：（a）（b）（）和（a（b））（）。分别是由去掉图 5.8所示的下画线标注的括号得到的。

<p align="center">
    <img width="70%" height="70%" src="http://images.iterate.site/blog/image/20190701/rjFCnw64mnUk.png?imageslim">
</p>


对于一个字符串，在任何时候如果右括号的个数大于左括号的个数，则说明从开始到现在的位置肯定可以删除若干个右括号。如果这个子字符串包含多个右括号，该删除哪一个呢？当然是删除任何一个都可以。对于上面这个例子来说，从开头到第三个右括号的位置多了一个右括号，因此我们需要删掉一个，分别删除这三个右括号，但是只会产生两个结果，因为删除第二个右括号和第三个右括号会得到同样的结果。<span style="color:red;">嗯，可能会得到相同的结果。</span>

在删除括号的时候，为保证不会产生重复值，需要记录之前的结果，避免出现重复。其实还有更好的办法，这里先留一个悬念，之后我们再讲解如何防止重复。这样，就可以使当前这个子字符串不再包含多余的右括号了。对于（ab）（），虽然也是合法字符串，但是它是通过删除 3 个左括号或右括号得到的，并不是最长的合法字符串，所以不是我们想要的结果。

还有一种情况是包含了多余的左括号，可以使用同样的方法去除多余的左括号。例如，输入是（a）（b））（，那么程序应该能够识别最长的合法字符串为（a）（b），如图 5.9所示。

<p align="center">
    <img width="70%" height="70%" src="http://images.iterate.site/blog/image/20190701/MFQlEqFAQxu6.png?imageslim">
</p>


首先，解决什么样的字符串是合法的字符串的问题。为了判断一个字符串是否合法，就像上面提到的，可以使用一个栈，这也是栈这种数据结构的一个典型应用。

为了简化操作，还可以使用一个变量来模拟栈，从头到尾地扫描字符串，只要遇到左括号就让变量加 1，遇到右括号就让变量减 1，一旦发现在这个过程中，某一步使得该变量的值小于 0，就说明该字符串是一个非法字符串，如果全部都通过的话，就说明它是合法字符串。这种只用一个计数变量的方法不仅容易理解，同时相比于传统的栈的方法，能够节省很多内存开销。注意：错误情况包括左右括号数量不相等，左右括号顺序不对。

我们从最开始的字符串出发分析这个问题。使用广度优先遍历算法，一定少不了队列，二话不说，先把初始字符串加入队列再说。

我们每次从队列中取出一个字符串，查看它是不是合法的，如果它是合法的，则把它加入结果集，返回结果就好了。如果不合法，我们该怎么办呢？

其实很简单，如果这个字符串不合法，遍历这个字符串，只要遇到左右括号字符的时候，我们就去掉该括号字符生成一个新的字符串，把它也加入到队列中进行分析。对于括号数量为 N 的字符串，理论上，这一步要产生 N-1个子字符串，当然还要去除重复的数据，可能会小于 N-1个子字符串，如图 5.10所示。

<p align="center">
    <img width="70%" height="70%" src="http://images.iterate.site/blog/image/20190701/OmHsXtwCTtNh.png?imageslim">
</p>


为了减少重复的计算，可以把字符串放到一个哈希集合里，在上一个问题中，我们知道集合是不存储相同的值的，在这里，我们同样利用这个性质来去重。注意：每个生成的子节点就是对每个位置移除左括号或者右括号剩下的子字符串。

这个问题要求去除最少的括号来得到给定字符串的合法的含有括号的字符串，我们需要找出所有合法的结果，还要保证去除最少的括号，要同时满足这两个条件。

找出所有合法的结果需要我们一直找到队列为空为止。而保证去除最少的括号，需要当发现了合法字符串以后，就不要再分析比它更短的字符串了，这就需要一层一层地分析。如果发现了合法的字符串，就不需要继续搜索下去了，直接跳出循环，这里我们使用的技术叫作剪枝。注意：在搜索过程中，所谓剪枝是通过某种判断，避免一些不必要的遍历过程，就是剪去搜索树中的某些枝条。

对队列中的每个字符串都进行相同的操作，还有一种情况是直到队列为空还没找到合法的字符串，那就返回空集。

我们使用集合来去除重复的临时数据，最终的结果也需要去除重复的数据，可以使用上一个问题中的 set（）函数来帮忙，代码如下：

```
01 queue=[str]　　　　　　#先把初始字符串加入队列
02 queue=list（set（set））　 #去除重复数据的方法注意：set（）函数和 list（）函数是两个非常重要的函数，分别用于创建集合和列表以及进行相应的转换。
```

你对广度优先遍历的算法模板一定很熟悉了，来看下面的代码：

在每一层的分析中，我们都需要把队列中合法的字符串加到最终结果的集合中，为此，还需要创建一个数组存储最终的结果。

```
01 res=[]　　　　　　　　　#res存放最终结果
```

接下来，就可以使用广度优先遍历算法对队列进行分析了。需要对队列中的每个元素进行判断，考查它是否为合法字符串。和以往不一样的地方在于，分析完一个数据后不是立即把它删除，而是留下来做之后的数据处理，这样设计的原因在于算法是一层一层地进行分析的。这样一来就需要在发现合法字符串以后就结束循环，而在本层分析中没有发现合法字符串时才生成下一层字符串。代码如下：

由于采用了层级分析，所以每一轮 for 循环处理的字符串都是等长的字符串，如果没有发现合法的字符串才会继续分析下一轮长度减 1 的字符串。为了得到下一层的字符串，可以从队列中拿出每个字符串，按照之前的分析，只要遇到左右括号字符，就去掉该括号字符生成一个新的字符串，把它也加入到队列之中。




## 最终代码


整合上面的代码，我们来看完整的代码，如代码 5.3所示。


```py
def isvalid(str):
    count = 0  # 创建一个变量记录括号的数量
    for c in str:
        if c == '(':  # 遇到左括号就让变量加一
            count += 1
        elif c == ')':
            count -= 1  # 遇到右括号就让变量减一
            if count < 0:
                return False
    return count == 0


def bfs(str):
    res = []  # res存放最终结果
    queue = [str]  # 先把初始字符串加入队列
    while len(queue) > 0:  # 队列不为空的时候就开始广度优先遍历。
        for i in range(len(queue)):  # 依次从队列中取出字符串开始分析
            if isvalid(queue[i]):
                res.append(queue[i])  # 发现合法字符串就放到结果集里
            if len(res) > 0:
                return list(set(res))  # 如果发现合法字符串就结束掉循环返回结果，并用集合去重
        temp = []  # 建立临时结果集
        for s in queue:  # 取出队列中每一个字符串
            for i in range(len(s)):  # 对于每个字符串，分别查看每个字符
                if s[i] == '(' or s[i] == ')':
                    temp.append(s[:i] + s[i + 1:])
        queue = list(set(temp))  # 把新生成的字符串赋值给队列，并用 set()函数去重
        return list(set(res))  # 先把数组转换为集合，再转换回数组来去重
```

这个问题是使用广度优先搜索算法来解决的，但是又和之前的问题不太一样。在之前的问题中，每处理完一个数据就把它从队列中去除，同时，按照某种特定的规则来寻找新的数据再加入到队列之中。而在本题中，为了能够得到所有的最长的合法字符串，我们采用一层一层分析的方式，为此需要保留本层数据以备生成下一层数据。同时，在本例中，我们再次使用了集合来解决重复问题。广度优先搜索算法的变化很多，核心就是由近到远地寻找目标元素。
