---
title: 05 神奇的词根
toc: true
date: 2019-06-26
---
# 可以补充进来的

- 这个题有问题吧？没说这个词根必须是从开头开始的。。
- 不过这个例子还是挺好的。

# 神奇的词根

在英语课上，英语老师为了让同学们掌握常见的词根来帮助理解和记忆单词，发明了一个游戏。

先来解释一下词根（root）的概念，它可以跟其他一些词组成另一个较长的单词，我们称这个单词为继承词（successor）。比如，词根 dis 跟随着单词 able（能够），可以形成新的单词 disable（不能够）。

这个游戏的玩法是这样的，给定一个由许多词根组成的字典和一个句子。你需要将句子中的所有继承词用词根替换掉。如果继承词中有许多形成它的词根，则用最短的词根替换它。

例如，字典为[＂cat＂,＂bat＂,＂rat＂]，句子为＂the cattle was rattled by the battery＂，经过替换，输出句子为＂the cat was rat by the bat＂。

<p align="center">
    <img width="70%" height="70%" src="http://images.iterate.site/blog/image/20190701/RwOIYQ2ERVSN.png?imageslim">
</p>

小朗朗准备写一个程序来解决这个问题，你可以帮帮他吗？

## 问题求解

先来看一下暴力破解法，由于输入是一个句子，所以需要先把句子转换为列表。

对于字典中的每一个词根来说，依次判断句子中的每个单词是否以这个词根开头，如果以它开头的话，就把该单词用词根替换掉。假如该词根的位数为 $n$，可以通过截取第 i 个单词（ $s[i]$ ）的前 $n$ 位和该词根进行比较以判断是否相等，代码如下：


再用一个循环遍历所有的词根，对于每个词根都执行相同的操作，最后把所有的代码拼接起来即可，拼接字符串可以使用字符串的 join 函数来完成。

上面的代码虽然能够解决问题，但是效率太低。对于大数据量的问题，肯定是无法完成任务的，那么该如何优化算法呢？

该问题的本质还是一个查找问题，那么来看一下哈希能否对刚才的查找过程进行优化。

在暴力破解法中，对于每一个词根，需要在所有的单词中截取相应位数的子字符串，假如词根数量很多或者单词数量很多，双重循环的效率会比较低。在这个过程中，可以把用单词去匹配词根的过程通过哈希来优化。

首先建立两个字典，并做好初始化工作。在建立字典时我们使用 `collections.defaultdict()`建立一个默认字典，它本身是一个字典，只不过 python 会自动为它的键赋一个初始值，也就是说，你不显式地为字典的键赋初值 python 不会报错，代码如下：<span style="color:red;">嗯，平时很少用 `collections.defaultdict()` </span>



接下来，以每一个词根的首字母为键，把每一个词根放到该键所对应的值中去，这里的值是一个集合（set），同时记录下该首字母所对应的词根的最大长度是多少，这样一来，之后对比单词的前缀时，只需要看这个最大长度即可，代码如下：

```
01 for w in dict:
02　　d[w[0]].add（w）
03　　s[w[0]]=max（s[w[0]],len（w））
```


两个字典建立好了，如何使用它们呢？首先把每个单词拿出来，查找以该单词开头的词根是否能够和这个单词匹配，s 字典里记录了以某个字母开头的词根的最大长度，从第一位开始截取一直截取到最大长度，如果发现这个子字符串确实是一个词根的话，则修改单词，并结束该轮循环。为了方便记录下标和读取单词，使用 enumerate() 函数来遍历句子，它会把索引放到第一个变量，把元素放到第二个变量。

最后通过字符串的 join 方法连接各个单词即可。

## 最终代码

这个游戏的最终代码如代码 3.5所示。

```py
import collections


def replace_words(dict, sentence):
    d = collections.defaultdict(set)
    s = collections.defaultdict(int)
    sentence = sentence.split()
    for w in dict:
        print(w[0])
        d[w[0]].add(w)
        s[w[0]] = max(s[w[0]], len(w))
    for i, w in enumerate(sentence):
        for j in range(s[w[0]]):
            if w[:j + 1] in d[w[0]]:  # 从短到长进行匹配
                sentence[i] = w[:j + 1]  # 替换为匹配到的词根
                break
    return ' '.join(sentence)
```




# 相关

- 《你也能看得懂的 python 算法书》
