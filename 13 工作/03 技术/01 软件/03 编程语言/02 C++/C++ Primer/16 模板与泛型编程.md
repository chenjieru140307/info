
第 16 章

### 模板与泛型编程

<65T|



内容

面向对象编程（OOP）和泛型编程都能处理在编写程序时不知道类型的情况。不同之 处在于：OOP能处理类型在程序运行之前都未知的情况；而在泛型编程中，在编译吋就能 获知类型了。

本书第 II 部分中介绍的容器、迭代器和算法都是泛型编程的例子。当我们编写一个泛 型程序吋，是独立于任何特定类型来编写代码的。当使用一个泛型程序时，我们提供类型 或值，程序实例可在其上运行。

例如，标准库为每个容器提供了单一的、泛型的定义，如 vector。我们可以使用这 个泛型定义来定义很多类型的 vector，它们的差异就在于包含的元素类型不同。

模板是泛型编程的基础。我们不必了解模板是如何定义的就能使用它们，实际上我们 已经这样用了。在本章中，我们将学习如何定义自己的模板。

[652>    模板是 C++中泛型编程的基础。一个模板就是一个创建类或函数的蓝图或者说公式。

当使用一个 vector 这样的泛型类型，或者 find 这样的泛型函数时，我们提供足够的信 息，将蓝图转换为特定的类或函数。这种转换发生在编译时。在本书第 3 章和第 II 部分中 我们已经学习了如何使用模板。在本章中，我们将学习如何定义模板。

##### 16.1定义模板

假定我们希望编写一个函数来比较两个值，并指出第一个值是小于、等于还是大于第 二个值。在实际中，我们可能想要定义多个函数，每个函数比较一种给定类型的值。我们 的初次尝试可能定义多个重载函数：

//如果两个值相等，返回 0，如果 vl 小返回-1，如果 v2 小返回 1 int compare(const string &vl, const string &v2)

{

if (vl < v2) return -1; if (v2 < vl) return 1; return 0;

}

int compare(const double &vl, const double &v2)

{

if (vl < v2) return -1; if (v2 < vl) return 1; return 0;

}

这两个函数几乎是相同的，唯一的差异是参数的类型，函数体则完全一样。

如果对每种希望比较的类型都不得不重复定义完全一样的函数体，是非常烦琐且容易 出错的。更麻烦的是，在编写程序的时候，我们就要确定可能要 compare 的所有类型。 如果希望能在用户提供的类型上使用此函数，这种策略就失效了。

###### 50 16.1.1函数模板

我们可以定义一个通用的函数模板(function template)，而不是为每个类型都定义一 个新函数。一个函数模板就是一个公式，可用来生成针对特定类型的函数版本。compare 的模板版本可能像下面这样：

template <typename T>

int compare(const T &vl, const T &v2)

{

if (vl < v2) return -1; if (v2 < vl) return 1; return 0;

}

L-6533>模板定义以关键字 template 开始，后跟一个模板参数列表(template parameter list)，这 是一个逗号分隔的一个或多个模板参数(template parameter)的列表，用小于号(<)和大 于号(>)包围起来。

在模板定义中，模板参数列表不能为空。

模板参数列表的作用很像函数参数列表。函数参数列表定义了若干特定类型的局部变 量，但并末指出如何初始化它们。在运行时，调用者提供实参来初始化形参。

类似的，模板参数表示在类或函数定义中用到的类型或值。当使用模板吋，我们(隐 式地或显式地)拒定模板实参(template argument)，将其绑定到模板参数上。

我们的 compare 函数声明了一个名为 T 的类型参数。在 compare 中，我们用名字 T 表示一个类型。而 T 表示的实际类型则在编译时根据 compare 的使用情况來确定。

实例化函数模板

当我们调用一个函数模板时，编译器(通常)用函数实参来为我们推断模板实参，即， 当我们调用 compare 时，编译器使用实参的类型來确定绑定到模板参数 T 的类型。例如， 在下面的调用中：

cout « compare(1, 0) « endl; // T 为 int

实参类型是 int。编译器会推断出模板实参为 int，并将它绑定到模板参数 T。

编译器用推断出的模板参数来为我们实例化(instantiate) 个特定版本的函数。当编 译器实例化一个模板时，它使用实际的模板实参代替对应的模板参数来创建出模板的个 新"实例”。例如，给定下面的调用：

//实例化出 int compare(const int&, const int&) cout « compare(1, 0) << endl; // T 为 int

// 实例化出 int compare (const vector<int>&, const vector<int>&)

vector<int> vecl{1, 2, 3}, vec2{4, 5, 6};

cout << compare (vecl, vec2) << endl; // T 为 vector<int>

编译器会实例化出两个不同版本的 compareo 对于第一个调用，编译器会编写并编译一 个 compare 版本，其中 T 被锌换为 int:

int compare(const int &vl, const int &v2)

{

if (vl < v2) return -1; if (v2 < vl) return 1; return 0;

}

对于第二个调用，编译器会生成另一个 compare 版本，其中 T 被转换为 vector<int>。 这些编译器生成的版本通常被称为模板的实例(instantiation)o 模板类型参数

<654~|



我们的 compare 函数有一个模板类型参数(type parameter)。一般来说，我们可以将 类型参数看作类型说明符，就像内置类型或类类型说明符一样使用。特别是，类型参数可 以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或类型转换：

//正确：返回类型和参数类型相同 template <typename T> T foo(T* p)

{

T tmp = *p; // tmp的类型将是指针 p 指向的类型 //...

return tmp;

类型参数前必须使用关键字 class 或 typename：

//错误：U之前必须加上 class 或 typename

template〈typename T, U> T calc (const T&, const U&);

在模板参数列表中，这两个关键字的含义相同，可以互换使用。一个模板参数列表中可以 同时使用这两个关键字：

//正确：在模板参数列表中，typename和 class 没有什么不同 template <typename T, class U> calc (const T&, const U&);

看起来用关键字 typename 来指定模板类型参数比用 class 更为直观。毕竟，我们 可以用内置(非类)类型作为模板类型实参。而且，typename更清楚地指出随后的名字 是一个类型名。但是，typename是在模板已经广泛使用之后才引入 C++语言的，某些程 序员仍然只用 class。

非类型模板参数

除了定义类型参数，还可以在模板中定义非类型参数(nontype parameter)。一个非类 型参数表示一个值而非一个类型。我们通过一个特定的类型名而非关键字 class 或 typename来指定非类型参数。

当一个模板被实例化时，非类型参数被一个用户提供的或编译器推断出的值所代替。 这些值必须是常量表达式(参见 2.4+4节，第 58 页)，从而允许编译器在编译时实例化 模板。

例如，我们可以编写一个 compare 版本处理字符串字面常量。这种字面常量是 const char的数组。由于不能拷贝一个数组，所以我们将自己的参数定义为数组的引用(参见 6.2.4节，第 195 页)。由于我们希望能比较不同长度的字符串字面常量，因此为模板定义 了两个非类型的参数。第一个模板参数表示第一个数组的长度，第二个参数表示第二个数 组的长度：

I 655〉    template<unsigned N, unsigned M>

int compare(const char (&pl)[N], const char (&p2)[M])

return strcrap(pi, p2);

1

当我们调用这个版本的 compare 时： compare("hi", "mom")

编译器会使用字面常量的大小来代替 N 和 M，从而实例化模板。记住，编译器会在一个字 符串字面常量的末尾插入一个空字符作为终结符(参见 2.1.3节，第 36 页)，因此编译器 会实例化出如下版本：

int compare(const char (&pl) [3], const char (&p2) [4])

一个非类型参数可以是一个整型，或者是一个指向对象或函数类型的指针或(左值) 引用。绑定到非类型整型参数的实参必须是一个常量表达式。绑定到指针或引用非类型参 数的实参必须具有静态的生存期(参见第 12 章，第 400 页)。我们不能用一个普通(非 static)局部变量或动态对象作为指针或引用非类型模板参数的实参。指针参数也可以 用 nullptr 或一个值为 0 的常量表达式来实例化。

在模板定义内，模板非类型参数是一个常量值。在需要常量表达式的地方，可以使用

非类型参数，例如，指定数组大小。

非类型模板参数的模板实参必须是常量表达式。

inline和 constexpr 的函数模板

函数模板可以声明为 inline 或 constexpr 的，如同非模板函数一样。inline或 constexpr说明符放在模板参数列表之后，返冋类型之前：

//正确：inline说明符跟在模板参数列表之后

template <typename T> inline T min(const T&, const T&);

//错误：inline说明符的位置不正确

inline template <typename T> T min(const T&, const T&);

编写类型无关的代码

我们最初的 compare 函数虽然简单，但它说明了编写泛型代码的两个重要原则：

•模板中的函数参数是 const 的引用。

•函数体中的条件判断仅使用 < 比较运算。

通过将函数参数设定为 const 的引用，我们保证了函数可以用于不能拷贝的类型。大多<656： 数类型，包括内置类型和我们己经用过的标准库类型(除 unique_ptr和 IO 类型之外)，

都是允许拷贝的。但是，不允许拷贝的类类型也是存在的。通过&参数设定为 const 的 引用，保证了这些类型可以用我们的 compare 函数来处理。而且，如果 compare 用于 处理大对象，这种设计策略还能使函数运行得更快。

你可能认为既使用<运算符又使用>运算符来进行比较操作会更为自然：

//期望的比较操作 if (vl < v2) return -1; if (vl > v2) return 1; return 0;

但是，如果编写代码时只使用<运算符，我们就降低了 compare函数对要处理的类型的 要求。这些类型必须支持<，但不必同时支持>»

实际上，如果我们真的关心类型无关和可移植性，可能需要用 less (参见 14.8.2节，

第 510 页)来定义我们的函数：

//即使用于指针也正确的 compare 版本；参见 14.8.2节(第 510 页) template <typename T> int compare(const T &vl, const T &v2)

{

if (less<T> () (vl, v2)) return -1; if (less<T> () (v2, vl)) return 1; return 0;

}

原始版本存在的问题是，如果用户调用它比较两个指针，且两个指针未指向相同的数组，

则代码的行为是未定义的(据查阅资料，less<T>的默认实现用的就是<，所以这其实并 未起到让这种比较有一个良好定义的作用——译者注)。

Prcustices 模板程序虚该尽量减少对实参类型的要求。

3编译器遇到-个模板定义吋，它并不生成代码。只有当我们实例化出模板的一个特 定版本时，编译器才会生成代码。当我们使用(而不是定义)模板时，编译器才生成代码， 这一特性影响了我们如何组织代码以及错误何时被检测到。

通常，当我们调用一个函数时，编译器只需要掌握函数的声明。类似的，当我们使用 -个类类型的对象时，类定义必须是可用的，但成员函数的定义不必已经出现。因此，我

们将类定义和函数声明放在头文件中，而普通函数和类的成员函数的定义放在源文件中。

模板则不同：为了生成•个实例化版本，编译器需要掌握函数模板或类模板成员函数 的定义，因此，与非模板代码不模板的头文件通常既包括声明也包括定义。

K键概念：投板和头文件

模板包含两种名字：

•那些不依赖于模板参数的名字

•那些依赖于模板参数的名字

当使用模板时，所有不依赖干模板参数的名字都必须是可见的，这是由模板的提供者来 保证的。而且，模板的提供者必须保证，当模板被实例化时，模板的定义，包括类模板 的成员的定义，也必须是可见的。

用来实例化模板的所有函数、类型以及与类型关联的运算符的声明都必须是可见 的，这是由模板的用户来保证的。

通过组织良好的程序结构，恰当使用头文件，这些要求都很容易满足。模板的设计 者应该提供一个头文件，包含模板定义以及在类模板或成员定义中用到的所有名字的声 明。模板的用户必须包含模板的头文件，以及用来实例化模板的任何类型的头文件、

大多数编译错误在实例化期间报告

模板直到实例化吋才会生成代码，这一特性影响了我们何时才会获知模板内代码的编 译错误，通常，编译器会在三个阶段报告错误，

第•个阶段是编译模板本身时。在这个阶段，编译器通常不会发现很多错误。编译器 可以检查语法错误，例如忘记分 0 或者变量名拼错等，但也就这么多了。

第二个阶段是编译器遇到模板使用时。在此阶段，编译器仍然没有很多可检查的。对 r函数模板调用，编译器通常会检查实参数目是否正确。它还能检查参数类型是否匹配。 对于类模板，编译器可以检查用户是否提供了正确数因的模板实参，但也仅限于此了。

第三个阶段是模板实例化时，只有这个阶段才能发现类型相关的错误。依赖 f 编译器 如何管理实例化，这类错误可能在链接时才报告。

当我们编写模板时，代码不能是针对特定类型的，但模板代码通常对其所使用的类型 有-些假设。例如，我们最初的 compare 函数中的代码就假定实参类型定义了<运算符。

if (vl < v2) return -1;    //要求类型 T 的对象支持〈操作

if (v2 < vl) return 1;    //要求类型 T 的对象支持〈操作

return 0;    //返回 int；不依軸于 T

当编译器处理此模板时，它不能验证 if 语句中的条件是否合法。如果传递给 compare <658j 的实参定义了<运算符，则代码就是正确的，否则就是错误的。例如，

Sales_data datal, data2;

cout << compare （datal, data2） << endl; // 错误：Sales_data 未定义<

此调用实例化了 compare的一个版本，将 T 替换为 Sales_data- if条件试图对 Sales_data对象使用<运算符，但 Sales_data并未定义此运算符。此实例化生成了 一个无&编译通过的函数版本。但是，这样错误直至编译器在类型 Sales_data上实 例化 compare 时才会被发现。

WARNING



保证传递给模板的实参支持模板所要求的操作，以及这些操作在模板中能正确 工作，是调用者的责任。

###### 16.1.1节练习

练习 16.1:给出实例化的定义。

练习 16.2:编写并测试你自己版本的 compare 函数。

练习 16.3:对两个 Sales_data对象调用你的 compare 函数，观察编译器在实例化 过程中如何处理错误。

练习 16.4:编写行为类似标准库 find 算法的模板。函数需要两个模板类型参数，-个 表示函数的迭代器参数，另一个表示值的类型。使用你的函数在一个 一个 list<string>中查找给定值。

练习 16.5:为 6.2.4节（第 195 页）中的 print 函数编写模板版本，它接受一个数组的 引用，能处理任意大小、任意元素类型的数组。

练习 16.6：你认为接受一个数组实参的标准庠函数 begin 和 end 是如何工作的？定义 你自己版本的 begin 和 end。

练习 16.7:編写一个 constexpr 模板，返回给定数组的大小。

练习 16.8:在第 97 页的“关键概念”中，我们注意到，C++程序员喜欢使用！=而不喜 欢<。解释这个习惯的原因。

###### 16.1.2类模板    $0

类模板（class template）是用来生成类的蓝图的。与函数模板的不同之处是，编译器 不能为类模板推断模板参数类型。如我们已经多次看到的，为了使用类模板，我们必须在 模板名后的尖括号中提供额外信息（参见 3.3节，第 87 页）——用来代替模板参数的模板<§59] 实参列表。

定义类模板

作为一个例子，我们将实现 StrBlob （参见 12.1.1节，第 405 页）的模板版本。我 们将此模板命名为 Blob，意指它不再针对 string。类似 StrBlob，我们的模板会提供 对元素的共享（且核查过的）访问能力。与类不同，我们的模板可以用于更多类型的元素。

与标准库容器相同，当使用 Blob 时，用户需要指出元素类型。

类似函数模板，类模板以关键字 template 开始，后跟模板参数列表。在类模板(及 其成员)的定义中，我们将模板参数当作替身，代替使用模板时用户需要提供的类型或值:

template <typename T> class Blob { public:

typedef T value_type;

typedef typename std::vector<T>::size_type size_type;

//构造函数 Blob();

Blob(std::initializer_list<T> il);

// Blob中的元素数目

size_type size() const { return data->size(); } bool empty() const { return data->empty(); }

//添加和删除元素

void push_back(const T &t) {data-〉push_back(t);}

//移动版本，参见 13.6.3节(第 484 页)

void push—back(T &&t)    { data->push_back(std::move(t));    }

void pop_back();

//元•访问 T& back();

T& operator [ ] (size_type i) ; // 在 14.5 节(第 501 瓦)中定义 private:

std::shared_ptr<std::vector<T>> data;

//若 data [i]无效，则抛出 msg

void check(size_type i, const std::string &msg) const;

}；

我们的 Blob 模板有一个名为 T 的模板类型参数，用来表示 Blob 保存的元素的类型。例 如，我们将元素访问操作的返回类型定义为 T&。当用户实例化 Blob 时，T就会被替换为 特定的模板实参类型。

除了模板参数列表和使用 T 代替 string 之外，此类模板的定义与 12.1.1节(第 405 页)中定义的类版本及 12.1.6节(第 422 页)和第 13 章、第 14 章中更新的版本是一样的。

X>实例化类模板

我们已经多次见到，当使用一个类模板时，我们必须提供额外信息。我们现在知道这 些额外信息是显式模板实参(explicit template argument)列表，它们被绑定到模板参数。 编译器使用这些模板实参来实例化出特定的类。

例如，为了用我们的 Blob 模板定义一个类型，必须提供元素类型：

Blob<int> ia;    // 空 Blob<int>

Blob<int> ia2 = {0,1,2,3,4}; // 有 5 个元素的 Blobcint〉

ia和 ia2 使用相同的特定类型版本的 Blob (即 Blob<int>)。从这两个定义，编译器 会实例化出一个与下面定义等价的类：

template <> class Blob<int> {

typedef typename std::vector<int>::size_type size_type; Blob ();

Blob(std::initializer_list<int> il);

//...

int& operator[](size_type i);

private:

std::shared_ptr<std::vector<int>> data;

void check（size_type i, const std::string &msg） const;

｝；

当编译器从我们的 Blob 模板实例化出一个类时，它会重写 Blob 模板，将模板参数 T 的 每个实例替换为给定的模板实参，在本例中是 int。

对我们指定的每一种元素类型，编译器都生成一个不同的类，

//下面的定义实例化出两个不同的 Blob 类型 Blob<string> names; // 保存 string 的 Blob Blob<double> prices; //不同的元素类型

这两个定义会实例化出两个不同的类。names的定义创建了一个 Blob 类，每个 T 都被替 换为 string。prices的定义生成了另一个 Blob 类，T被替换为 double。

![img](C++  Primer 5-152.jpg)



一个类模板的每个实例都形成一个独立的类。类哩 Blob<string〉与任何其 他 Blob 类型都没有关联，也不会对任何其他 Blob 类型的成员有特殊访问权限」

在模板作用域中引用模板类型

为了阅读模板类代码，应该记住类模板的名字不是一个类型名（参见 3.3节，第 87 页）。类模板用来实例化类型，而一个实例化的类型总是包含模板参数的。

可能令人迷惑的是，一个类模板中的代码如果使用了另外一个模板，通常不将一个实 际类型（或值）的名字用作其模板实参。相反的，我们通常将模板自己的参数当作被使用 模板的实参。例如，我们的 data 成员使用了两个模板，vector和 shared_ptr。我们<661 | 知道，无论何时使用模板都必须提供模板实参，在本例中，我们提供的模板实 i 就是 Blob 的模板参数。因此，data的定义如下：

std::shared_ptr<std::vector<T» data;

它使用了 Blob的类型参数来声明 data 是一个 shared_ptr的实例，此 shared_ptr 指向一个保存类型为 T 的对象的 vector 实例。当我们实 7 例化一个特定类型的 Blof，例 如 Blob<string>R^，data 会成为：

shared_ptr<vector<string»

如果我们实例化 Blob<int>，则 data 会成为 shared_ptr<vector<int»，依此类推。

类模板的成员函数

与其他任何类相同，我们既可以在类模板内部，也可以在类模板外部为其定义成员函 数，且定义在类模板内的成员函数被隐式声明为内联函数。

类模板的成员函数本身是一个普通函数。但是，类模板的每个实例都有其自己版本的 成员函数。因此，类模板的成员函数具有和模板相同的模板参数。因而，定义在类模板之 外的成员函数就必须以关键字 template 开始，后接类模板参数列表。

与往常一样，当我们在类外定义一个成员时，必须说明成员属于哪个类。而且，从一 个模板生成的类的名字中必须包含其模板实参。当我们定义一个成员函数时，模板实参与 模板形参相同。即，对于 StrBlob 的一个给定的成员函数

ret-type StrBlob: :member-name(parm-list)

对应的 Blob 的成员应该是这样的：

template ctypename T>

ret-type Blob<T>: :member-name(parm-list)

check和元素访问成员

我们首先定义 check 成员，它检查一个给定的索引:

template <typename T>

void Blob<T>::check(size_type i, const std::string &msg) const {

if (i >= data->size())

throw std::out_of_range(msg);

}

除了类名中的不同之处以及使用了模板参数列表外，此函数与原 StrBlob 类的 check 成 员完全一样。

下标运算符和 back 函数用模板参数指出返回类型，其他未变：

| 662〉    template <typename T>

T& Blob<T>::back()

check(0, "back on empty Blob"); return data->back();

}

template <typename T>

T& Blob<T>::operator[](size_type i)

{

//如果 i 大大，check会抛出异常，阻止访问一个不存在的元素 check(i, "subscript out of range"); return (*data)[i];

}

在原 StrBlob 类中，这些运算符返回 strings。而模板版本则返回一个引用，指向用来 实例化 Blob 的类型。

pop_back函数与原 StrBlob 的成员几乎相同：

template <typename T> void Blob<T>::pop_back()

{

check(0, "pop_back on empty Blob"); data->pop_back();

}

在原 StrBlob 类中，下标运算符和 back 成员都对 const 对象进行了重载。我们将这些 成员及 front 成员的定义留作练习。

Blob构造函数

与其他任何定义在类模板外的成员一样，构造函数的定义要以模板参数开始：

template <typename T>

Blob<T>: :Blob () : data (std: :make_shared<std: : vector<T»() )    { }

这段代码在作用域 Blob<T>中定义了名为 Blob 的成员函数。类似 StrBlob 的默认构造

函数(参见 12.1.1节，第 405 页)，此构造函数分配一个空 vector，并将指向 vector 的指针保存在 data 中。如前所述，我们将类模板自己的类型参数作为 vector 的模板实 参来分配 vector。

类似的，接受一个 initializer_list参数的构造函数将其类型参数 T 作为 initializer_list参数的元素类型：

template <typename T>

Blob<T>::Blob(std::initializer_list<T> il):

data(std::make_shared<std::vector<T»(il))    { }

类似默认构造函数，此构造函数分配一个新的 vector。在本例中，我们用参数 il 来初 始化此 vector。

为了使用这个构造函数，我们必须传递给它一个 initialiZer_liSt，其中的元素 必须与 Blob 的元素类型兼容：

Blob<string> articles = {"a",    "an", "the"};

这条语句中，构造函数的参数类型为 initializer_list<string>。列表中的每个字 符串字面常量隐式地转换为一个 string。

< 663 1



类模板成员函数的实例化

默认情况下，一个类模板的成员函数只有当程序用到它时才进行实例化。例如，下面代码

//实例化 Blob<int>和接受 initializer_list<int>的构造函数

Blob<int> squares = {0,1,2,3,4,5,6,7,8,9};

// 实例化 Blob<int>: :size() const

for (size_t i = 0; i != squares.size(); ++i)

squares [i ] = i*i; // 实例化 Blob<int> :: operator [](size_t)

实例化了 Blob<int>类和它的三个成员函数：operator [] > size和接受 initializer_list<int> 的构造函数。

如果一个成员函数没有被使用，则它不会被实例化。成员函数只有在被用到时才进行 实例化，这一特性使得即使某种类型不能完全符合模板操作的要求(参见 9.2节，第 294 页)，我们仍然能用该类型实例化类。

![img](C++  Primer 5-153.jpg)



默认情况下，对于一个实例化了的类模板，其成员只有在使用时才被实例化。

在类代码内简化模板类名的使用

当我们使用一个类模板类型时必须提供模板实参，但这一规则有一个例外。在类模板 自己的作用域中，我们可以直接使用模板名而不提供实参：

//若试图访问一个不存在的元素，BlobPtr抛出一个异常 template <typename T> class BlobPtr { public:

BlobPtr(): curr(0)    { }

BlobPtr(Blob<T> &a, size_t sz = 0):

wptr(a.data), curr(sz) { }

T& operator*() const

{ auto p = check (curr, "dereference past end，，)； return (*p) [curr] ; // (*p)为本对象指向的 vector

}

//递增和递减

BlobPtr& operator++() ； // 前置运算符 BlobPtr& operator——()；

private:

//若检查成功，check返回一个指向 vector 的 shared_ptr std::shared_ptr<std::vector<T>>

check(std::size_t, const std::strings) const;

//保存一个 weak_ptr，表示底层 vector 可能被销毁 std::weak_ptr<std::vector<T>> wptr; std: : size_t curr; //数组中的当前位置

}；

细心的读者可能已经注意到，BlobPtr的前置递增和递减成员返回 BlobPtr&，而不是 BlobPtr<T>&o当我们处于一个类模板的作用域中时，编译器处理模板自身引用时就好

E6M>像我们已经提供了与模板参数匹配的实参一样。即，就好像我们这样编写代码一样：

BlobPtr<T>& operator++();

BlobPtr<T>& operator——();

在类模板外使用类模板名

当我们在类模板外定义其成员时，必须记住，我们并不在类的作用域中，直到遇到类 名才表示进入类的作用域(参见 7.4节，第 253 页)：

//后置：递增/递减对象但返回原值 template <typename T>

BlobPtr<T> BlobPtr<T>::operator++(int)

{

//此处无须检查；调用前置递增时会进行检查 BlobPtr ret = *this; // 保存当前值 ++*this; //推进一个元素；前置++检查递增是否合法 return ret; //返回保存的状态

}

由于返回类型位于类的作用域之外，我们必须指出返回类型是一个实例化的 BlobPtr, 它所用类型与类实例化所用类型一致。在函数体内，我们己经进入类的作用域，因此在定 义 ret 时无须重复模板实参。如果不提供模板实参，则编译器将假定我们使用的类型与 成员实例化所用类型一致，因此，ret的定义与如下代码等价：

BlobPtr<T> ret = *this;

在一个类模板的作用域内，我们可以直接使用模板名而不必指定模板实参。

类模板和友元

当一个类包含一个友元声明(参见 7.2.1节，第 241 页)时，类与友元各自是否是模 板是相互无关的。如果一个类模板包含一个非模板友元，则友元被授权可以访问所有模板 实例。如果友元自身是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例。

一对一友好关系

类模板与另一个(类或函数)模板间友好关系的最常见的形式是建立对应实例及其友 元间的友好关系。例如，我们的 Blob 类应该将 BlobPtr 类和一个模板版本的 Blob 相

等运算符（最初是在 14.3.1节（第 498 页）练习中为 StrBlob 定义的）定义为友元。

为了引用（类或函数）模板的一个特定实例，我们必须首先声明模板自身。一个模板 声明包括模板参数列表：

//前置声明，在 Blob 中声明友元所需要的

< 665 1



template

template

template

bool



<typename> class BlobPtr;

<typename> class Blob; //运算符==中的参数所需要的 <typename T>

operator==(const Blob<T>&, const Blob<T>&);

template <typename T> class Blob {

//每个 Blob 实例将访问权限授予用相同类型实例化的 BlobPtr 和相等运算符 friend class BlobPtr<T>;

friend bool operator==<T>

(const Blob<T>&, const Blob<T>&);

//其他成员定义，与 12.1.1 (第 405 页)相同

我们首先将 Blob、BlobPtr和 operator==声明为模板。这些声明是 operator==0 数的参数声明以及 Blob 中的友元声明所需要的。

友元的声明用 Blob 的模板形参作为它们自己的模板实参。因此，友好关系被限定在 用相同类型实例化的 Blob 与 BlobPtr 相等运算符之间：

Blob<char> ca; // BlobPtr<char〉和 operator==<char>都是本对象的友元 Blob<int> ia; // BlobPtr<int>和 operator==<int〉都是本对象的友元

BlobPtr<char〉的成员可以访问 ca （或任何其他 Blob<char>对象）的非 public 部 分，但 ca 对 ia （或任何其他 Blobdrit〉对象）或 Blob 的任何其他实例都没有特殊访 问权限。

通用和特定的模板友好关系

一个类也可以将另一个模板的每个实例都声明为自己的友元，或者限定特定的实例为 友元：

//前置声明，在将模板的一个特定实例声明为友元时要用到 template <typename T> class Pal; class C { // C是一个普通的非模板类

friend class Pal<C>; //用类 C 实例化的 Pal 是 C 的一个友元 // Pal2的所有实例都是 C 的友元；这种情况无须前置声明 template <typename T> friend class Pal2;

}；

template ctypename T> class C2 { // C2 本身是一个类模板 // C2的每个实例将相同实例化的 Pal 声明为友元 friend class Pal<T>; // Pal的模板声明必须在作用域之内 // Pal2的所有实例都是 C2 的每个实例的友元，不需要前置声明 template <typename X〉 friend class Pal2;

// Pal3是一个非模板类，它是 C2 所有实例的友元 friend class Pal3; //不需要 Pal3 的前置声明

}；

为了让所有实例成为友元，友元声明中必须使用与类模板本身不同的模板参数。

[»令模板自己的类型参数成为友元

py]    在新标准中，我们可以将模板类型参数声明为友元：

template ctypename Type〉 class Bar { friend Type; //将访问权限授予用来实例化 Bar 的类型

}；

此处我们将用来实例化 Bar 的类型声明为友元。因此，对于某个类型名 Foo, Foo将成 为 Bar<Foo>W友元，Sales一 data 将成为 Bar<Sales_data>W友元，依此类推》

值得注意的是，虽然友元通常来说应该是一个类或是一个函数，但我们完全可以用一 个内置类型来实例化 Bar。这种与内置类型的友好关系是允许的，以便我们能用内置类型 来实例化 Bar 这样的类。

模板类型别名

类模板的-个实例定义了一个类类型，与任何其他类类型一样，我们可以定义一个 typedef （参见 2.5.1节，第 60 页）来引用实例化的类：

typedef Blob<string> StrBlob;

这条 typedef 语句允许我们运行在 12.1.1节（第 405 页）中编写的代码，而使用的却是 用 string 实例化的模板版本的 Blob。由于模板不是一个类型，我们不能定义一个 typedef引用一个模板。即，无法定义一个 typedef 引用 Blob<T>。

岡 但是，新标准允许我们为类模板定义一个类型别名：

tempiate<typename T> using twin = pair<T, T>; twin<string> authors; II authors是一个 pair<string, string>

在这段代码中，我们将 twin 定义为成员类型相同的 pair 的别名。这样，twin的用户 只需指定一次类型。

一个模板类型别名是一族类的别名：

twin<int> win_loss; // win_loss是一个 pair<int, int> twin<double> area; // area是一个 pair<double, double>

就像使用类模板一样，当我们使用 twin 时，需要指出希望使用哪种特定类型的 twin。 当我们定义一个模板类型别名时，可以固定一个或多个模板参数：

template <typename T> using partNo = pair<T, unsigned〉； partNo<string> books; // books 是一个 pair<string, unsigned〉 partNo<Vehicle> cars; // cars 是一个 pair<Vehicle, unsigned〉 partNo<Student> kids; // kids 是一个 pair<Student, unsigned>

这段代码中我们将 partNo 定义为一族类型的别名，这族类型是 second 成员为 unsigned的 pair。partNo的用户需要指出 pair 的 first 成员的类型，但不能指定 second成员的类型。

E667>类模板的 static 成员

与任何其他类相同，类模板可以声明 static 成员（参见 7.6节，第 269 页）:

template <typename T> class Foo { public:

static std::size_t count ()    { return ctr; }

//其他接口成员

private:

static std::size_t ctr;

//其他实现成员

}；

在这段代码中，Foo是一个类模板，它有一个名为 count 的 public static成员函数 和一个名为 ctr 的 private static数据成员。每个 Foo 的实例都有其自己的 static 成员实例。即，对任意给定类型 X，都有一个 Foo<X> : : ctr和一个 Foo<X> : : count 成员。所有 Foo<X〉类型的对象共享相同的 ctr 对象和 count 函数。例如，

// 实例化 static 成员 Foo<string〉： ： ctr 和 Foo<string>:: count

Foo<string> fs;

//所有三个对象共享相同的 Foo<int>: : ctr和 Foo<int>: :count成员

Foo<int> fi, fi2, fi3;

与任何其他 static 数据成员相同，模板类的每个 static 数据成员必须有且仅有一 个定义。但是，类模板的每个实例都有一个独有的 static 对象。因此，与定义模板的成 员函数类似，我们将 static 数据成员也定义为模板：

template <typename T>

size_t Foo<T>: :ctr = 0; // 定义并初始化 ctr

与类模板的其他任何成员类似，定义的开始部分是模板参数列表，随后是我们定义的成员 的类型和名字。与往常一样，成员名包括成员的类名，对于从模板生成的类来说，类名包 括模板实参。因此，当使用一个特定的模板实参类型实例化 Foo 吋，将会为该类类型实 例化一个独立的 ctr，并将其初始化为 0。

与非模板类的静态成员相同，我们可以通过类类型对象来访问一个类模板的 static 成员，也可以使用作用域运算符直接访问成员。当然，为了通过类来直接访问 static 成 员，我们必须引用一个特定的实例：

Foo<int> f i;    // 实例化 Foo<int>类和 static 数据成员 ctr

auto ct = Foo<int>: : count () ; // 实例化 Foo<int〉：： count ct = f i . count () ;    // 使用 Foo<int〉：： count

ct = Foo: : count () ;    //错误：使用哪个模板实例的 count?

类似任何其他成员函数，一个 static 成员函数只有在使用时才会实例化。

###### 16.1.2节练习

< 668 |



练习 16.9:什么是函数模板？什么是类模板？

练习 16.10:当一个类模板被实例化时，会发生什么？

练习 16.11:下面 List 的定义是错误的。应如何修正它？

template <typename eleraType> class Listltem; template <typename elemType> class List { public:

List<elemType>();

List<elemType>(const List<elemType> &); List<elemType>& operator=(const List<elemType> &); 〜List ();

void insert(Listltem *ptr, elemType value); private:

Listltem *front, *end;

}；

练习 16.12：编写你自己版本的 Blob 和 BlobPtr 模板，包含书中未定义的多个 const 成员。

练习 16.13:解释你为 BlobPtr 的相等和关系运算符选择哪种类型的友好关系？

练习 16.14：编写 Screen 类模板，用非类型参数定义 Screen 的高和宽。

练习 16.15：为你的 Screen 模板实现输入和输出运算符。Screen类需要哪些友元(如 果需要的话)来令输入和输出运算符正确工作？解释每个友元声明(如果有的话)为什 么是必要的。

练习 16.16:将 StrVec 类(参见 13.5节，第 465 页)重写为模板，命名为 Vec。

###### 16.1.3模板参数

类似函数参数的名字，一个模板参数的名字也没有什么内在含义。我们通常将类型参 数命名为 T，但实际上我们可以使用任何名字：

template <typename Foo> Foo calc(const Foo& a, const Foo& b)

{

Foo tmp = a; // tmp的类型与参数和返回类型一样

return tmp; //返回类型和参数类型一样

}

模板参数与作用域

模板参数遵循普通的作用域规则。一个模板参数名的可用范围是在其声明之后，至模 □6L>板声明或定义结束之前。与任何其他名字一样，模板参数会隐藏外层作用域中声明的相同

名字。但是，与大多数其他上下文不同，在模板内不能重用模板参数名： typedef double A;

template <typename A, typename B> void f(A a, B b)

{

A tmp = a; // tmp的类型为模板参数 A 的类型，而非 double double B; //错误：重声明模板参数 B

}

正常的名字隐藏规则决定了 A的 typedef 被类型参数 A 隐藏。因此，tmp不是一个 double，其类型是使用 f 时绑定到类型参数 A 的类型。由于我们不能重用模板参数名， 声明名字为 B 的变量是错误的。

由于参数名不能重用，所以一个模板参数名在一个特定模板参数列表中只能出现一次：

//错误：非法重用模板参数名 V

template <typename V, typename V> //...

模板声明

模板声明必须包含模板参数:

//声明但不定义 compare 和 Blob

template <typename T> int compare(const T&, const T&); template <typename T> class Blob;

与函数参数相同，声明中的模板参数的名字不必与定义中相同：

// 3个 calc 都指向相同的函数模板

template ctypename T> T calc (const T&, const T&) ; // 声明 template <typename U> U calc (const U&, const U&) ; // 声明 //模板的定义

template ctypename Type>

Type calc (const Types a, const Type& b) {/*...*/}

当然，一个给定模板的每个声明和定义必须有相同数量和种类(即，类型或非类型)的参数。

Best    一个特定文件所需要的所有模板的声明通常一起放置在文件开始位置，出现于

任何使用这些模板的代码之前，原因我们将在 16.3节(第 617 页)中解释;，

使用类的类型成员

回忆一下，我们用作用域运算符(：：)来访问 static 成员和类型成员(参见 7.4节， 第 253 页和 7.6节，第 269 页)。在普通(非模板)代码中，编译器掌握类的定义。因此， 它知道通过作用域运算符访问的名字是类型还是 static 成员。例如，如果我们写下 string: : size_type，编译器有 string 的定义，从而知道 size_type是一个类型。

<670~1



但对于模板代码就存在困难。例如，假定 T 是一个模板类型参数，当编译器遇到类似 T: :mem这样的代码时，它不会知道 mem 是一个类型成员还是一个 static 数据成员，直 至实例化时才会知道。但是，为了处理模板，编译器必须知道名字是否表示一个类型。例 如，假定 T 是一个类型参数的名字，当编译器遇到如下形式的语句时：

T::size_type * p;

它需要知道我们是正在定义一个名为 p 的变量还是将一个名为 size_type的 static 数 据成员与名为 P 的变量相乘。

默认情况下，C++语言假定通过作用域运算符访问的名字不是类型。因此，如果我们 希望使用一个模板类型参数的类型成员，就必须显式告诉编译器该名字是一个类型。我们 通过使用关键字 type name来实现这一点：

template <typename T>

typename T::value_type top(const T& c)

{

if (!c.empty())

return c.back();

else

return typename T::value_type();

}

我们的 top 函数期待一个容器类型的实参，它使用 typename 指明其返回类型并在 c 中 没有元素时生成一个值初始化的元素(参见 7.5.3节，第 262 页)返回给调用者。

当我们希望通知编译器一个名字表示类型时，必须使用关键字 typename，而 L    不能使用 class。.、：

默认模板实参

就像我们能为函数参数提供默认实参一样(参见 6.5.1节，第 211 页)，我们也可以提 供默认模板实参(default template argument)。在新杯准中，我们可以为函数和类模板提供 默认实参。而更早的 C 杆标准只允许为类模板提供默认实参。

例如，我们重写 compare，默认使用标准库的 less 函数对象模板(参见 14+8.2节， 第 509 页):

II compare有一个默认模板实参 less<T>和一个。默认函数实参 F()

template <typename T, typename F = less<T»

int compare(const T &vl, const T &v2, F f = F())

{

if (f(vl, v2)) return -1; if (f(v2, vl)) return 1; return 0;

}

在这段代码中，我们为模板添加了第二个类型参数，名为 F，表示可调用对象(参见 10.3.2 节，第 346 页)的类型；并定义了一个新的函数参数 f，绑定到一个可调用对象上。

我们为此模板参数提供了默认实参，并为其对应的函数参数也提供了默汄实参。默汄 模板实参指出 compare 将使用标准库的 less 函数对象类，它是使用与 compare f'C 的类型参数实例化的。默认函数实参指出 f 将是类型 F 的一个默认初始化的对象。

当用户调用这个版本的 compare 时，可以提供自己的比较操作，但这并不是必耑的：

bool i = compare (0, 42) ; // 使用 less; i 为-1

II结果依赖于 iteml 和 item2 中的 isbn

Sales_data iteml(cin), item2(cin);

bool j = compare(iteml, item2, compareIsbn);

第一个调用使用默认函数实参，即，类型 less<T>的一个默认初始化对象。在此调用中， T为 int，因此可调用对象的类型为 less<int>„ compare的这个实例化版本将使用 1633<；1111；>进行比较操作。

在第二个调用中，我们传递给 compare 三个实参：comparelsbn (参见 11.2.2节， 第 379 页)和两个 SaleS_data类型的对象。当传递给 compare 三个实参时，第三个实 参的类型必须是一个可调 i 对象，该可调用对象的返回类型必须能转换为 bOOi 值，且接 受的实参类型必须与 compare 的前两个实参的类型兼容，与往常一样，模板参数的类型 从它们对应的函数实参推断而来。在此调用中，T的类型被推断为 Sales_data, F被推 断为 comparelsbn 的类型。

与函数默认实参一样，对于一个模板参数，只有当它右侧的所有参数都有默认实参时, 它才可以有默认实参。

模板默认实参与类模板

无论何时使用一个类模板，我们都必须在模板名之后接上尖括号。尖括号指出类必须 从一个模板实例化而来。特别是，如果一个类模板为其所有模板参数都提供了默认实参， 上 L 我们希望使用这些默认实参，就必须在模板名之后跟一个空尖括号对：

template Cclass T = int> class Numbers { // T 默认为 int public:

Numbers(T v = 0): val(v) { }

//对数值的各种操作 private:

T val;

}；

Numbers<long double> lots_of_precision;

Numberso average_precision; //空<>表示我们希望使用默认类型

此例中我们实例化了两个 Numbers 版本：average_precision是用 int 代替 T 实例 化得到的：lots_of_precision是用 long double代替 T 实例化而得到的。

###### 16.1.3节练习

<672]



练习 16.17:声明为 typename 的类型参数和声明为 class 的类型参数有什么不同(如 果有的话)？什么时候必须使用 typename?

练习 16.18：解释下面每个函数模板声明并指出它们是否非法。更正你发现的每个错误。

(a)    template <typename T, U, typename V〉void f1 (T, U, V);

(b)    template〈typename T> T f2 (int &T);

(c)    inline template <typename T> T foo (T, unsigned int*);

(d)    template <typename T> f4 (T, T);

(e)    typedef char Ctype;

template <typename Ctype> Ctype f5(Ctype a);

练习 16.19:编写函数，接受一个容器的引用，打印容器中的元素。使用容器的 size_type 和 size 成员来控制打印元素的循环。

练习 16.20:重写上一题的函数，使用 begin 和 end 返回的迭代器來控制循环。

###### 16.1.4成员模板

一个类(无论是普通类还是类模板)可以包含本身是模板的成员函数。这种成员被称 为成员模板(membertemplate)。成员模板不能是虚函数。

普通(非模板)类的成员模板

作为普通类包含成员模板的例子，我们定义一个类，类似 unique_ptr所使用的默 认删除器类型(参见 12 丄 5 节，第 418 页)。类似默认删除器，我们的異将包含一个重载 的函数调用运算符(参见 14.8节，第 506 页)，它接受一个指针并对此指针执行 delete， 与默认删除器不同，我们的类还将在删除器被执行时打印一条信息。由于希望刪除器适用 丁-任何类型，所以我们将调用运算符定义为一个模板：

//函数对象类，对给定指针执行 delete class DebugDelete { public:

DebugDelete(std::ostream &s = std::cerr) : os (s)    { }

//与任何函数模板相同，T的类型由编译器推断

template <typename T> void operator()(T *p) const

{ os << "deleting unique_ptr" « std::endl; delete p; } private:

std::ostream &os;

}；

\^>与任何其他模板相同，成员模板也是以模板参数列表开始的。每个 DebugDelete 对象都 有一个 ostream 成员，用于写入数据：还包含一个自身是模板的成员函数。我们可以用 这个类代替 delete：

double* p = new double;

DebugDelete d; //可像 delete 表达式一样使用的对象 d (p) ; // 调用 DebugDelete: : operator () (double*)，释放 p int* ip = new int;

// 在一个临时 DebugDelete 对象上调用 operator () (int*)

DebugDelete()(ip);

由于调用一个 DebugDelete 对象会 delete 其给定的指针，我们也可以将 DebugDelete用作 unique_ptr的删除器。为了重载 unique_ptr的删除器，我们在 尖括号内给出删除器类型，并_提供一个这种类型的对象给 unique_ptr的构造函数(参 见 12.1.5节，第 418 页)：

/ /销毁 p 指向的对象

// 实例化 DebugDelete : : operator (} <int〉(int *) unique_ptr<int, DebugDelete> p (new int, DebugDelete());

//销毁~sp指向的对象

// 实例化 DebugDelete: : operator () <string> (string*) unique_ptr<string, DebugDelete> sp(new string, DebugDelete());

在本例中，我们声明 p 的删除器的类型为 DebugDelete，并在 p 的构造函数中提供了该 类型的一个未命名对象。

unique_ptr的析构函数会调用 DebugDelete 的调用运算符。因此，无论何吋 unique_ptr的析构函数实例化时，DebugDelete的调用运算符都会实例化：因此，上 述定义会这样实例化.

// DebugDelete的成 S 模板实例化样例

void DebugDelete::operator() (int *p) const { delete p; } void DebugDelete::operator() (string *p) const { delete p; }

类模板的成员模板

对于类模板，我们也可以为其定义成员模板。在此情况下，类和成员各自有自己的、 独立的模板参数。

例如，我们将为 Blob 类定义一个构造函数，它接受两个迭代器，表示要拷贝的元素 范围。由于我们希望支持不同类型序列的迭代器，因此将构造函数定义为模板：

template <typename T> class Blob {

template <typename It〉 Blob(It b, It e);

}；

此构造函数有自己的模板类型参数 It，作为它的两个函数参数的类型。

与类模板的普通函数成员不同，成员模板是函数模板。当我们在类模板外定义一个成 C6Z4>员模板时，必须同时为类模板和成员模板提供模板参数列表。类模板的参数列表在前，后

跟成员自己的模板参数列表：

template <typename T> // 类的类型参数 template < type name It> //构造函数的类型参数

Blob<T〉：：Blob(Itb, It e):

data(std::make_shared<std::vector<T>>(b, e))    { }

在此例中，我们定义了一个类模板的成员，类模板有一个模板类型参数，命名为 T。而成 员自身是一个函数模板，它有一个名为工 t 的类型参数。

实例化与成员模板

为了实例化一个类模板的成员模板，我们必须同时提供类和函数模板的实参。与往常 一样，我们在哪个对象上调用成员模板，编译器就根据该对象的类型来推断类模板参数的 实参。与普通函数模板相同，编译器通常根据传递给成员模板的函数实参来推断它的模板 实参(参见 16.1.1节，第 579 页)：

int ia[] = {0,1,2,3,4,5,6,7,8,9}; vector<long> vi = {0,1,2,3,4,5,6,7,8,9}; list<const char*> w = {"nown, nis", "the", "time"};

//实例化 Blob<int>类及其接受两个 int*参数的构造函数 Blob<int> al(begin(ia), end(ia));

//实例化 Blob<int>类的接受两个 vector<long>: : iterator的构造画数

Blob<int> a2(vi.begin (), vi.end());

//实例化 Blob<string〉及其接受两个 list<const char*〉：： iterator参数的构造函数

Blob<string> a3(w.begin(), w.end());

当我们定义 al 时，显式地指出编译器应该实例化一个 int 版本的 Blobo 构造函数自己 的类型参数则通过 begin (ia)和 end (ia)的类型来推断，结果为 int*。因此，al的定 义实例化了如下版本：

Blob<int>::Blob(int*, int*);

a2的定义使用了已经实例化了的 Blob<int〉类，并用 vector<short>: : iterator 替换 It 来实例化构造函数。a3的定义(显式地)实例化了一个 string 版本的 Blob, 并(隐式地)实例化了该类的成员模板构造函数，其模板参数被绑定到 list<COnSt char*>。

###### 16.1.4节练习

![img](C++  Primer 5-154.jpg)



练习 16.21:编写你自己的 DebugDelete 版本。

练习 16.22：修改 12.3节(第 430 贾)中你的 TextQuery 程序，令 shared_ptr成 员使用 DebugDelete 作为它们的删除器(参见 12.1.4节，第 415 页)。

练习 16.23：预测在你的查询主程序中何时会执行调用运算符。如果你的预测和实际不 符，确认你理解了原因。

练习 16.24:为你的 Blob 模板添加一个构造函数，它接受两个迭代器。

###### 16.1.5控制实例化

当模板被使用时才会进行实例化(参见 16.1.1节，第 582 页)这一特性意味着，相同 的实例可能出现在多个对象文件中。当两个或多个独立编译的源文件使用了相同的模板，Lli-并提供了相同的模板参数时，每个文件中就都会有该模板的一个实例。

在大系统中，在多个文件中实例化相同模板的额外开销可能非常严重。在新标准中，

我们可以通过显式实例化(explicitinstantiation)来避免这种开销。一个显式实例化有如下

形式:

extern template declaration;    // 实例化声明

template declaration;    // 实例化定义

如 n 是一个类或函数声明，其中所有模板参数已被替换为模板实参。例如，

//实例化声明与定义

extern template class Blob<string>;    // 声明

template int compare (const int&, const int&) ; // 定义

当编译器遇到 extern 模板声明时，它不会在本文件中生成实例化代码。将一个实例化声 明为 extern 就表示承诺在程序其他位置有该实例化的一个非 extern 声明(定义)。对 于一个给定的实例化版本，可能有多个 extern 声明，但必须只有一个定义。

由于编译器在使用一个模板时自动对其实例化，因此 extern 声明必须出现在任何使 用此实例化版本的代码之前：

// Application.cc

//这些模板类型必须在程序其他位置进行实例化 extern template class Blob<string>;

extern template int compare(const int&, const int&);

Blob<string> sal, sa2; //实例化会出现在其他位置 // Blob<int>及其接受 initializer_list的构造函数在本文件中实例化 Blob<int> al = {0,1,2,3,4,5,6,7,8,9};

Blob<int> a2(al); //拷贝构造函数在本文件中实例化

int i = compare (al [0] , a2 [0] ) ; //实例化出现在其他位置

| 676〉文件 Application. o将钮含 Blob<int〉的实例及其接受 initializer_list参数的 构造函数和拷贝构造函数的实例。而 compare<int〉函数和 Blob<string>类将不在本 文件屮进行实例化。这些模板的定义必须出现在程序的其他文件中：

// templateBuild.cc

//实例化文件必须为每个在其他文件中声明为 extern 的类型和函数提供一个(非 extern ) //的定义

template int compare(const int&, const int&);

template class Blob<string>; //实例化类模板的所有成员

当编译器遇到一个实例化定义(与声明相对)时，它为其生成代码。因此，文件 templateBuild.o将会包含 compare 的 int 实例化版本的定义和 Blob<string>类 的定义。当我们编译此应用程序时，必须将 templateBuild.o和 Application.。链 接到一起。

WARNING



对每个实例化声明，在程序中某个位置必须有其显式的实例化定义。.

实例化定义会实例化所有成员

-个类模板的实例化定义会实例化该模板的所有成员，包括内联的成员函数。当编译 器遇到一个实例化定义时，它不了解程序使用哪些成员函数。因此，与处理类模板的普通 实例化不同，编译器会实例化该类的所有成员。即使我们不使用某个成员，它也会被实例 化。因此，我们用来显式实例化一个类模板的类型，必须能用于模板的所有成员。

![img](C++  Primer 5-156.jpg)



在一个类模板的实例化定义中，所用类型必须能用于模板的所有成员函数。

###### 16.1.5节练习    -

练习 16.25：解释下面这些声明的含义：

extern template class vector<string>; template class vector<Sales_data>;

练习 16.26：假设 NoDefault 是一个没有默认构造函数的类，我们可以显式实例化 vector<NoDefault>吗？如果不可以，解释为什么。

练习 16.27:对下面每条带标签的语句，解释发生了什么样的实例化（如果有的话 X 如 果：个模板被实例化，解释为什么；如果未实例化，解释为什么没有。

template <typename T> class Stack { };

| void             | .f1(Stack<char>);                   | // (a) |
| ---------------- | ----------------------------------- | ------ |
| class Exercise { |                                     |        |
|                  | Stack<double> &rsd;                 | //(b)  |
|                  | Stack<int> si;                      | "⑷     |
| ｝；             |                                     |        |
| int              | main ()    {                        |        |
|                  | Stack<char> ★sc;                    | // (d) |
|                  | fl (*sc);                           | // (e) |
| }                | int iObj = sizeof(Stack< string >); | // (0  |

16.1.6效率与灵活性

对模板设计者所面对的设计选择，标准库智能指针类型（参见 12.1节，第 400 页）给 出了一个很好的展示。

shared_ptr和 unique_ptr之间的明显不同是它们管理所保存的指针的策略-

前者给予我们共享指针所有权能力；后者则独占指针。这一差异对两个类的功能来说是 至关重要的。

这两个类的另-•个差异是它们允许用户重载默认删除器的方式。我们可以很容易地重 载一个 shared_ptr的删除器，只要在创建或 reset 指针时传递给它一个可调用对象即 可。与之相反，删除器的类型是一个 unique_ptr对象的类型的一部分。用户必须在定 义 uniquejtr 时以显式模板实参的形式提&删除器的类型。因此，对于

unique_ptr

的用户来说，提供自己的删除器就更为复杂。

如何处理删除器的差异实际上就是这两个类功能的差异。但是，如我们将要看到的，<67L] 这一实现策略上的差异可能对性能有重要影响。

在运行时绑定删除器

虽然我们不知道标准库类型是如何实现的，但可以推断出，shared ptr必须能直接 访问其删除器。即，删除器必须保存为一个指针或一个封装了指针的类_（如 function,

参见 14.8.3节，第 512 页）。

我们可以确定 shared_ptr不是将删除器直接保存为一个成员，因为删除器的类型

直到运行时才会知道。实际上，在一个 shared_ptr的生存期中，我们可以随时改变其 删除器的类型。我们可以使用一种类型的删除器构造一"shared_ptr，随后使用 reset 赋予此 shared_ptr另一种类型的删除器。通常，类成员的类型去运行时是不能改变的。 因此，不能直接^存删除器。

为了考察删除器是如何正确工作的，让我们假定 shared_ptr将它管理的指针保存 在一个成员 p 中，且删除器是通过一个名为 del 的成员来访问的。则 shared_ptr的析 构函数必须包含类似下面这样的语句：

// del的值只有在运行时才知道；通过一个指针来调用它

del ? del(p) : delete p; // del (p)需要运行时跳转到 del 的地址

rCT＞由于删除器是间接保存的，调用 del (P＞需要一次运行时的跳转操作，转到 del 中保存的 地址来执行对应的代码。

在编译时绑定删除器

现在，让我们来考察 unique_ptr可能的工作方式。在这个类中，删除器的类型是 类类型的一部分，即，unique_ptr有两个模板参数，一个表示它所管理的指针，另一个 表示删除器的类型。由于删除器的类型是 unique_Ptr类型的一部分，因此删除器成员 的类型在编译时是知道的，从而删除器可以直接保&在 unique_ptr对象中。

unique_ptr的析构函数与 shared_ptr的析构函数类似，也是对其保存的指针调 用用户提供&删除器或执行 delete:

// del在编译时紼定；直接调用实例化的删除器 del (p) ; //无运行时额外开销

del的类型或者是默认删除器类型，或者是用户提供的类型。到底是哪种情况没有关系， 应该执行的代码在编译时肯定会知道。实际上，如果删除器是类似 DebugDelete (参见 16.1.4节，第 595 页)之类的东西，这个调用甚至可能被编译为内联形式。

通过在编译时绑定删除器，uniqUe_Ptr避免了间接调用删除器的运行时开销。通过 在运行时绑定删除器，shared_ptr使运户重载删除器更为方便。

###### 16.1.6节练习

练习 16.28：编写你自己版本的 shared_ptr和 unique_ptr。

练习 16.29:修改你的 Blob 类，用你自己的 shared_ptr代替标准库中的版本。

练习 16.30:重新运行你的一些程序，验证你的 shared_Ptr类和修改后的 Blob 类。 (注意：实现 weak_ptr类型超出了本书范围，因此你不能将 BlobPtr 类与你修改后 的 Blob 一起使用《 )

练习 16.31:如果我们将 DebugDelete 与 unique_ptr 一起使用，解释编译器将删 除器处理为内联形式的可能方式。

##### 16.2模板实参推断

我们已经看到，对于函数模板，编译器利用调用中的函数实参来确定其模板参数。从 函数实参来确定模板实参的过程被称为模板实参推断(template argument deduction)。在模

板实参推断过程中，编译器使用函数调用中的实参类型来寻找模板实参，用这些模板实参 生成的函数版本与给定的函数调用最为匹配。

###### 16.2.1类型转换与模板类型参数

<6791



与非模板函数一样，我们在一次调用中传递给函数模板的实参被用来初始化函数的形 参。如果一个函数形参的类型使用了模板类型参数，那么它采用特殊的初始化规则。只有 很有限的几种类型转换会自动地应用于这些实参。编译器通常不是对实参进行类型转换， 而是生成一个新的模板实例。

与往常一样，顶层 const (参见 2.4.3节，第 57 页)无论是在形参中还是在实参中， 都会被忽略。在其他类型转换中，能在调用中应用于函数模板的包括如下两项。

• const转换：可以将一个非 const 对象的引用(或指针)传递给一个 const 的 引用(或指针)形参(参见 4.11.2节，第 144 页)。

•数组或函数指针转换：如果函数形参不是引用类型，则可以对数组或函数类型的实 参应用正常的指针转换。一个数组实参可以转换为一个指向其首元素的指针。类似 的，一个函数实参可以转换为一个该函数类型的指针(参见 4.11.2节，第 143 页)。

其他类型转换，如算术转换(参见 4.11.1节，第 142 页)、派生类向基类的转换(参见 15.2.2 节，第 530 页)以及用户定义的转换(参见 7.5.4节，第 263 页和 14.9节，第 514 页)，都 不能应用于函数模板。

作为一个例子，考虑对函数 fobj 和 fref 的调用。fobj函数拷贝它的参数，而 fref 的参数是引用类型：

template <typename T> T fobj (T, T) ; // 实参被拷贝 template <typename T> T fref (const T&, const T &) ; // 引用 string si ("a value");

const string s2 (’’another value”)；

fobj (si, s2) ;    // 调用 fobj (string, string) ; const 被忽略

fref (si, s2) ;    // 调用 fref (const strings, const strings)

//将 si 转换为 const 是允许的

int a[10], b[42];

fobj (a, b) ;    // 调用 f (int*, int*)

fref (a, b) ;    //错误：数组类型不匹配

在第一对调用中，我们传递了一个 string 和一个 const string。虽然这些类型不严格 匹配，但两个调用都是合法的。在 fobj 调用中，实参被拷贝，因此原对象是否是 const 没有关系。在 fref 调用中，参数类型是 const 的引用。对于一个引用参数来说，转换 为 const 是允许的，因此这个调用也是合法的。

在下一对调用中，我们传递了数组实参，两个数组大小不同，因此是不同类型。在 fobj调用中，数组大小不同无关紧要。两个数组都被转换为指针。fobj中的模板类型 为 int*。但是，fref调用是不合法的。如果形参是一个引用，则数组不会转换为指针 (参见 6.2.4节，第 195 页)。a和 b 的类型是不匹配的，因此调用是错误的。

![img](C++  Primer 5-157.jpg)



将实参传递给带模板类型的函数形参时，能够自动应用的类型转换只有 const 转换及数组或函数到指针的转换。

<680 |



使用相同模板参数类型的函数形参

一个模板类型参数可以用作多个函数形参的类型。由于只允许有限的几种类型转换， 因此传递给这些形参的实参必须具有扣 M 的类型。如果推断出的类型不匹配，则调用就是 错误的。例如，我们的 compare 趙数(参见 16.1.1节，第 578 页)接受两个 const T& 参数，其实参必须是相同类型：

long lng;

compare (lng, 1024) ; // 错误：不能实例化 compare (long, int)

此凋用是错误的，因为传递给 compare 的实参类型不同。从第一个函数实参推断出的模 板实参为 long，从第二个函数实参推断出的模板实参为 int。这些类型不匹配，因此模 板实参推断失败。

如果希望允许对函数实参进行正常的类型转换，我们可以将函数模板定义为两个类型 参数：

//实参类型可以不同，但必须兼容

template <typename A, typename B>

int flexibleCompare(const A& vl, const B& v2)

{

if (vl < v2) return -1; if (v2 < vl) return 1; return 0;

}

现在用户可以提供不同类型的实参了： long lng;

f lexibleCompare (lng, 1024) ; // 正确：调用 flexibleCompare (long, int)

当然，必须定义了能比较这些类型的值的<运算符。

正常类型转换应用于普通函数实参

函数模板可以有用普通类型定义的参数，即，不涉及模板类型参数的类型。这种函数 实参不进行特殊处理；它们正常转换为对应形参的类型(参见 6.］节，第 183 页)。例如， 考虑下面的模板：

template <typename T> ostream Sprint(ostream &os, const T &obj)

{

return os « obj;

}

第一个函数参数是一个已知类型 ostreamS。第二个参数 obj 则是模板参数类型。由于 os的类型是固定的，因此当调用 print 时，传递给它的实参会进行正常的类型转换：

I 681〉    print (cout, 42); // 实例化 print (ostream&, int)

ofstream f ("output");

print (f, 10);    // 使用 print <ostream&, int)；将 f 转换为 ostream&

在第一个调用中，第一个实参的类型严格匹配第一个参数的类型。此凋用会实例化接受一 个 ostream&和一个 int 的 print 版本。在第二个凋用中，第一个实参是一个 of stream, 它可以转换为 ostream& (参见 8.2.1节，第 284 页)。由于此参数的类型不依赖于模板参 数，因此编译器会将 f 隐式转换为 ostream&。

![img](C++  Primer 5-158.jpg)



如果函数参数类型不是模板参数，则对实参进行正常的类型转换._

###### 16.2.1节练习

练习 16.32：在模板实参推断过程中发生了什么？

练习 16.33：指出在模板实参推断过程中允许对函数实参进行的两种类型转换。

练习 16.34：对下面的代码解释每个调用是否合法。如果合法，T的类型是什么？如果 不合法，为什么？

template <class T> int compare(const T&, const T&);

(a) compare("hi", "world"); (b) compare("bye", "dad");

练习 16.35：下面调用中哪些是错误的(如果有的话)？如果调用合法，T的类型是什 么？如果调用不合法，问题何在？

template <typename T> T calc(T, int); template <typename T> T fcn(T, T); double d; float f; char c;

(a) calc (c, ’ c' ) ;    (b) calc (d, f);

(c)    fen (c, 'c');    (d) fcn(d, f);

练习 16.36：进行下面的调用会发生什么：

template <typename T> f1(T, T);

template <typename Tl, typename T2) f2 (T1, T2); int i = 0, j = 42, *pl = &i, *p2 = &j; const int *cpl = &i, *cp2 = &j;

⑻ fl (pi, p2) ;    (b) f2 (pi, p2) ;    (c) fl(cpl, cp2);

(d)    f2(cpl, cp2) ;    (e) fl(pl' cpl) ; (e) f2 (pi, cpl);

16.2.2函数模板显式实参    6

在某些情况下，编译器无法推断出模板实参的类型。其他-些情况下，我们希望允许 用户控制模板实例化。当函数返回类型与参数列表中任何类型都不相同时，这两种情况最<682~| 常出现。

指定显式模板实参

作为一个允许用户指定使用类型的例子，我们将定义一个名为 sum 的函数模板，它 接受两个不同类型的参数。我们希望允许用户指定结果的类型。这样，用户就可以选择合 适的精度。

我们可以定义表示返回类型的第三个模板参数，从 Iflj 允许用户控制返回类型：

II编译器无法推断 T1，它未出现在函数参數列表中 template <typename Tl, typename T2, typename T3>

T1 sum(T2, T3);

在本例中，没有任何函数实参的类型可用米推断 Tl 的类型。毎次调用 sum 吋调用者都必 须为 T1 提供一■个显式模板实参(explicit template argument )。

我们提供显式模板实参的方式与定义类模板实例的方式相同。敁式模板实参在尖括号 中给出，位于函数名之后，实参列表之前：

// T1是显式指定的，T2和 T3 是从函数实参类型推断而来的

auto val3 = sum<long long>（i, lng）; // long long sum（int, long）

此调用显式指定 T1 的类型。而 T2 和 T3 的类型则由编译器从 i 和 lng 的类型推断出来。

显式模板实参按由左至右的顺序与对应的模板参数匹配；第一个模板实参与第一个模 板参数匹配，第二个实参与第二个参数匹配，依此类推。只有尾部（最右）参数的显式模 板实参才可以忽略，而且前提是它们可以从函数参数推断出來。如果我们的 sum 函数按 照如下形式编写：

//糟糕的设计：用户必须指定所有三个模板参数

template <typename Tl, typename T2, typename T3>

T3 alternative_sum（T2, Tl）;

则我们总是必须为所有三个形参指定实参，

//错误：不能推断前几个模板参数

auto val3 = alternative_sum<long long〉（i, lng）;

//正确：显式指定了所有三个奏数

auto val2 = alternative_sum<long long, int, long〉（i, lng）;

正常类型转换应用于显式指定的实参

对于用普通类型定义的函数参数，允许进行正常的类型转换（参见 16.2.1节，第 602 页），出于同样的原因，对于模板类型参数已经显式指定了的函数实参，也进行正常的类型 转换:

I 683〉    long lng;

compare(lng, 1024〉； compare<long>(lng, 1024); compare<int>(lng, 1024);



//错误：模板参数不匹配

// 正确：实例化 compare （long, long） // 正确：实例化 compare （int, int）

如我们所见，第一个调用是错误的，因为传递给 compare 的实参必须具有相同的类 型。如果我们显式指定模板类型参数，就可以进行正常类型转换了。因此，调用 compare<long〉等价于调用一个接受两个 const long&参数的函数。int类型的参数 被自动转化为 long。在第三个调用中，T被显式指定为 int，因此 lng 被转换为 int。

###### 16.2.2节练习

练习 16.37:标准库 max 函数有两个参数，它返回实参中的较大者。此函数有一个模板 类型参数。你能在调用 max 时传递给它一个 int 和一个 double 吗？如果可以，如何 做？如果不可以，为什么？

练习 16.38：当我们调用 make^hare （参见 12.1.1节，第 401 页）时，必须提供一个 显式模板实参，解释为什么需 i 显式模板实参以及它是如何使用的。

练习 16.39:对 16.1.1节（第 578 页）中的原始版本的 compare 函数，使用一个显式 模板实参，使得可以向函数传递两个字符串字面常量。

###### 16.2.3尾置返回类型与类型转换

当我们希望用户确定返回类型时，用显式模板实参表示模板函数的返回类型是很有效 的。但在其他情况下，要求显式指定模板实参会给用户增添额外负担，而且不会带来什么 好处。例如，我们可能希望编写一个函数，接受表示序列的一对迭代器和返回序列中一个

元素的引用:

template <typename It〉

??? &fcn(It beg, It end)

{

//处理序列

return *beg; //返回序列中一个元素的引用

}

我们并不知道返回结果的准确类型，但知道所需类型是所处理的序列的元素类型:

vector<int> vi = {1,2,3,4 Blob<string> ca = { "hi", auto &i = fen(vi.begin(), auto &s = fen(ca.begin(),



5};

"bye" };

vi . end () ) ; // fen 应该返回 int& ca.end () ) ; // fen 应该返回 strings

此例中，我们知道函数应该返而且知道我们可以用 decltype （*beg）来获取此< 684 | 表达式的类型。但是，在编译器遇到函数的参数列表之前，beg都是不存在的。为了定义 此函数，我们必须使用尾置返回类型（参见 6.3.3节，第 206 页）。由于尾置返回出现在参 UlJ 数列表之后，它可以使用函数的参数，

//尾置返回允许我们在参数列表之后声明返回类型 template <typename It〉

auto fen （It beg, It end） -> decltype（*beg）

{

//处理序列

return *beg; //返回序列中一个元素的引用

此例中我们通知编译器 fen 的返回类型与解引用 beg 参数的结果类型相同。解引用运算 符返回一个左值（参见 4.1.1节，第 121 页），因此通过 decltype 推断的类型为 beg 表 示的元素的类型的引用。因此，如果对一个 string 序列调用 fen，返回类型将是 strings。如果是 int 序列，则返回类型是 int&。

进行类型转换的标准库模板类

有时我们无法直接获得所需要的类型。例如，我们可能希望编写一个类似 fen 的函 数，但返回一个元素的值（参见 6.3.2节，第 201 页）而非引用。

在编写这个函数的过程中，我们面临一个问题：对于传递的参数的类型，我们几乎一 无所知。在此函数中，我们知道唯一可以使用的操作是迭代器操作，而所有迭代器操作都 不会生成元素，只能生成元素的引用。

为了获得元素类型，我们可以使用标准库的类型转换（type transformation）模板。这 些模板定义在头文件 type_traitS中。这个头文件中的类通常用于所谓的模板元程序设 计，这一主题已超出本书 6^范围。但是，类型转换模板在普通编程中也很有用。表 16.1 列出了这些模板，我们将在 16.5节（第 624 页）中看到它们是如何实现的。

在本例中，我们可以使用 remove_reference来获得元素类型 Oremove_reference 模板有一个模板类型参数和一个名为 type 的（public）类型成员。如果 ii 们用一个引 用类型实例化 remove_reference，则 type 将表示被引用的类型。例如，如果我们实 例化 remove_reference<int&>，则 type 成员将是 into 类似的，如果我们实例化 remove_reference<string&>，则 type 成员将是 string，依此类推。更一般的， 给定一个迭代器 beg：

remove_reference<decltype （*beg） >: : type

将获得 beg 引用的元素的类型：decltypeCbeg）返回元素类型的引用类型。 remove_ref erence: : type脱去引用，剩下兀素类型本身。

组合使用 remove_reference>尾置返冋及 decltype，我们就可以在函数中返回 元素值的拷贝：

I卿〉    //为了使用模板参数的成员，必须用 typename，参见 16.1.3节（第 593 I ）

template <typename It〉 auto fcn2（It beg, It end）->

typename remove_reference<decltype（*beg）>::type

{

//处理序列

return *beg; //返回序列中一个元素的拷贝

}

注意，type是一个类的成员，而该类依赖于一个模板参数。因此，我们必须在返回类型 的声明中使用 typename 来告知编译器，type表示一个类型（参见 16.1.3节，第 593 页）

| 表 16.1:标准类型转换模板 |                   |                    |
| ----------------------- | ----------------- | ------------------ |
| 对 Mod<T>，其中 Mod 为      | 若 T 为             | 则 Mod<T>::type 为 |
| remove reference        | X&或 X&&          | X                  |
|                         | 否则              | T                  |
| add const               | X&、const X或函数 | T                  |
|                         | 否则              | const T            |
| add lvalue reference    | X&                | T                  |
|                         | X&&               | X&                 |
|                         | 否则              | T&                 |
| add_rvalue_reference    | X&或 X&&          | T                  |
|                         | 否则              | T&&                |
| remove_pointer          | X*                | X                  |
|                         | 否则              | T                  |
| add_pointer             | X&或 X&&          | X*                 |
|                         | 否则              | T*                 |
| make_signed             | unsigned X        | X                  |
|                         | 否则              | T                  |
| make_unsigned           | 带符号类型        | unsigned X         |
|                         | 否则              | T                  |
| remove extent           | X[n]              | X                  |
|                         | 否则              | T                  |
| remove all extents      | X[nl] [n2].“      | X                  |
|                         | 否则              | T                  |

表 16.1中描述的每个类型转换模板的工作方式都与 remove_reference类似。每 个模板都有一个名为 type 的 public 成员，表示一个类型。此型与模板自身的模板类 型参数相关，其关系如模板名所示。如果不可能（或者不必要）转换模板参数，则 type 成员就是模板参数类型本身。例如，如果 T 是一个指针类型，则 remove pointer<T>: : type是 T 指向的类型。如果 T 不是一个指针，则无须进行任何

转换，从而 type 具有与 T 相同的类型。

###### 16.2.3节练习

练习 16.40：下面的函数是否合法？如果不合法，为什么？如果合法，对可以传递的实 参类型有什么限制(如果有的话)？返回类型是什么？ template <typename It〉

auto fcn3(It beg, It end) -> decltype(*beg + 0)

{

//处理序列

return *beg; //返回序列中一个元素的拷贝

}

练习 16.41:编写一个新的 sum 版本，它的返回类型保证足够大，足以容纳加法结果。

###### 16.2.4函数指针和实参推断

当我们用一个函数模板初始化一个函数指针或为一个函数指针赋值(参见 6.7节，第 221页)时，编译器使用指针的类型来推断模板实参。

例如，假定我们有一个函数指针，它指向的函数返回 int，接受两个参数，每个参数 都是指向 const int的引用。我们可以使用该指针指向 compare 的一个实例：

template <typename T> int compare(const T&, const T&);

// pfl 指向实例 int compare (const int&, const int&) int (*pf1)(const int&, const int&) = compare;

pfl中参数的类型决定了 T的模板实参的类型。在本例中，T的模板实参类型为 int。指 针 pfl 指向 compare 的 int 版本实例。如果不能从函数指针类型确定模板实参，则产 生错误：

// func的重载版本；每个版本接受一个不同的函数指针类型 void func(int(*)(const strings, const strings)); void func (int (*) (const int&, const int&)); func (compare) ; //错误：使用 compare 的哪个实例？

这段代码的问题在于，通过 func 的参数类型无法确定模板实参的唯一类型。对 func 的 调用既可以实例化接受 int 的 compare 版本，也可以实例化接受 string 的版本。由于 不能确定 func 的实参的唯一实例化版本，此调用将编译失败。

我们可以通过使用显式模板实参来消除 func 调用的歧义：

//正确：显式指出实例化哪个 compare 版本

func (compare<int>) ; // 传递 compare (const int&, const int&)

此表达式调用的 func 版本接受一个函数指针，该指针指向的函数接受两个 const int& 参数。

![img](C++  Primer 5-159.jpg)



当参数是一个函数模板实例的地址时，程序上下文必须满足：对每个模板参数, 能唯一确定其类型或值。

<687~|



###### 16.2.5模板实参推断和引用

为了理解如何从函数调用进行类型推断，考虑下面的例子:

template <typename T> void f(T &p);

其中函数参数 p 是一个模板类型参数 T 的引用，非常重要的是记住两点：编译器会应用正 常的引用绑定规则；const是底层的，不是顶层的，

从左值引用函数参数推断类型

当一个函数参数是模板类型参数的一个普通(左值)引用时(即，形如 T&)，绑定规 则告诉我们，只能传递给它一个左值(如，一个变量或一个返回引用类型的表达式)。实 参可以是 const 类型，也可以不是。如果实参是 const 的，则 T 将被推断为 const 类型：

template <typename T> void f 1 (T&) ; // 实参必须是一个左值

//对 fl 的调用使用实参所引用的类型作为模板参数类型 fl (i) ;    // i是一 tint；模板参数类型 T 是 int

f 1 (ci) ;    // ci 是一个 const int；模板参数 T 是 const int

fl(5) ;    //错误：传递给一个&参数的实参必须是一个左值

如果一个函数参数的类型是 const T&，正常的绑定规则告诉我们可以传递给它任何 类型的实参——一个对象(const或非 const)、一个临时对象或是一个字面常量值。当 函数参数本身是 const 时，T的类型推断的结果不会是一个 const 类型。const已经是 函数参数类型的一部分；因此，它不会也是模板参数类型的一部分：

template <typename T> void. f2 (const T&) ; // 可以接受一个右值

// f2中的参教是 const &；实参中的 const 是无关的

//在每个调用中，f2的函数参数都被推断为 const int& f2 (i) ;    // i是一个 int；模板参数 T 是 int

f2 (ci) ;    // ci 是一个 const int，但模板参数 T 是 int

f2 (5) ;    // 一个 const &参数可以绑定到一个右值；T是 int

从右值引用函数参数推断类型

当一个函数参数是一个右值引用(参见 13.6.1节，第 471 页)(即，形如 T&&)时， 正常绑定规则告诉我们可以传递给它一个右值。当我们这样做时，类型推断过程类似普通 左值引用函数参数的推断过程。推断出的 T 的类型是该右值实参的类型：

template <typename T> void f3 (T&&);

f3(42); //实参是一个 int 类型的右值；模板参数 T 是 int

s§>引用折叠和右值引用参数

假定 i 是一个 int 对象，我们可能认为像 f3(i)这样的调用是不合法的。毕竟，i 是一个左值，而通常我们不能将一个右值引用绑定到一个左值上。但是，C++语言在正常 绑定规则之外定义了两个例外规则，允许这种绑定。这两个例外规则是 move 这种标准库 设施正确工作的基础。

第一个例外规则影响右值引用参数的推断如何进行。当我们将一个左值(如 i)传递 给函数的右值引用参数，且此右值引用指向模板类型参数(如 T&&)时，编译器推断模板 类型参数为实参的左值引用类型。因此，当我们调用 f3(i)时，编译器推断 T 的类型为 int&，而非 int。

T被推断为看起来好像意味着 f 3的函数参数应该是一个类型 int&的右值引用

通常，我们不能（直接）定义一个引用的引用（参见 2.3.1节，第 46 页）。但是，通过类 型别名（参见 2.5.1节，第 60 页）或通过模板类型参数间接定义是可以的，

在这种情况下，我们可以使用第二个例外绑定规则：如果我们间接创建一个引用的引 用，则这些引用形成了 “折 fi”。在所有情况下（除了一个例外），引用会折叠成一个普通 fcTTl 的左值引用类型。在新标准中，折叠规则扩展到右值引用。只在一种特殊情况下引用会折 11 叠成右值引用：右值引用的右值引用。即，对于一个给定类型 X:

• X& &、X& &&和 X&& &都折叠成类型 X&

•类型 X & & &&折叠成 X& &

引用折叠只能应用于间接创建的引用的引用，如类型别名或模板参数

如果将引用折叠规则和右值引用的特殊类型推断规则组合在一起，则意味着我们可以 对一个左值调用 f3»当我们将一个左值传递给 f3 的（右值引用）函数参数时，编译器推 断 T 为一个左值引用类型：

f3（i） ;    //实参是一个左值；模板参数 T 是 int&

f3 （ci） ;    //实参是一个左值；模板参数 T 是一个 const int&

当一个模板参数 T 被推断为引用类型时，折叠规则告诉我们函数参数 T&&折叠为一个左值 引用类型。例如，f3（i）的实例化结果可能像下面这样：

//无效代码，只是用于演示目的

void f3<int&> （int& &&） ; // 当 T 是 int&时，函数参数为 int& &&

f3的函数参数是 T&&且 T 是 int&，因此 T&&是 int&会折叠成 int&。因此，即使 f3的函数参数形式是一个右值引用（即，T&&），此调用也会用一个左值引用类型（即， int& ）实例化 f3:

void f3<int&> （int&） ; // 当 T 是 int&时，函数参数折叠为 int&

这两个规则导致了两个重要结果：

•如果一个函数参数是一个指向模板类型参数的右值引用（如，T&&），则它可以被 绑定到一个左值；且

•如果实参是一个左值，则推断出的模板实参类型将是一个左值引用，且函数参数将 被实例化为一个（普通）左值引用参数（T&）

另外值得注意的是，这两个规则暗示，我们可以将任意类型的实参传递给 T&&类型的函数 参数。对于这种类型的参数，（显然〉可以传递给它右值，而如我们刚刚看到的，也可以 传递给它左值。

如果一个函数参数是指向模板参数类型的右值引用（如，T&& ），则可以传递 给它任意类型的实参。如果将一个左值传递给这样的参数，则函数参数被实例 化为一个普通的左值引用（T& ）。

编写接受右值引用参数的模板函数

模板参数可以推断为一个引用类型，这一特性对模板内的代码可能有令人惊讶的影响: template <typename T> void f3（T&& val）

T t = val; //拷贝还是绑定一个引用？

t = fcn(t); //赋值只改变 t 还是既改变 t 又改变 val?

if (val == t) {/*...*/}// 若 T 是引用类型，则一直为 true

}

当我们对一个右值调用 f 3时，例如字面常量 42, T为 int。在此情况下，局部变量 t 的 类型为 int，且通过拷贝参数 val 的值被初始化。当我们对 t 赋值时，参数 val 保持 不变。

另一方面，当我们对一个左值 i 调用 f3 时、则 T 为 int&。当我们定义并初始化局 部变量 t 时，赋予它类型 int&。因此，对 t 的初始化将其绑定到 val。当我们对 t 赋值 时，也同时改变了 val的值。在 f3 的这个实例化版本中，if判断永远得到 true。

当代码中涉及的类型可能是普通(非引用)类型，也可能是引用类型时，编写正确的 代码就变得异常困难(虽然 remove_reference这样的类型转换类可能会有帮助(参见

16.2.3 节，第 605 页))。

在实际中，右值引用通常用于两种情况：模板转发其实参或模板被重载。我们将在 16.2.7节(第 612 页)中介绍实参转发，在 16.3节(第 614 页)中介绍模板重载。

目前应该注意的是，使用右值引用的函数模板通常使用我们在 13.6.3节(第 481 页) 中看到的方式来进行重载：

template <typename T> void f (T&s) ;    // 瑯定到非 const 右值

template <typename T> void f (const T&) ;    // 左值和 const 右值

与非模板函数一样，第一个版本将绑定到可修改的右值，而第二个版本将绑定到左值或 const右值。

I 690 >



###### 16.2.5节练习

练习 16.42:对下面每个调用，确定 T 和 val 的类型：

template <typename T> void g (T&& val); int i = 0; const int ci = i;

(a) g(i);    (b) g(ci); (c) g (i * ci);

练习 16.43：使用上一题定义的函数，如果我们调用 g(i = ci), g的模板参数将是什 么？

练习 16.44:使用与第一题中相同的三个调用，如果 g 的函数参数声明为 T(而不是 T&& ), 确定 T 的类型。如果 g 的函数参数是 const T&呢？

练习 16.45:给定下面的模板，如果我们对一个像 42 这样的字面常量调用 g，解释会发 生什么？如果我们对一个 int 类型的变量调用 g 呢？

template <typename T> void g(T&& val) { vector<T> v; }

###### 16.2.6 理解 std::move

标准库 move 函数(参见 13.6.1节，第 472 页)是使用右值引用的模板的一个很好的 例子。幸运的是，我们不必理解 move 所使用的模板机制也可以直接使用它。但是，研究 move是如何工作的可以帮助我们巩固对模板的理解和使用。

在 13.6.2节(第 473 页)中我们注意到，虽然不能直接将一个右值引用绑定到一个左 值上，但可以用 move 获得一个绑定到左值上的右值引用。由于 move 本质上可以接受任

何类型的实参，因此我们不会惊讶于它是一个函数模板。

std::move是如何定义的

标准库是这样定义 move 的：

//在返回类型和类型转换中也要用到 typename，参见 16.1.3节(第 593 页)

// remove_reference 是在 16.2.3 节(第 605 页)中介紹的 template <typename T>

typename remove_reference<T>::type&& move(T&& t)

{

// static_cast是在 4.11.3节(第 145 页)中介绍的

return static_cast<typename remove_reference<T>::types&> (t);

}

这段代码很短，但其中有些微妙之处。首先，move的函数参数 T&&是一个指向模板类型 参数的右值引用。通过引用折叠，此参数可以与任何类型的实参匹配。特别是，我们既可 以传递给 move—个左值，也可以传递给它一个右值：

string si ("hi!"), s2;

s2 = std: :move (string ("bye ! ") ) ; // 正确：从一个右值移动数据 s2 = std: :move (si) ; //正确：但在赋值之后，si的值是不确定的

std::move是如何工作的

在第一个赋值中，传递给 move 的实参是 string 的构造函数的右值结果-

<69i~l



string ("bye !")。如我们已经见到过的，当向一个右值引用函数参数传递一个右值时， 由实参推断出的类型为被引用的类型(参见 16.2.5节，第 608 页)。因此，在 std: :move (string (’’bye ! ’*))中：

•推断出的 T 的类型为 string。

•因此，remove_reference 用 string 进行实例化。

•    remove_reference<string>的 type 成员是 string。

•    move的返回类型是 string&&。

•    move的函数参数 t 的类型为 string&&。

因此，这个调用实例化 move<string>，即函数

string&& move(string &&t)

函数体返回 static_cast<string&&> (t) o t的类型已经是 string&&，于是类型转 换什么都不做。因此？此调用的结果就是它所接受的右值引用。

现在考虑第二个赋值，它调用了 std: :move ()。在此调用中，传递给 move 的实参 是一个左值。这样：

•推断出的 T 的类型为 strings (string的引用，而非普通 string)。

•因此，remove—reference 用 strings进行实例化。

•    remove_reference<string&〉的 type 成员是 string。

•    move的返回类型仍是 string&&。

•    move的函数参数 t 实例化为 strings    会折叠为 strings。

因此，这个调用实例化 move<string&〉，即

string&& move(string &t)

这正是我们所寻求的——我们希望将一个右值引用绑定到一个左值=这个实例的函数体返 回 static cast<string&&> (t)。在此情况下，t的类型为 strings，cast将其转 换为 string&&o

从一个左值 static_cast到一个右值引用是允许的

通常情况下，static_cast只能用于其他合法的类型转换(参见 4.11.3节，第 145 页)。但是，这里又有一条 it■对右值引用的特许规则：虽然不能隐式地将一个左值转换为 右值引用，但我们可以用 static_caSt显式地将一个左值转换为一个右值引用。

对于操作右值引用的代码来说，将一个右值引用绑定到一个左值的特性允许它们截断 I 692>左值。有时候，例如在我们的 StrVec 类的 reallocate 函数(参见 13.6.1节，第 469 页)中，我们知道截断一个左值是安全的。一方面，通过允许进行这样的转换，C++语言 认可了这种用法。但另一方面，通过强制使用 static_cast, C++语言试图阻止我们意

外地进行这种转换。

最后，虽然我们可以直接编写这种类型转换代码，但使用标准库 move 函数是容易得 多的方式。而且，统一使用 std: :mOve使得我们在程序中查找潜在的截断左值的代码变 得很容易。

###### 16.2.6节练习

练习 16.46:解释下面的循环，它来自 n.5节(第 469 页)中的 StrVec: : reallocate:

for (size_t i = 0; i != size (); ++i)

alloc.construct(dest++, std::move(*elem++));

驗 16.2.7转发

某些函数需要将其一个或多个实参连同类型不变地转发给其他函数。在此情况下，我们 需要保持被转发实参的所有性质，包括实参类型是否是 const 的以及实参是左值还是右值。

作为一个例子，我们将编写一个函数，它接受一个可调用表达式和两个额外实参。我 们的函数将调用给定的可调用对象，将两个额外参数逆序传递给它。下面是我们的翻转函 数的初步模样：

//接受一个可调用对象和另外两个参数的模板

//对“翻转”的参数调用给定的可调用对象

// flipl是一个不完整的实现：顶层 const 和引用去失了 template <typename F, typename Tl, typename T2> void flipl(F f, Tl tl, T2 t2)

f(t2, tl);

}

这个函数一般情况下工作得很好，但当我们希望用它调用一个接受引用参数的函数时就会 出现问题：

void f (int vl, int &v2) // 注意 v2 是一个引用

cout « vl «



« ++v2 « endl;



在这段代码中，f改变了绑定到 v2 的实参的值。但是，如果我们通过 flipl 调用 f，f 所做的改变就不会影响实参：

f(42, i);    // f 改变了实参 i

flipl (f, j, 42) ; //通过 flipl 调用 f 不会改变 j

问题在于 j 被传递给 flipl 的参数 tl。此参数是一个普通的、非引用的类型 int，而非 int&o因此，这个 flipl 调用会实例化为

void flipl(void(*fcn)(int, int&), int tl, int t2); j的值被拷贝到 tl 中，f中的引用参数被绑定到 tl，而非 j，从而其改变不会影响 j。

< 693 I



定义能保持类型信息的函数参数

为了通过翻转函数传递一个引用，我们需要重写函数，使其参数能保持给定实参的“左 值性”，更进一步，可以想到我们也希望保持参数的 const 属性。

通过将一个函数参数定义为一个指向模板类型参数的右值引用，我们可以保持其对应 实参的所有类型信息。而使用引用参数(无论是左值还是右值)使得我们可以保持 const 属性，因为在引用类型中的 const 是底层的。如果我们将函数参数定义为 T1&&和 T2&&, 通过引用折叠(参见 16.2.5节，第 608 页)就可以保持翻转实参的左值/右值属性(参见

16.2.5 节，第 608 页)：

template <typename F, typename Tl, typename T2> void flip2(F f, T1 &&tl, T2 &&t2)

{

f(t2, tl);

}

与较早的版本一样，如果我们调用 flip2(f, j, 42)，将传递给参数 tl 一个左值 j。 但是，在 fliP2 中，推断出的 T1 的类型为 int&，这意味着 tl 的类型会折叠为 int&。 由于是引用类型，tl被绑定到 j 上。当 fliP2 调用 f 时，f中的引用参数 v2 被绑定到 tl，也就是被绑定到 j。当 f 递增 v2 时，它也同时改变了 j的值。

![img](C++  Primer 5-160.jpg)



如果一个函数参数是指向模板类型参数的右值引用(如 T&& )，它对应的实参 的 const 属性和左值/右值属性将得到保持。

这个版本的 fliP2 解决了一半问题。它对于接受一个左值引用的函数工作得很好, 但不能用于接受右值引用参数的函数。例如：

void g(int &&i, int& j)

{

cout « i « " ’’ « j << endl;

}

如果我们试图通过 fliP2 调用 g，则参数 t2 将被传递给 g 的右值引用参数。即使我们传 递一个右值给 flip2：

flip2(g, i, 42); //错误：不能从一个左值实例化 int&S,

传递给 g 的将是 flip2 中名为 t2 的参数。函数参数与其他任何变量一样，都是左值表 达式(参见 13.6.1节，第 471 页)》因此，flip2中对 g 的调用将传递给 g 的右值引用参 数一个左值。

在调用中使用 std:forward保持类型信息

I 694〉    我们可以使用一个名为 forward 的新标准库设施来传递 flip2 的参数，它能保持原

始实参的类型。类似 move, forward定义在头文件 utility 中。与 move 不同，forward

岡必须通过显式模板实参来调用（参见 16.2.2节，等 603 页）。forward返回该显式实参类 型的右值引用。即，fOrward<T>的返回类型是 T&&。

通常情况下，我们使用 forward 传递那些定义为模板类型参数的右值引用的函数参 数。通过其返回类型上的引用折叠，forward可以保持给定实参的左值/右值属性：

template <typename Type> intermediary（Type &&arg）

{

finalFcn（std::forward<Type>（arg））;

}

本例中我们使用 Type 作为 forward 的显式模板实参类型，它是从 arg 推断出来的。由 于 arg 是一个模板类型参数的右值引用，Type将表示传递给 arg 的实参的所有类型信息。 如果实参是一个右值，则 Type 是一个普通（非引用）类型，forward<Type>将返回 Types,&o如果实参是一个左值，则通过引用折疊，Type本身是一个左值引用类型。在此 情况下，返回类型是一个指向左值引用类型的右值引用。再次对 forwarcKType〉的返回 类型进行引用折叠，将返回一个左值引用类型。

当用于一个指向模板参数类型的右值引用函数参数（T&&）时，forward会保 持实参类型的所有细节。

使用 forward，我们可以再次重写翻转函数:

template <typename F, typename Tl, typename T2> void flip(F f, Tl &&tl, T2 &&t2)

{

f(std::forward<T2>(t2), std::forward<Tl>(tl));

}

如果我们调用 flip (g, i, 42) , i将以 int&类型传递给 g, 42将以 int&&类型传递 给 g。

![img](C++  Primer 5-161.jpg)



与 std: :move相同，对 std: :forward不使用 using 声明是一个好主意， 我们将在 18.2.3节（第 706 页）中解释原因。

###### 16.2.7节练习

练习 16+47:编写你自己版本的翻转函数，通过调用接受左值和右值引用参数的函数来 测试它，

##### 驗 16.3重载与模板

函数模板可以被另一个模板或一个普通非模板函数重载。与往常一样，名字相同的函 数必须具有不同数量或类型的参数。

I 695〉



如果涉及函数模板，则函数匹配规则（参见 6.4节，第 209 页）会在以下几方面受到

影响：

•对于一个调用，其候选函数包括所有模板实参推断(参见 16.2节，第 600 页)成 功的函数模板实例。

•候选的函数模板总是可行的，因为模板实参推断会排除任何不可行的模板。

•与往常一样，可行函数(模板与非模板)按类型转换(如果对此调用需要的话)米

排序。当然，可以用于函数模板调用的类型转换是非常有限的(参见 16.2.1节，第 601 页)。

•与往常一样，如果恰有•个函数提供比任何其他函数都更好的匹配，则选择此函数。 但是|如果有多个函数提供同样好的匹配。贝 IJ:

—如果同样好的函数中只有一个是非模板函数，则选择此函数。

-如果同样好的函数中没有非模板函数，而有多个函数模板，且其中一个模板比 其他模板更特例化，则选择此模板。

—否则，此调用有歧义。

\ 正确定义一组重载的函数模板需要对类型间的关系及模板函数允许的有限的 实参类型转换有深刻的理解

编写重载模板

作为一个例子，我们将构造一组函数，它们在调试中可能很有用。我们将这些调试函 数命名为 debug_rep，每个函数都返回一个给定对象的 string 表示。我们首先编写此 函数的最通用版 i，将它定义为一个模板，接受一个 const 对象的引用：

//打印任何我们不能处理的类型

template <typename T> string debug_rep(const T &t)

{

ostringstream ret; // 参见 8.3 节(第 287 页)

ret « t; //使用 T 的输出运算符打印 t 的一个表示形式

return ret. str () ; // 返回 ret 绑定的 string 的一个副本

}

此函数可以用来生成一个对象对应的 string 表示，该对象可以是任意具备输出运算符的<6961 类型。

接下来，我们将定义打印指针的 debug_rep版木：

//打印指针的值，后跟指针指向的对象

II注意：此函数不能用于 char*；参见 16.3节(第 617 页)

template <typename T> string debug_rep(T *p)

{

ostringstream ret;

ret « "pointer: "<< p;    //打印指针本身的值

if (p)

ret « ’• " « debug_rep (*p) ; // 打印 p 指向的值

else

ret « " null pointer"; // 或指出 p 为空 return ret. str () ; // 返回 ret 绑定的 string 的一个副本

}

此版本生成一个 string，包含指针本身的值和调用 debug_rep获得的指针指向的值。 注意此函数不能用于打印字符指针，因为 IO 库为 char*值定义了一个<<版本。此<<版木 假定指针表示一个空字符结尾的字符数组，并打印数组的内容而非地址值。我们将在 16.3

节(第 617 页)介绍如何处理字符指针。

我们可以这样使用这些函数：

string s (’’hi");

cout << debug_rep(s) << endl;

对于这个调用，只有第一个版本的 debug_rep是可行的。第二个 debug_rep版本要求 一个指针参数，但在此调用中我们传递的 i 一个非指针对象。因此编译器€法从一个非指 针实参实例化一个期望指针类型参数的函数模板，因此实参推断失败。由于只有一个可行 函数，所以此函数被调用。

如果我们用一个指针调用 debug_rep： cout << debug_rep(&s) « endl;

两个函数都生成可行的实例：

•    debug_rep (const string*&)，由第一个版本的 debug_rep 实例化而来，T 被绑定到 string*。

•    debug_rep (string*)，由第二个版本的 debug_rep实例化而来，T被绑定到 string。

第二个版本的 debug_rep的实例是此调用的精确匹配。第一个版本的实例需要进行普通 指针到 const 指针 6 转换。正常函数匹配规则告诉我们应该选择第二个模板，实际上编 译器确实选择了这个版本。

s>多个可行模板

作为另外一个例子，考虑下面的调用：

const string *sp = &s;

cout « debug_rep(sp) « endl;

此例中的两个模板都是可行的，而且两个都是精确匹配：

•    debug_rep (const string*&)。由第~■个版本的 debug_rep 实例化而来，T 被绑定到 string*。

•    debug_rep (const string*)，由第二个版本的 debug_rep 实例化而来，T 被绑定至 1J const string。

在此情况下，正常函数匹配规则无法区分这两个函数。我们可能觉得这个调用将是有歧义 的。但是，根据重载函数模板的特殊规则，此调用被解析为 debUg_rep(T*)，即，更特 例化的版本。

设计这条规则的原因是，没有它，将无法对一个 const 的指针调用指针版本的 debug_rep。问题在于模板 debug_rep (const T&)本质上可以用于任何类型，包括指 针类型了此模板比 debug_rep(T*r更通用，后者只能用于指针类型。没有这条规则，传 递 const 的指针的调用永远是有歧义的。

当有多个重载模板对一个调用提供同样好的匹配时，应选择最特例化的版本、

非模板和模板重载

作为下一个例子，我们将定义一个普通非模板版本的 debug rep来打印双引号包围

的 string：

//打印双引号包围的 string string debug_rep(const string &s) {

return z + s + r ;

现在，当我们对一个 string 调用 debug_rep时：

string s ("hi**);

cout « debug_rep(s) << endl;

有两个同样好的可行函数：

•    debug_rep<string> (const strings)，第一个模板，T 被绑定到 string*»

•    debug_rep (const strings) , 非模板函数。

在本例中，两个函数具有相同的参数列表，因此显然两者提供同样好的匹配。但是，编译 OS 器会选择非模板版本。当存在多个同样好的函数模板时，编译器选择最特例化的版本，出 于相同的原因，一个非模板函数比一个函数模板更好。

对于一个调用，如果一个非函数模板与一个函数模板提供同样好的匹配，则选 择非模板版本。

重载模板和类型转换

还有一种情况我们到目前为止尚未讨论：C风格字符串指针和字符串字面常量。现在 有了一个接受 string 的 debug_rep版本，我们可能期望一个传递字符串的调用会匹配 这个版本。但是，考虑这个调用：

cout << debug_rep ("hi world!’，)<< endl; // 调用 debug_rep (T*)

本例中所有三个 debug_rep版本都是可行的：

•    debug_rep (const T&) , T 被绑定至 ij char [ 10]。

•    debug_rep (T*) , T 被绑定至 Ij const char。

•    debug_rep (const strings)，要求从 const char*至 Ij string 的类型转换。

对给定实参来说，两个模板都提供精确匹配——第二个模板需要进行一次(许可的)数组 到指针的转换，而对于函数匹配来说，这种转换被认为是精确匹配(参见 6.6.1节，第 219 页)。非模板版本是可行的，但需要进行一次用户定义的类型转换，因此它没有精确匹配 那么好，所以两个模板成为可能调用的函数。与之前一样，T*版本更加特例化，编译器会 选择它。

如果我们希望将字符指针按 string 处理，可以定义另外两个非模板重载版本：

//将字符指针转换为 string，并调用 string 版本的 debug_reg string debug_rep(char *p)

{

return debug_rep(string(p));

}

string debug_rep(const char *p)

return debug一 rep(string(p));

缺少声明可能导致程序行为异常

值得注意的是，为了使 char*版本的 debug_rep正确工作，在定义此版本时， debug_rep (const strings)的声明必须在作用域中。否则，就可能调用错误的 debug_rep 版本：

| 699>    template <typename T> string debug_rep(const T &t);

template <typename T> string debug_rep(T *p);

II为了使 debug_rep (char* )的定义正确工作，下面的声明必彡贞在作用域中 string debug_rep(const string &);

string debug_rep(char *p)

{

//如果接受一个 const string&的版本的声明不在作用域中，

//返回语句将调用 debug_rep (const T&)的 T 实例化为 string 的版本 return debug_rep(string(p));

}

通常，如果使用了一个忘记声明的函数，代码将编译失败。但对于重载函数模板的函数而 言，则不是这样。如果编译器可以从模板实例化出与调用匹配的版本，则缺少的声明就不 重要了。在本例中，如果忘记了声明接受 string 参数的 debug_rep版本，编译器会默 默地实例化接受 const T&的模板版本。

![img](C++  Primer 5-162.jpg)



在定义任何函数之前，记得声明所有重载的函数版本，这样就不必担心编译器 由于未遇到你希望调用的函数而实例化一个并非你所需的版本。乂：

###### 16.3节练习

练习 16.48：编'弓你自己版本的 debug_rep函数。 练习 16.49：解释下面每个调用会发生什么：

template <typename T> void f(T); template <typename T> void f(const T*); template <typename T> void g(T); template <typename T> void g(T*); int i = 42, *p = &i;

const int ci = 0, *p2 = &ci; g(42) ; g(p); g(ci) ; g(p2); f(42) ; f(p); f(ci); f(p2);

练习 16.50：定义上一个练习中的函数，令它们打印一条身份信息。运行该练习中的代 码。如果函数调用的行为与你预期不符，确定你理解了原因。

##### 驗 16.4吋变参数模板

[C++ j    个可变参数模板(variadic template)就是一个接受可变数冃参数的模板函数或模板

类。可变数目的参数被称为参数包(parameter packet)。存在两种参数包：模板参数包

LZOO> (template parameter packet)，表示零个或多个模板参数；函数参数包(function parameter packet)，表示零个或多个函数参数。

我们用一个省略号来指出一个模板参数或函数参数表示一个包。在一个模板参数列表

中，class..。或 typename..。指出接下来的参数表示零个或多个类型的列表；一个类型 名后面跟一个省略号表示零个或多个给定类型的非类型参数的列表。在函数参数列表中， 如果一个参数的类型是一个模板参数包，则此参数也是一个函数参数包。例如：

// Args是一个模板参数包；rest是一个函数参数包 // Args表示零个或多个模板类型参数 // rest表示掌个或多个函数参数 template <typename T, typename... Args> void foo (const T &t, const Args& ... rest);

声明了 foo是一个可变参数函数模板，它有一个名为 T 的类型参数，和一个名为 Args 的模板参数包。这个包表示零个或多个额外的类型参数。foo的函数参数列表包含一个 const &类型的参数，指向 T 的类型，还包含一个名为 rest 的函数参数包，此包表示零 个或多个函数参数。

与往常一样，编译器从函数的实参推断模板参数类型。对于一个可变参数模板，编译 器还会推断包中参数的数目。例如，给定下面的调用：

| int i = 0; double d = 3.14; string s = | "how now brown cow |      |
| -------------------------------------- | ------------------ | ---- |
| foo (i, s, 42r d);                     | //包中有三个参数   |      |
| foo(s, 42, "hi");                      | //包中有两个参数   |      |
| foo(d, s);                             | //包中有一个参数   |      |
| foo("hi");                             | //空包             |      |

编译器会为 foo 实例化出四个不同的版本:

void foo(const int&, const strings, const int&, const doubles); void foo(const strings, const int&, const char[3]&); void foo (const doubles, const strings);

void foo(const char[3]&);

在每个实例中，T的类型都是从第一个实参的类型推断出来的。剩下的实参(如果有的话) 提供函数额外实参的数目和类型。

sizeof..。运算符

当我们需要知道包中有多少元素时，可以使用 sizeof..。运算符。类似 sizeof (参 见 4.9节，第 139 页)，sizeof..。也返回一个常量表达式(参见 2.4.4节，第 58 页)，而且 不会对其实参求值：

template<typename ... Args> void g(Args ... args) { cout « sizeof . . . (Args) << endl; // 类型参数的数目 cout « sizeof... (args) « endl; // 函数参数的数目

###### 16.4节练习

练习 16.51:调用本节中的每个 foo，确定 sizeof... (Args)和 sizeof... (rest)分别 返回什么。

练习 16.52:编写一个程序验证上一题的答案。

###### 16.4.1编写可变参数函数模板

如 6.2.6节(第 198 页)所述，我们可以使用一个 initializer_list来定义一个 可接受可变数目实参的函数。但是，所有实参必须具有相同的类型(或它们的类型可以转 换为同一个公共类型)。当我们既不知道想要处理的实参的数目也不知道它们的类型时， 可变参数函数是很有用的。作为一个例子，我们将定义一个函数，它类似较早的 error_msg函数，差别仅在于新函数实参的类型也是可变的。我们首先定义一个名为 print的函数，它在一个给定流上打印给定实参列表的内容。

可变参数函数通常是递归的(参见 6.3.2节，第 204 页)。第一步调用处理包中的第一 个实参，然后用剩余实参调用自身。我们的 print 函数也是这样的模式，每次递归调用 将第二个实参打印到第一个实参表示的流中。为了终止递归，我们还需要定义一个非可变 参数的 print 函数，它接受一个流和~个对象：

//用来终止递归并打印最后一个元素的函数

//此函教必须在可变参数版本的 print 定义之前声明

template<typename T>

ostream Sprint(ostream &os, const T &t)

{

return os « t; //包中最后一个元素之后不打印分隔符

}

//包中除了最后一个元素之外的其他元素都会调用这个版本的 print template <typename T, typename... Args>

ostream Sprint(ostream &os, const T &t, const Args&... rest)

{

os « t « ", "；    //打印第一个实参

return print (os, rest...);    // 递!)3 调用，打印其他实参

)

第一个版本的 print 负责终止递归并打印初始调用中的最后一个实参。第二个版本的 print是可变参数版本，它打印绑定到 t 的实参，并调用自身来打印函数参数包中的剩 余值。

这段程序的关键部分是可变参数函数中对 print 的调用： return print (os, rest...); //递担调用，打印其他实参

我们的可变参数版本的 print 函数接受三个参数：一个 ostreams，一个 const T&和一 个参数包。而此调用只传递了两个实参。其结果是 rest 中的第一个实参被绑定到 t，剩

[202>余实参形成下一个 print 调用的参数包。因此，在每个调用中，包中的第一个实参被移 除，成为绑定到 t 的实参。即，给定：

print (cout, i, s, 42); //包中有两个参数 递归会执行如下：

调用    t    rest...

print(cout,    i,    s, 42)    i    s, 42

print(cout,    s,    42)    s    42

print (cout, 42)调用非可变参数版本的 print

前两个调用只能与可变参数版本的 print 匹配，非可变参数版本是不可行的，因为这两 个调用分别传递四个和三个实参，而非可变参数 print 只接受两个实参。

对于最后一次递归调用 print （cout, 42），两个 print 版本都是可行的。这个调 用传递两个实参，第一个实参的类型为 ostream&»因此，可变参数版本的 print 可以 实例化为只接受两个参数：一个是 ostream&参数，另一个是 const T&参数。

对于最后一个调用，两个函数提供同样好的匹配。但是，非可变参数模板比可变参数 模板更特例化，因此编译器选择非可变参数版本（参见 16.3节，第 615 页）。

WARNING



当定义可变参数版本的 print 时，非可变参数版本的声明必须在作用域中。 否则，可变参数版本会无限递归。

###### 16.4.1节练习

练习 16.53:编写你自己版本的 print 函数，并打印一个、两个及五个实参来测试它， 要打印的每个实参都应有不同的类型。

练习 16.54:如果我们对一个没有<<运算符的类型调用 print，会发生什么？

练习 16.55：如果我们的可变参数版本 print 的定义之后声明非可变参数版本，解释可 变参数的版本会如何执行。

###### 16.4.2包扩展

对于一个参数包，除了获取其大小外，我们能对它做的唯一的事情就是扩展（expand）

它。当扩展一个包时，我们还要提供用于每个扩展元素的模式（pattern）。扩展一个包就是<70^ 将它分解为构成的元素，对每个元素应用模式，获得扩展后的列表。我们通过在模式右边 放一个省略号（...）来触发扩展操作，

例如，我们的 print 函数包含两个扩展：

template <typename T, typename... Args> ostream &

print（ostream &os, const T &t, const Args&... rest） // 才广展 Args

{

os « t <<    ;

return print（os, rest...）;    // ，展 rest

}

第一个扩展操作扩展模板参数包，为 print 生成函数参数列表。第二个扩展操作出现在 对 print 的调用中。此模式为 print 调用生成实参列表。

对 Args 的扩展中，编译器将模式 const Arg&应用到模板参数包 Args 中的每个元 素。因此，此模式的扩展结果是一个逗号分隔的零个或多个类型的列表，每个类型都形如 const type&o 例如：

print （cout, i, s, 42）; //包中有两个参数 最后两个实参的类型和模式一起确定了尾置参数的类型。此调用被实例化为：

ostream&

print（ostreams, const int&, const strings, const int&）;

第二个扩展发生在对 print 的（递归）调用中。在此情况下，模式是函数参数包的 名字（即 rest）。此模式扩展出一个由包中元素组成的、逗号分隔的列表。因此，这个调

用等价于：

print(os, s, 42);

理解包扩展

print中的函数参数包扩展仅仅将包扩展为其构成元素，C++语言还允许更复杂的扩 展模式。例如，我们可以编写第二个可变参数函数，对其每个实参调用 debug_rep (参 见 16.3节，第 615 页)，然后调用 print 打印结果 string:

II在 print 调用中对每个实参讲用 debug_rep template <typename... Args>

ostream SerrorMsg(ostream &os, const Args&... rest)

{

// print(os, debug_rep(al), debug_rep(a2),    debug_rep(an)

return print(os, debug_rep(rest)...);

}

I 704〉 这个 print 调用使用了模式 debug_reg (rest)。此模式表示我们希望对函数参数 包 rest 中的每个元素调用 debug_repo扩展结果将是一个逗号分隔的 debug_rep调 用列表。即，下面调用：

errorMsg(cerr, fcnName, code.num(), otherData, "other”， item);

就好像我们这样编写代码一样

print (cerr, debug_rep(fcnName), debug_rep(code.num()),

debug_rep(otherData), debug_rep("otherData"), debug_rep(item));

与之相对，下面的模式会编译失败

// 将包传递给 debug_rep; print (os, debug_rep (al, a2,    an))

print (os, defc)ug_rep (rest...)); // 错误：此调用无匹配函数

这段代码的问题是我们在 debug_rep调用中扩展了 rest，它等价于

print(cerr, debug_rep(fcnName, code.num(),

otherData, "otherData", item));

在这个扩展中，我们试图用一个五个实参的列表来调用 debug_rep，但并不存在与此调 用匹配的 debug_rep版本。debug_rep函数不是可变参数的，而且没有哪个 debug_rep 版本接受五个参 i。

扩展中的模式会独立地应用于包中的每个元素。

###### 16.4.2节练习

练习 16.56：编写并测试可变参数版本的 errorMsg。

练习 16.57:比较你的可变参数版本的 errorMsg 和 6.2.6节(第 198 页冲的 error_msg 函数。两种方法的优点和缺点各是什么？

#### @ 16.4.3转发参数包

■c^    在新标准下，我们可以组合使用可变参数模板与 forward 机制来编写函数，实现将

其实参不变地传递给其他函数。作为例子，我们将为 StrVec 类(参见 13.5节，第 465 页)添加一个 emplace_back成员。标准库容器的 emplace_back成员是一个 IJT 变参 数成员模板(参见 16.1.4_节，第 596 页)，它用其实参在容器管理的内存空间中直接构造 一个元素。

我们为 StrVec 设计的 emplace_back版本也应该是可变参数的，因为 string 有 多个构造函数，参数各不相同。由于我 1 门希望能使用 string 的移动构造函数，因此还需<ZQ5： 要保持传递给 emplace_back的实参的所有类型信息。

如我们所见，保持类型信息是一个两阶段的过程。首先，为了保持实参中的类型信息，

必须将 emplace_back的函数参数定义为模板类型参数的右值引用(参见 16.2.7节，第 613 页)：

class StrVec { public:

template 〈class... Args> void emplace_back(Args&&...);

//其他成员的定义，同 13.5节(第 465 页)

}；

模板参数包扩展中的模式是&&，意味着每个函数参数将是一个指向其对应实参的右值引 用。

其次，当 emplace_back将这些实参传递给 construct 时，我们必须使用 forward 来保持实参的原始类型(参见 16.2.7节，第 614 页)：

template <class... Args> inline

void StrVec::emplace_back(Args&&... args)

{

chk_n_alloc () ; //如果需要的话重新分配 StrVec 内存空间

alloc.construct(first_free++, std::forward<Args>(args)...)；

}

emplace_back的函数体调用了 chk_n_alloc (参见 13.5节：第 465 50来确保有足 够的空间容纳一个新兀素，然后调用了 construct在 first_free指向的位置中创建 了一个元素。construct调用中的扩展为

std::forward<Args>(args)...

它既扩展了模板参数包 Args，也扩展了函数参数包 args。此模式牛成如下形式的元素 std: : forward<Ti> (ti)

其中 A 表示模板参数包中第 i 个元素的类型，ti表示函数参数包中第 i 个元素。例如， 假定 svec 是一个 StrVec，如果我们调用

svec. emplace_back (10, r c’)； // 将 cccccccccc 添力口为新的尾元素 construct调用中的模式会扩展出

std::forward<int>(10), std::forward<char>(c)

通过在此调用中使用 forward，我们保证如果用一个右值调用 emplaCe_back，则 construct也会得到一个右值。例如，在下面的调用巾：

svec.emplace_back (si + s2) ; // 使用移动构造函数 传递给 emplace back的实参是一个右值，它将以如下形式传递给 construct

std::forward<string>(string("the end"))

forward<string>的结果类型是 string&&，因此 construct 将得到一个右值引用实 参。construct会继续将此实参传递给 string 的移动构造函数来创建新元素。

进议：转发和"T变参数模板

可变参数函数通常将它们的参数转发给其他函数。这种函数通常具有与我们的 emplace_back函数一样的形式：

// fun有零个或多个参数，每个参数都是一个模板参数类型的右值引用 template<typename... Args>

void fun (Args&& . . . args) //将 Args 扩展为一个右值引用的列表

{

// work的实参既扩展 Args 又扩展 args work(std::forward<Args>(args)...);

}

这里我们希望将 fun 的所有实参转发给另一个名为 work 的函数，假定由它完成函数的 实际工作 6 类似 emplace_back中对 construct 的调用，work调用中的扩展既扩展 了模板参数包也扩展了函 i 参数包。

由于 fun 的参数是右值引用，因此我们可以传递给它任意类型的实参；由于我们 使用 std: : forward传递这些实参，因此它们的所有类型信息在调用 work 时都会得 到保持。

###### 16.4.3节练习

练习 16.58：为你的 StrVec 类及你为 16.1.2节(第 591 页)练习中编写的 Vec 类添加 emplace_back 函数。

练习 16.59:假定 s 是一个 string，解释调用 svec . emplace_back (s)会发生什么。 练习 16.60：解释 make_shared (参见 12.1.1节，第 401 页)是如何工作的。

练习 16.61:定义你自己版本的 make shared。

绿 16.5模板特例化

编写单一模板，使之对任何可能的模板实参都是最适合的，都能实例化，这并不总是 能办到。在某些情况下，通用模板的定义对特定类型是不适合的：通用定义可能编译失败 或做得不正确。其他时候，我们也可以利用某些特定知识来编写更高效的代码，而不是从 通用模板实例化。当我们不能(或不希望)使用模板版本时，可以定义类或函数模板的-• 个特例化版本。

我们的 compare 函数是一个很好的例子，它展示了函数模板的通用定义不适合一个 特定类型(即字符指针)的情况。我们希望 compare 通过调用 strcmp 比较两个字符指 针而非比较指针值。实际上，我们已经重载了 compare函数来处理字符串字面常量(参 见 16.1.1节，第 579 页)：

//第一个版本；可以比较任意两个类型

template <typename T> int compare(const T&, const T&);

//第二个版本处理字符串字面常量 template<size_t N, size_t M>

int compare(const char (&)[N], const char (&)[M]);

但是，只有当我们传递给 compare 一个字符串字面常量或者一个数组时，编译器才会调 用接受两个非类型模板参数的版本。如果我们传递给它字符指针，就会调用第一个版本：

const char *pl = "hi", *p2 = "mom";

compare (pi, p2) ;    //调用第一个模板

compare ("hi" f "mom");    //调用有两个非类型参数的版本

我们无法将一个指针转换为一个数组的引用，因此当参数是 pi 和 p2 时，第二个版本的 compare是不可行的。

为了处理字符指针(而不是数组)，可以为第一个版本的 compare 定义一个模板特例 化(template specialization)版本。一个特例化版本就是模板的一个独立的定义，在其中一 个或多个模板参数被指定为特定的类型。

定义函数模板特例化

当我们特例化一个函数模板时，必须为原模板中的每个模板参数都提供实参。为了指 出我们正在实例化一个模板，应使用关键字 template 后跟一个空尖括号对(<〉)。空尖 括号指出我们将为原模板的所有模板参数提供实参：

// compare的特殊版本，处理字符数组的指针 template <>

int compare(const char* const &pl, const char* const &p2)

{

return strcmp(pi, p2);

}

理解此特例化版本的困难之处是函数参数类型。当我们定义一个特例化版本时，函数参数 类型必须与一个先前声明的模板中对应的类型匹配。本例中我们特例化：

template <typename T> int compare(const T&, const T&);

其中函数参数为一个 const 类型的引用。类似类型别名，模板参数类型、指针及 const 之间的相互作用会令人惊讶(参见 2.5.1节，第 60 页)。

我们希望定义此函数的一个特例化版本，其中 T 为 const char*。我们的函数要求 一个指向此类型 const 版本的引用。一个指针类型的 const 版本是一个常量指针而不是 指向 const 类型的指针(参见 2.4.2节，第 56 页)。我们需要在特例化版本中使用的类型 是 const char * const &，即一个指向 const char的 const 指针的引用。

函数重载与模板特例化

<~707~|



<70^1



当定义函数模板的特例化版本时，我们本质上接管了编译器的工作。即，我们为原模 板的一个特殊实例提供了定义。重要的是要弄清：一个特例化版本本质上是一个实例，而 非函数名的一个重载版本。

![img](C++  Primer 5-164.jpg)



特例化的本质是实例化一个模板，而非重载它。因此，特例化不影响函数匹配 17

我们将--个特殊的函数定义为一个特例化版本还是一个独立的非模板函数，会影响到 函数匹配。例如，我们己经定义了两个版本的 compare 函数模板，一个接受数组引用参 数，另一个接受 const T&。我们还定义了一个特例化版本来处理字符指针，这对函数匹 配没有影响-当我们对字符串字面常量调用 compare 时

compare（"hi", "mom"）

对此调用，两个函数模板都是可行的，且提供同样好的（即精确的）匹配。但是，接受字 符数组参数的版本更特例化（参见 16.3节，第 615 页），因此编译器会选择它，

如果我们将接受字符指针的 compare 版本定义为一个普通的非模板函数（而不是模 板的一个特例化版本），此调用的解析就会不同。在此情况下，将会有三个可行的函数： 两个模板和非模板的字符指针版本。所有三个函数都提供同样好的匹配。如前所述，当一 个非模板函数提供与函数模板同样好的匹配时，编译器会选择非模板版本（参见 16.3节， 第 615 页）。

关键概念：绔通作川域现则应川于特例化

为了特例化一个模板，原模板的声明必须在作用域中 D 而且，在任何使用模板实例 的代码之前，特例化版本的声明也必须在作用域中，

对于普通类和函数，丢失声明的情况（通常）很容易发现——编译器将不能继续处 理我们的代码。但是，如果丢失了一个特例化版本的声明，编译器通常可以用原模板生 成代码:。由于在丢失特例化版本时编译器通常会实例化原模板，很容易产生模板及其特 例化版本声明顺序导致的错误，而这种错误又很难查找。

如果一个程序使用一个特例化版本，而同时原模板的一个实例具有相同的模板实参 集合，就会产生错误。但是，这种错误编译器又无法发现。

卩^«模板及其特例化版本应该声明在同一个头文件中所有同名模板的声明应该放 在前面，然后是这些模板的特例化版本、

类模板特例化

除了特例化函数模板，我们还可以特例化类模板。作为一个例子，我们将为标准库 hash模板定义一个特例化版本，可以用它来将 Sales_data对象保存在无序容器中。默 i人情况下，无序容器使用 hash<key_type> （参见 11.4节，第 394 页）来组织其元素。 为了让我们自己的数据类型也能使用三种默汄组织方式，必须定义 hash 模板的一个特例 化版本。一个特例化 hash 类必须定义：

• 一个重载的调用运算符（参见 14.8节，第 506 页），它接受一个容器关键字类型的 对象，返回一■个 size_t»

•两个类®成员，result_type和 argument_type，分别调用运算符的返回类型 和参数类型，

•默认构造函数和拷贝赋值运算符（可以隐式定义，参见 13.1.2节，第 443 页）。

在定义此特例化版本的 hash 时，唯一复杂的地方是：必须在原模板定义所在的命名空 间中特例化它。我们将在 18.2节（第 695 页）中介绍更多命名空间的相关内容。现在，我 们只需知道一我们可以向命名空间添加成员。为了达到这一目的，首先必须打开命名空间：

II打开 std 命名空间，以便特例化 std: :hash namespace std {

} //关闭 std 命名空间；注意：右花括号之后没有分号 花括号对之间的任何定义都将成为命名空间 Std 的一部分。

下面的代码定义了一个能处理 Sales_data的特例化 hash 版本：

II打开 std 命名空间，以便特例化 std: :hash namespace std {

template <> //我们正在定义一个特例化版本，模板参数为 Sales_data struct hash<Sales_data>

{

//用来散列一个无序容器的类型必须要定义下列类型 typedef size_t result一 type;

typedef Sales_data argument_type; // 默认情况下，此类型需要== size_t operator()(const Sales_data& s) const;

//我 7 们的类使用合成的拷贝控制成员和 i 认构造函数

}；

size_t

hash<Sales_data>::operator()(const Sales_data& s) const

{

return hash<string>()(s.bookNo) A

hash<unsigned>()(s.units_sold) A hash<double>()(s.revenue);

}

} //关闭 std 命名空间；注意：右花括号之后没有分号

我们的 hash<Sales_data>定义以 templateo 开始，指出我们正在定义一"^全特例化 03 的模板=我们正在特例化的模板名为 hash，而特例化版本为 hash<Sales_data>。接 下来的类成员是按照特例化 hash 的要求而定义的。

类似其他任何类，我们可以在类内或类外定义特例化版本的成员，本例中就是在类外 定义的。重载的调用运算符必须为给定类型的值定义一个哈希函数。对于一个给定值，任 何时候调用此函数都应该返回相同的结果。一个好的哈希函数对不相等的对象(儿乎总是)

应该产生不同的结果。

在本例中，我们将定义一个好的哈希函数的复杂任务交给了标准库。标准库为内置类 型和很多标准库类型定义了 hash类的特例化版本。我们使用一个(未命名的) hash<string>对象来生成 bookNo 的哈希值，用一个 hashfunsigned:^5!]^来生成 units_sold的哈希值，用一个 hash<double>对象來生成 revenue 的哈希值。我们 将这些结果进行异或运算(参见 4.8节，第 137 页)，形成给定 Sales_data对象的完整 的哈希值。

值得注意的是，我们的 hash 函数计算所有三个数据成员的哈希值，从而与我们为 Sales_data定义的 operator==(参见 14.3.1节，第 497 页)是兼容的。默认情况下，

为了处&特定关键字类型，无序容器会组合使用 key_type对应的特例化 hash 版本和 key_type上的相等运算符。

假定我们的特例化版本在作用域中，当将 Sales_data作为容器的关键字类型吋，

编译器就会自动使用此特例化版本：

II 使用 hash<Sales_data>* 14.3」节(第 497 瓦)中 Sales_data 的 operator= unordered_multiset<Sales_data> SDset;

由于 hash<Sales data〉使用 Sales data的私有成员，我们必须将它声明为

Sales_data 的友兀：

template〈class T> class std: :hash; // 友元声明所需要的 class Sales_data {

friend class std::hash<Sales_data>;

//其他成贾定义，如前

}；

这段代码指出特殊实例 hash<Sales_data〉是 Sales_data的友元。由于此实例定义 在 std 命名空间中，我们必须记得在 friend 声明中应使用 std: :hash。

![img](C++  Primer 5-165.jpg)



为了让 Sales_data的用户能使用 hash 的特例化版本，我们应该在 Sales_data的头文件中定义该特例化版本。

类模板部分特例化

与函数模板不同，类模板的特例化不必为所有模板参数提供实参。我们可以只指定一 r7iE>部分而非所有模板参数，或是参数的一部分而非全部特性。一个类模板的部分特例化 (partial specialization)本身是一个模板，使用它时用户还必须为那些在特例化版本中未指

定的模板参数提供实参。

![img](C++  Primer 5-166.jpg)



我们只能部分特例化类模板，而不能部分特例化函数模板。

在 16.2.3节(第 605 页)中我们介绍了标准库 remove_reference类型。该模板是 通过一系列的特例化版本来完成其功能的：

//原始的、最通用的版本

template <class T> struct remove_reference { typedef T type;

}；

//部分特例化版本，将用于左值引用和右值引用

template〈class T> struct remove_reference<T&> // 左值弓 1 用 { typedef T type; };

template〈class T> struct remove_reference<T&&> // 右值引用 { typedef T type; };

第一个模板定义了最通用的模板。它可以用任意类型实例化；它将模板实参作为 type 成 员的类型=接下来的两个类是原始模板的部分特例化版本。

由于一个部分特例化版本本质是一个模板，与往常一样，我们首先定义模板参数。类 似任何其他特例化版本，部分特例化版本的名字与原模板的名字相同。对每个未完全确定 类型的模板参数，在特例化版本的模板参数列表中都有一项与之对应。在类名之后，我们 为要特例化的模板参数指定实参，这些实参列于模板名之后的尖括号中。这些实参与原始 模板中的参数按位置对应。

部分特例化版本的模板参数列表是原始模板的参数列表的一个子集或者是一个特例 化版本。在本例中，特例化版本的模板参数的数目与原始模板相同，但是类型不同。两个 特例化版本分别用于左值引用和右值引用类型：

int i;

// decltype (42)为 int，使用原始模板 remove reference<decltype(42)>::type a;

// decltype (i)为 int&，使用第一个(T& )部分特例化版本 remove_reference<decltype(i)>::type b;

// decltype (std: :move (i))为 int&&，使用第二个(即 T&& )部分特例化版本 remove reference<decltype(std::move(i))>::type c;

三个变量 a、b和 c 均为 int 类型。

特例化成员而不是类

我们可以只特例化特定成员函数而不是特例化整个模板。例如，如果 FOO 是一个模 板类，包含一个成员 Bar，我们可以只特例化该成员：

template <typename T> struct Foo {

Foo (const T &t = T()): mem(t) { } void Bar() { /* ... */ }

T mem;

// Foo的其他成员

}；

tempiate<>    //我们正在特例化一个模板

void Foo<int> : :Bar () // 我们正在特例化 Foo<int>的成员 Bar {

//进行应用于 int 的特例化处理

}

本例中我们只特例化？00<;1111:>类的一个成员，其他成员将由 Foo 模板提供：

Foo<string> fs;    // 实例化 Foo<string>: :Foo ()

f s .Bar () ;    // 实例化 Foo<string> ::Bar ()

Foo<int> f i;    // 实例化 Foo<int>:: Foo ()

fi .Bar () ;    //使用我们特例化版本的 Foo<int>: :Bar ()

当我们用 int 之外的任何类型使用 Foo 时，其成员像往常一样进行实例化。当我们用 int 使用 Foo 时，Bar之外的成员像往常一样进行实例化。如果我们使用 FOO<int>的成员 Bar，则会使用我们定义的特例化版本。

###### 16.5节练习_

练习 16.62：定义你自己版本的 hash<Sales_data〉，并定义一个 Sales_data对象 的 unordered_multiset。将多条交易记录保存到容器中，并打印其内容。

练习 16.63:定义一个函数模板，统计一个给定值在一个 vector 中出现的次数。测试 你的函数，分别传递给它一■个 double 的 vector,—个 int 的 vector 以及一个 string 的 vector。

练习 16.64：为上一题中的模板编写特例化版本来处理 vector<const char*〉。编 写程序使用这个特例化版本。

练习 16.65:在 16.3节(第 617 页)中我们定义了两个重载的 debug_rep版本，一个 接受 const char*参数，另一个接受 char*参数。将这两个函数重写为特例化版本。 练习 16.66:重载 debtig_rep函数与特例化它相比，有何优点和缺点？

练习 16.67:定义特例化版本会影响 debLig rep的函数匹配吗？如果不影响，为什么？

Era＞小结_

模板 U C++语 i 众不 M 的特性，也是标准叩的基础.-个機板就是-个编译器用來 1-:成特定炎类 51 或函数的蓝困.'I:-成特纪类或函数的过样称为实例化。我们只编'与一次模 板，就町以将其用 n 种类型和值，编译器僉为毎种类型相值进汀模板实例化•

我们既可以定义涵数模板，也 W 以定义类模板。标准祚律法都记函数模板，标准库容 器都是类校板

W乂投板实参允 i'卩我们阆定-个或多个模板参数的类■值。对 f 指定了显式模板实 参的模板参数。可以应用止常的类彻转換.

•个投板特例化就足 '个用户提供的模板实例，它将•个或多个模板参数绑定到特定 类增成值上. '与我们不能(或不沿望)将模板定义用 r 某鵷特定类型时，特例化依常夯用.

诚新 C++鉍准的个 1:耍部分足川'变参数摸板。个 4 变参数模板叫'以接受数 H 和类 可变的参歎。叫变養数模板允许我们编 1 像容器卿 emplace 成霧和标准峰

make_shareci 数这样的函数，实现将实参传递给对象的构造函数-

类模板(class template)投板定义，吋

从它实例化出牯定的类。炎投板的定义以 关键'? template开始，后跟尖括号对＜ 和＞，M:内为个用逗分隔的•个或多个 模板参故的列表，随后足类的定义。

默认模板实参(default template argument)

•个类咽或-•个值.'与肋提供対应校 &实参时，模板会使川它，

显式实例化 ＜ explicit instantiation) ■个

声明，y、j所夼模板参数提供了显式实参. 川求-指列化过程。如宋卢叫 A1; extern 的，模板将不会被实例化:否则，模板将 利蜊指定的实参道行寃駒化。对毎个 extern投板声明，/EfiUY:中某处必须 个 IP extern的!ul式丈例化.

显式模板实参(.explicit template argument)

花•个函数调用中成定义模板类类型时, 由用 P 提供的模板实参。赇式模板实参在 紧跟作模板名的尖括 G 对中给岀。

函数参数包(function parameter pack)表

不；个或多个函数参数的参数包„

函数模板(function template)模板定义，

|叮从它沈例化岀特定函数，函数模板的定

义以又键 7 template斤始，JTI+跟尖 ttU 对＜和＞.K内为-••个用屬分分隔的-个或 多个模板参敷的列犮，随后是函数的定义,

实例化(instantiate)編汴器处评过柷，

W实际的模板实参來乍成模板的_个特殊 实例。其屮参数波锌換为对应的实参.， 函数投板被凋谢对，会 T 彳动根裾传述给它 的实参來实例化。时使/B类桢板时，则： 要我们提供姑式模板实参。

实例(instantiation)编汗器从模板成

的类或函放。

成员模板(member template) 4^ ft IeIK 板的成 S 函数。成 0 模板不能是虚函数。

非类型参数(nontype parameter) 喪水

值的模板参数。11:类喂模板参数的实参必 须玷常 W 炎达式.

包扩展(packexpansion)处理过程，将

••个参数包押换为其中元素的列表.

参数包(parameter pack)衣丫'^个成多 个参数的税板或函数参数。

部分特例化(partial specialization)类投

板的-个版木，其中指记厂策，+坫所

有模板参数，或是一个或多个参数的属性 未被完全指定。

模式(pattern)定义了扩展后参数包中每 个元素的形式。

模板实参(template argument)用来实

例化模板参数的类型或值。

模板实参推断(template argument deduction)编译器确定实例化哪个函数 模板的过程。编译器检查那些使用模板参 数的实参的类型，将这些类型或值绑定到 模板参数，來自动实例化一个函数版本。

模板参数(template parameter)在模板

参数列表中指定的名字，可在模板定义内 部使用。模板参数可以是类型参数，也可 以是非类型参数。为了使用•个类模板， 我们必须为毎个模板参数提供显式实参， 编译器使用这些类型或值实例化出一个类 版本，其中所有用到模板参数的地方都被 替换为实际的实参。当使用一个函数模板 时，编译器使用调用中的函数实参推断模 板实参，并使用推断出的模板实参实例化 出一个特定的函数。

模板参数列表(template parameter list)

用逗号分隔的参数列表，用丁•模板的定义 或声明中。每个参数可以是一个类型参数， 也可以是一个非类型参数。

模板参数包(template parameter pack)

表示零个或多个模板参数的参数包。

模板特例化(templatespecialization)类

模板、类模板的成员或函数模板的重定义， 其中指定了某些(或全部)模板参数。模 板特例化版本必须出现在原模板的声明之 后，必须出现在任何利用特殊实参来使用 模板的代码之前。一个函数模板中的每个 模板参数都必须完全特例化。

类型参数(type parameter)模板参数列

表中的名字，用來表示类型。类型参数在 关键字 typename 或 class 之后指定。

类型转换(type transformation)由标准

库定义的类模板，可将给定的模板类型参 数转换为一个相关类型。

可变参数模板(variadic template)接受

可变数目模板实参的模板。模板参数包用 省略号指定(如 class...、typename..。或 type-name...)
