
###### 9.1引言

在上一章我们已了解到进程之间具有关系。首先，每个进程有一个父进程（初始的内核级进 程通常是自己的父进程）。当子进程终止时，父进程得到通知并能取得子进程的退出状态。在 8.6 节说明 waitpid 函数时，我们也提到了进程组，以及如何等待进程组中的任意一个进程终止。

本章将更详细地说明进程组以及 POSIX.1引入的会话的概念。述将介绍登录 shell （登录时所 调用的）和所有从登录 shell 启动的进程之间的关系。

在说明这些关系时不可能不谈及信号，而讨论信号时又需要很多本章介绍的概念。如果你不 熟悉 UNIX 系统信号机制，则可能先要浏览一下第 10 章。

9.2终端登录

先说明当我们登录到 UNIX 系统时所执行的各个程序。在早期的 UNIX 系统（如 V7）中，用户用 哑终端（用硬连接连到主机）进行登录，终端或者是本:地的（直接连接）或者是雖的（通过调制解调

网器连接）。在这两种情况下，登录都经由内核中的终端设备驱动程序。例如，在 PDP-11上常用的设备是 DH-11和 DZ41。因为连到主机上的终端设备数是固定的，所以同时的登录数也就有了已知的上限。

随着位映射图形终端的出现，开发出了窗口系统，它向用户提供了与主机系统进行交互的新 方式。创建终端窗口的应用也被开发出来，它仿真了基于字符的终端，使得用户可以用熟悉的方 式（即通过 shell 命令行）与主机进行交互。

现今，某些平台允许用户在登录后启动一个窗口系统，而另一些平台则自动为用户启动窗口 系统。在后面一种情况中，用户可能仍然需要登录，这取决于窗口系统是如何配置的（某些窗口 系统可被配置成自动为用户登录）。

我们现在描述的过程用于经由终端登录至 UNIX 系统。孩过程几乎与所使用的终端类型无关，所 使用的终端可以是基于字符的终端、仿真基于字符终端的图形终端，或者运行窗口系统的图形终端。

\1. BSD终端登录

在过去 35 年中，BSD终端登录过程并没有多少改变。系统管理者创建通常名为/etc/ttys 的文件，其中，每个终端设备都有一行，每一行说明设备名和传到 getty 程序的参数。例如，其 中一个参数说明了终端的波特率等。当系统自举时，内核创建进程 ID 为 1 的进程，也就是 init 进程。init进程使系统进入多用户模式。init读取文件/etc/ttys，对每一个允许登录的终端 设备，init调用一次 fork，它所生成的子进程则 exec getty程序。选种情况示于图 9-1中。

图 9-1中所有进程的实际用户 ID 和有效用户 ID 都是 0 （也就是说，它们都具有超级用户特 权）。init以空环境 execgetty 程序。    [286]

getty对终端设备调用 open 函数，以读、写方式将终端打开。如果设备是调制解调器，则 open可能会在设备驱动程序中滞留，直到用户拨号调制解调器，并且线路被接通。一旦设备被打 开，则文件描述符 0、1、2就被设置到该设备。然后 getty 输出“login: ”之类的信息，并等 待用户键入用户名。如果终端支持多种速度，则 getty 可以测试特殊字符以便适当地更改终端速 度（波特率）。关于 getty 程序以及有关数据文件（gettytab）的细节，请参阅 UNIX 系统手册。

当用户键入了用户名后，getty的工作就完成了。然后它以类似于下列的方式调用 login 程序：

execle（"/bin/login", "login", "-p", username, （char *）0, envp）；

（在 gettytab 文件中可能会有一些选项使其调用其他程序，但系统默认是 login 程序）。init 以一个空环境调用 getty。getty以终端名（如 TERM=foo，其中终端 foo 的类型取自 gettytab 文件）和在 gettytab 中说明的环境字符串为 login 创建一个环境（envp参数）。-p标志通知 login保留传递给它的环境，也可将其他环境字符串加到该环境中，但是不要替换宏。图 9-2显 示了 login刚被调用后这些进程的状态。

进程 ID1

毎个终埔执行 —次 fork

I每个子进程 [exec getty



进程 ID1

读取/etc/ttys 卜个终嫩执行-次 fork J创建空环境

X

打开终端设备 （文件描述符 0,1、2）; '读用户名 初始环境集



图 9-1为允许终端登录，init调用的进程



图 9-2 login调用后进程的状态



因为最初的 init 进程具有超级用户特权，所以图 9-2中的所有进程都有超级用户特权。图 9-2中底部 3 个进程的进程 ID 相同，因为进程 ID 不会因执行 exec 而改吏。并且，除了最初的 init进程，所有进程的父进程 ID 均为 1。

login能处理多项工作。因为它得到了用户名，所以能调用 getpwnam 取得相应用户的口 令文件登录项。然后调用 getpaSS（3）以显示提示“Password: ”，接着读用户键入的口令（自 然，禁止回显用户键入的口令）。它调用 crypt（3）将用户键入的口令加密，并与该用户在阴影口岡 令文件中登录项的 pw_paSSwd字段相比较。如果用户几次键入的口令都无效，则 login 以参数 1调用 exit 表示登录过；程失败。父进程（init） 了解到子进程的终止情况后，将再次调用 fork, 其后又执行了 getty，对此终端重复上述过程。

这是 UNIX 系统传统的用户身份验证过程。现代 UNIX 系统已发展到支持多个身份验证过程。

例如，FreeBSD、Linux、Mac OS X 以及 Solaris 都支持被称为 PAM （Pluggable Authentication Modules，可插入的身份验证模块）的更加灵活的方案。PAM允许管理人员配置使用何种身份验 证方法来访问那些使用 PAM 库编写的服务。

如果应用程序需要验证用户是否具有适当的权限去执行某个服务，那么我们要么将身份验证 机制编写到应用中，要么使用 PAM 库得到同样的功能。使用 PAM 的优点是，管理员可以基于本 地策略、针对不同任务配置不同的验证用户身份的方法。

如果用户正确登录，login就将完成如下工作。

•将当前工作目录更改为该用户的起始目录(chdir)0

•调用 chown 更改该终端的所有权，使登录用户成为它的所有者。

•将对该终端设备的访问权限改变成"用户读和写”。

•调用 setgid 及 initgroups 设置进程的组 ID。

•用 login 得到的所有信息初始化环境：起始目录(HOME)、shell (SHELL)、用户名(USER 和 LOGNAME)以及一个系统默认路径(PATH)，

•    login进程更改为登录用户的用户 ID (setuid)并调用该用户的登录 shell，其方式类似于： execl("/bin/sh", "-sh", (char *)0);

|    argv[0]的第一个字符负号是一个标志，表示该 shell 被作为登录 shell 调用。shell可

|以査看此字符，并相应地修改其启动过程。

login程序实际所做的比上面说的要多。它可选择地打印日期消息(message-of-the-day)文 件、检査新邮件以及执行其他一些任务。本章中我们主要关心上面所说的功能。

回忆 8.11节中对 setuid 函数的讨论，因为 setuid 是由超级用户调用的，它更改所有 3 个用户 ID:实际用户江)、有效用户 ID 和保存的用户 ID 所有 3 个组 ID 也有同样效果。

login在较早时间调用的 setgid 对



进程 1D1

通过 getty 和 login

硬雜



至此，登录用户的登录 shell 开始运行。其父进程 ID是 init 进程(进程 ID1)，所以当此登录 shell 终止 时，init会得到通知(接到 SIGCHLD 信号)，它会对 该终端重复全部上述过程。登录 shell 的文件描述符 0、

[2881 1和 2 设置为终端设备。图 9-3显示了这种安排。

现在，登录 shell 读取其启动文件(Bourne shell 和 Korn shell 是.profile，GNU Boume-again shell 是.bash_profile、.bash_login 或.profile，

C shell是.cshrc和.login)。这些启动文件通常更 改某些环境变量并增加很多环境变量。例如，大多数 用户设置他们自己的 PATH 并常常提示实际终端类型 (TERM)。当执行完启动文件后，用户最后得到 shell 提示神，并能键入命令。    §

3 9-3终端登录完成各种设置后的进程安排



\2.    Mac OS X终端登录

Mac OS X部分地基于 FreeBSD，所以其终端登录进程与 BSD 终端登录进程的工作步骤基本

相同。但是，Mac OS X有些不同之处。

•    init的工作是由 launchd 完成的。

•    一开始提供的就是图形终端。

\3.    Linux终端登录

Linux的终端登录过程非常类似于 BSD。确实，Linux login命令是从 4.3BSD login命令

派生出来的。BSD登录过程与 Linux 登录过程的主要区别在于说明终端配置的方式。

在 System V的 init 文件格式之后，有些 Linux 发行版的 init 程序使用了管理文件方式。在|289|

这些系统中，/etc/inittab包含配置信息，指定了 init应当为之启动 getty 进程的各终端设备 其他 Linux 发行版本，如最近的 Ubuntu 发行版，配有称为“Upstart”的 init 程序。使用存

放在/etc/init目录的*.conf命名的配置文件。例如，运行/dev/ttyl上的 getty 需要的 说明可能放在/etc/init/ttyl .conf文件中。

根据所使用的 getty 版本的不同，终端的特征要么在命令行中说明（如 agetty），要么在 /etc/gettydefs 文件中说明（如 mgetty）。

\4. Solaris终端登录

Solaris支持两种形式的终端登录：（a） getty方式，这与前面对 BSD 终端登录的说明一样；

（b） ttymon登录，这是 SVR4 引入的一种新特性。通常，getty用于控制台，ttymon则用于 其他终端的登录。

ttymon命令是服务讲问设施（Service Access Facility» SAF）的一部分。SAF的目的是用一 致的方式对提供系统访问的服务进行管理（关于 SAF 的详细信息可以参见 Rago[1993]的第 6 章）。

按照本书的宗旨，我们只简单说明从 init 到登录 shell 之间不同的工作步骤，最后结果与图 9-3 中所示相似。init是 sac （service access controller，服务 i 方问控制器）的父进程，sac调用 fork,

然后，当系统进入多用户状态时，其子进程执行 ttymcm 程序。ttymon监控在配置文件中列出 的所有终端端口，当用户键入登录名时，它调用一次 fork。在此之后 ttymon 的子进程执行 login，它向用户发出提示，要求输入口令字。一旦完成这一处理，login执行登录用户的登录 shell，于是到达了图 9-3中所示的位置。一个区别是用户登录 shell 的父进程现在是 ttymon，而 在 getty 登录中，登录 shell 的父进程是 init。

9.3网络登录

通过串行终端登录至系统和经由网络登录至系统两者之间的主要（物理上的）区别是：网络 登录时，在终端和计算机之间的连接不再是点到点的。在网络登录情况下，login仅仅是一种可 用的服务，这与其他网络服务（如 FTP 或 SMTP）的性质相同。

在上节所述的终端登录中，init知道哪些终端设备可用来进行登录，并为每个设备生成一 个 getty 进程。但是，对网络登录情况则有所不同，所有登录都经由内核的网络接口驱动程 序（如以太网驱动程序），而且事先并不知道将会有多少这样的登录。因此必须等待一个网络连 接请求的到达，而不是使一个进程等待每一个可能的登录。

为使同一个软件既能处理终端登录，又能处理网络登录，系统使用了一种称为伪终端（pseudo terminal）的软件驱动程序，它仿真串行终端的运行行为，并将终端操作映射为网络操作，反之亦 然，（在第 19 章，我们将详细说明伪终端。）    [290]

\1. BSD网络登录

在 BSD 中，有一个 inetd 进程（有时称为因特网超级服务器），它等待大多数网络连接。本 节将说明 BSD 网络登录中所涉及的进程序列。关于这些进程的网络程序设计方面的细节请参阅 Stevens、Fenner 和 Rudoff p004]。

作为系统启动的一部分，init调用一个 shell，使其执行 shell 脚本/etc/rc。由此 shell 脚本启动 一个守护进程 inetd。一旦此 shell 脚本终止，inetd的父进程就变成 init。inetd等待 TCP/IP连

接请求到达主机，而当一个连接请求到达时，它扶行一次 fork，然后生成的子进程 exec 适当的程序。 假定一个对于 TELNET 服务进程的 TCP 连接请求到达。TELNET是使用 TCP 协议的远程登

录应用程序。在另一台主机（它通过某种形式的网络与服务进程主机相连接）上的用户，或在同 一个主机上的一个用户启动 TELNET 客户进程，由此启动登录过程：

telnet hostname

该客户进程打开一个到 hostname 主机的 TCP 连接，在 hostname 主机上启动的程序被称为 TELNET 服务进程，然后，客户进程和服务进程之间使用 TELNET 应用协议通过 TCP 连接交换数据。启动客 户进程的用户现在登录到了服务进程所在的主机（当然，假定用户在服务进程主机上有一个有效的账 号）。图 94 显示了在执行 TELNET 服务进程（称为 telnetd）中所涉及的进程序列。

进程 ID1

"I系统出现多用户时，

\> /bin/sh 中的 fork/exec,

J执行 shell 脚本 etc/rc

1从 TELP4ET 客户进程来 J的连接请求剎达时



进程 ID1

I 通过 inetd, telnetd, 广和 login

通过 telnetd 脤务和 \ telnet客户的网络链接



网    图 9~4执行 TELNET 服务进程时调用的进程序列

然后，telnetd进程打开一个伪终端设备，并用 fork 分成两个进程。父进程处理通过网络 连接的通信，子进程则执行 login 程序。父进程和子进程通过伪终端相连接。在调用 exec 之前， 子进程使其文件描述符 0、1、2与伪终端相连。如果登

录正确，login就执行 9.2节中所述的同样步骤-更

改当前工作目录为起始目录、设置登录用户的组 ID、

用户 ID 以及初始环境。然后 login 调用 exec 将其 自身替换为登录用户的登录 shell。图 9-5显示了到达 这一点时的进程安排。

很明显，在伪终端设备驱动程序和实际终端用户之 间进行了很多工作。第 19 章详细说明伪终端时，我们 将介绍与这种安排相关的所有进程。

需要理解的重点是：当通过终端（见图 9-3）或网 络（见图 9-5）登录时，我们得到一个登录 shell，其标 准输入、标淮输出和标准错误要么连接到一个终端设 备，要么连接到一个伪终端设备上。在后面几节中我们 会了解到这一登录 shell 是一个 POSIX.1会话的开始，

而此终端或伪终端则是会话的接制终端。

图 9-5网络登录完成各种设置后的进程安排



\2. Mac OS X网络登录

Mac OS X是部分地基于 FreeBSD 的，所以其网络登录与 BSD 网络登录基本相同。但 Mac OS X上 telnet 守护进程是从 launchd 运行的。    |292|

telnet守护进程在 Mac OS X中默认是禁用的(虽然可以通过 launchctl(l)命令启用)。

Mac OS X上执行网络登录的更好办法是用使 ssh (安全 shell 命令)。

\3.    Linux网络登录

除了有些版本使用扩展的因特网服务守护进程 xinetd 代替 inetd 进程外，Linux网络登录 的其他方面与 BSD 网络登录相同。xinetd进程对它所启动的各种服务的控制比 inetd 提供的 控制更加精细。

\4.    Solaris网络登录

Solaris中网络登录的工作过程与 BSD 和 Linux 中的步骤几乎一样。同样使用了类似于 BSD 版的 inetd 服务进程，但是在 Solaris 中，inetd服务进程在服务管理设施(Service Management Facility» SMF>下作为 restarter 运行。这个 restarter 是守护进程，它负责启动和监视其他守护进 程，如果其他守护进程失败的话，restarter重启这些失效进程。虽然 inetd 服务程序由 SMF 中 的主 restarter 启动，但实际上主 restartei■是由 init 程序启动的，最后得到的结果与图 9-5中一样。

Solaris服务管理设施是管理和监视系统服务的框架’提供了一种从影响系统服务的故障中恢复的 ；速径。关于服务管理设施的更多内容，可参阅 AdarasP005]以及 Solaris 系统手册 smf(5)和 inetd(lM)。

###### 9.4进程组

每个进程除了有一进程 ID 之外，还属于一个进程组，第 10 章讨抢信号时还会涉及进程组。

进程组是一个或多个进程的集合。通常，它们是在同一作业中结合起来的(9.8节将详细讨 论作业控制)，同一进程组中的各进程接收来自同一终端的各种信号。每个进程组有一个唯一的 进程组 ID。进程组 ID 类似于进程 ID_它是一个正整数，并可存放在 pid_t数据类型中。函 数 getpgrp 返回调用进程的进程组 ID。

| #include <unistd.h>     |                            |
| ----------------------- | -------------------------- |
| pid_t getpgrp (void)，- | 返回值：调用进程的进程组 ID |

在早期 BSD 派生的系统中，垓函数的参数是 pW，返回该进程的进程组 ID。Single UNIX Specification定义了 getpgid函数模仿此种运行行为。    [2511

\#include <unistd.h>

pid_t getpgid (pid_t pid);

返回值：若成功，返回进程组 ID；若出错，返回-1

若 pid 是 0，返回调用进程的进程组 ID，于是， getpgid(0>;

等价于

getpgrp ()，-

每个进程组有一个组长进程。组长进程的进程组 ID 等于其进程 ID。

进程组组长可以创建一个进程组、创建该组中的进程，然后终止。只要在某个进程组中有一

个进程存在，则该进程组就存在，这与其组长进程是否终止无关。从进程组创建开始到其中最后 一个进程离开为止的时间区间称为进程组的生命期。某个进程组中的最后一个进程可以终止，也 可以转移到另一个进程组。

进程调用 setpgid 可以加入一个现有的进程组或者创建一个新进程组（下一节中将说明用 setsid也可以创建一个新的进程组）。

♦include <unistd.h>

int setpgid (pid_t pid, pid_t pgid);

返回值：若成功，返回 0；若出错。返回-1

setpgid函数将/wW进程的进程组 ID 设置为 pg/c/。如果这两个参数相等，则由 p/t/指定的 进程变成进程组组长。如果 pit/是 0，则使用调用者的进程 ID。另外，如果 pg 记是 0，则由 指定的进程 ID 用作进程组 ID。

—个进程只能为它自己或它的子进程设置进程组 Uh 在它的子进程调用了 exec后，它就不 再更改该子进程的进程组 ID。

在大多数作业授制 shell 中，在 fork 之后调用此函数，使父进程设置其子进程的进程组 ID， 并且也使子进程设置其自己的进程组这两个调用中有一个是冗余的，但让父进程和子进程都 这样做可以保证，在父进程和子进程认为子进程已进入了该进程组之前，这确实已经发生了。如 果不这样做，在 fork 之后，由于父进程和子进程运行的先后次序不确定，会因为子进程的组员 身份取决于哪个进程首先执行而产生竞争条件。

在讨论信号时，将说明如何将一个信号发送给一个进程（由其进程 ID 标识）或发送给一个 进程组（由进程组 ID 标识）。类似地，8.6节的 waitpid 函数可被用来等待一个进程或者指定进

[294]程组中的一个进程终止。

###### 9-5会话

会话（session）是一个或多个进程组的集合。例如，可以具有图 9-6中所示的安排 D 其中， 在一个会话中有 3 个进程组。

登录 shell



进程组



|       |      |       |
| ----- | ---- | ----- |
| procl |      | proc2 |
|       |      |       |

进程组



proc3



proc4



proc5

进程组

会话

图 9-6进程组和会话中的进程安排

通常是由 shell 的管道将几个进程编成一组的，例如，图 9-6中的安排可能是由下列形式的 shell

命令形成的:

procl I proc2 &

proc3 I proc4 | proc5

进程调用 setsid 函数建立一个新会话，

\#include <unistd.h> pid_t setsid(void);

返回值：若成功，返回进程组 ID:若出错，返回-1

如果调用此函数的进程不是一 4^程组的粗投，则此函数创建一个新会话。具体会发生以下 3 件事。

(1)    该进程变成新会话的会话首进程(sessionleader，会话首进程是创建该会话的进程)。此 时，该进程是新会话中的唯一进程。

(2)    该进程成为一个新进程组的组长进程。新进程组 ID 是该调用进程的进程江)。

(3)    该进程没有控制终端(下一节讨论控制终端)。如果在调用 setsid 之前该进程有一个 控制终端，那么这种联系也被切断。

如果该调用进程已经是一个进程组的组长，则此函数返回出错。为了保证不处于这种情况，通 常先调用 fork，然后使其父进程终止，而子进程则继续。因为子进程继承了父进程的进程组 ID， 而其进程 ID 则是新分配的，两者不可能相等，这就保证了子进程不是一个进程组的组长。

Single UNIX Specification只说明了会话首进程，而没有类似于进程 ID 和进程组 ID 的会话 ID。 显然，会话首进程是具有唯一进程 ID 的单个进程，所以可以将会话首进程的进程 ED 视为会话 UX 会话 ID 这一概念是由 SVR4 引入的。历史上，基于 BSD 的系统并不支持这个概念，但后来改弦 易辙也支持了会话 ID。getsid函数返回会话首进程的进程组 ID。

一些实现(如 Solaris)与 Single UNIX Specification保持一致，在实践中避免使用“会话 ID” 这一短语，而是将此称为“会话首进程的进租组 ro”D会话首进程总是一个进程组的组长进程， 所以两者是等价的。

\#include <unistd.h> pid_t getsid (pid_t pid);

返回值：若成功，返回会话首进程的进程组 ID:若出错，返回-1

如若 pW 是 0, getsid返回调用进程的会话首进程的进程组 ED。出于安全方面的考虑，一 些实现有如下限制：如若 p 记并不属于调用者所在的会话，那么调用进程就不能得到该会话首进 程的进程组 ID。

9.6控制终端

会话和进程组还有一些其他特性。

•—个会话可以有一个控制终端(controlling terminal)o这通常是终端设备(在终端登录情 况下)或伪终端设备(在网络登录情况下)。

•建立与控制终端连接的会话首进程被称为控制进程(controllingprocess)。

•—个会话中的几个进程组可被好成一个前台进租组(foreground process group)以及一个 或多个后台进程组(background process group)。

•如果一个会话有一个控制终端，则它有一个前台进程组，其他进程组为后台进程组》

•无铪何时键入终端的中断键（常常是 Delete 或 Ctrl+C），都会将中断信号发送至前台进程

组的所有进程。

。无论何时键入终端的退出键（常常是 Ctrl+\），都会将退出信号发送至前台进程组的所有进程。 •如果终端接口检测到调制解调器（或网络）己经断开连接，则将挂断信号发送至控制进

程（会话首进程）。

这些特性示于图 9-7中。

会话

proc5



![img](UNIXaf83d8a7160b-35.png)



|           | niii | rIii  |       |       |      | niii | riiI |      |      |      |
| --------- | ---- | ----- | ----- | ----- | ---- | ---- | ---- | ---- | ---- | ---- |
| 登录 shell | prod | proc2 | proc3 | proc4 |      |      |      |      |      |      |
|           |      | L     |       |       |      |      | i    |      |      |      |

后台进程组

会话首进程=控射进程

后台进程组



通常，我们不必担心控制终端，登录时，将自动建立控制终端。

1 P0SIX.1将如何分配一个控制终端的机制交给具体实现来选择。19.4节中将说明实际步骤。

当会话首进程打开第一个尚未与一个会话相关联的终端设备时，只要在调用 open 时没有指

；定 O_NOCTTY括志（见 3.3节），System V派生的系统将此作为控制终端分配给此会话。

! 当会话首进程用 TIOCSCTTY 作为叫 wesf 参数（第三个参教是空指针）裯用 ioctl 时，基于 BSD

|2两



的系统为会话分配控制终祺。为使此调用成功执行，此会话不能已经有一个控制终端（通常 ioctl 调 !用紧银在 setsid 调用之后，setsid保证此进程是一个没有控制终端的会诺首进租）。除了以兼容模 i式支持其他系统以外，基于 BSD 的系统不使用 POSIX.1中对 open 函教所说明的 O_NOCTTY标志。 i    图 9-8总结了本书讨论的 4 个平台分&控制终端的方式。注意，虽然 Mac OS X 10.6.8是从

! BSD派生出来的。但其分配控制终梂的方式如同 System V。

| 方    法                                    | FreeBSD 8.0 | Linux 3.2.0 | Mac OS X 10.6.8 | Solaris 10 |
| ------------------------------------------- | ----------- | ----------- | --------------- | ---------- |
| 没有指定 O_NOCTTY的 open TIOCSCTTY ioctl 命令 |             |             | •               | •          |

图 9-8不同的实现分配控制终端的方式

有时不管标准输入、标准输出是否重定向，程序都要与控制终端交互作用。保证程序能与控 制终端对话的方法是 open 文件/dev/tty，在内核中，此特殊文件是控制终端的同义语。自然

地，如果程序没有控制终端，则对于此设备的 open 将失败。

典型的例子是用于读口令的 getpaSS(3)函数(终端回显被关闭)。这一函数由 crypt⑴程

序调用，并可用于管道中。例如： crypt < salaries ( Ipr

将文件 salaries 解密，然后经由管道将输出送至打印缓冲服务程序。因为 crypt 从其标准 输入读输入文件，所以标准输入不能用于输入口令。而且，crypt经过了设计，因此每次运行 此程序时都应输入加密口令，这样也就阻止了用户将口令存放在文件中(这会造成安全性漏洞)。

已经知道有一些方法可以破译 crypt 程序使用的密码。关于加密文件的详细情况请参见 Garfinkel 等[2003]。

##### 9.7 函数 tcgetpgrp、tcsetpgrp 和 tcgetsid

需要有一种方法来通知内核哪一个进程组是前台进程组，这样，终端设备驱动程序就能知道 将终端输入和终端产生的信号发送到何处(见图 9-7)。

\#include <unistd.h>

pid_t tcgetpgrp (int fd};

返回值：若成功，返回前台进程组 ID:若出错，返回-1

int tcsetpgrp (int fd, pid_t pgrpid);

返回值：若成功，返回 0；若出错，返回-1

函数 tcgetpgrp 返回前台进程组 ID，它与在片上打开的终端相关联。

如果进程有一个控制终端，则该进程可以调用 tcsetpgrp 将前台进程组 ID 设置为 pgrpid。

pgrp记值应当是在同一会话中的一个进程组的 ID。仲必须引用该会话的控制终端。    [298]

大多数应用程序并不直接调用这两个函数。它们通常由作业控制 shell 调用。

给出控制 TTY 的文件描述符，通过 tcgetsid 函数，应用程序就能获得会话首进程的进程

组 ID。

\#include <termios.h> pid_t tcgetsid (int fd);

返回值：若成功，返回会话首进程的进程组 ID；若出错，返回-1

需要管理控制终端的应用程序可以调用 tcgetsid 函数识别出控制终端的会话首进程的会 话 ID (它等价于会话首进程的进程组 ID)。

9.8作业控制

作业搜制是 BSD 在 1980 年左右增加的一个特性。它允许在一个终端上启动多个作业(进程组)， 它控制哪一个作业可以访问该终端以及哪些作业在后台运行。作业控制要求以下 3 种形式的支持。

(1)    支持作业控制的 shell。

(2)    内核中的终端驱动程序必须支持作业控制。

(3)    内核必须提供対某些作业控制信号的支持。

；    SVR3提供了一种不同的作业控制，称为 shell 层（sheUlayer）。但是 POSIXJ 选择了 BSD形

式的作 I 控制，这也是我们在这里所说明的。POSIXJ的早期版本中，对作业控制的支持是可选 择的，现在则要求所有平台都支持它。

从 shell 使用作业控制功能的角度观察，用户可以在前台或后台启动一个作业。一个作业只是 几个进程的集合，通常是一个进程管道。例如：

vi main.c

在前台启动了只有一个进程组成的作业。下面的命令：

pr *.c I Ipr & make all &

在后台启动了两个作业。这两个后台作业调用的所有进程都在后台运行。

如前所述，我们需要一个支持作业控制的 shell 以使用由作业控制提供的功能。对于早期的系

统，shell是否支持作业控制比较易于说明。C shell支持作业控制，Bourne shell不支持，而 Komshell 能否支持作业控制取决于主机是否支持作业控制。但是现在 C shell已被移植到并不支持作业控制的 系统上（如 System V的早期版本），而当用名字 j sh而不是用 sh 调用 SVR4 中的 Bourne shell时，

|299|它支持作业授制。如果主机支持作业接制，则 Kom shell继续支持作业控制。Boume-again shell也 支持作业控制。各种 shell 之间的差别无关紧要时，我们将只是一般地说明支持作业控制的曲 ell 和 不支持作业控制的 shell。

当启动一个后台作业时，shell赋予它一个作业标识符，并打印一个或多个进程 ID。下面的脚 本显示了 Kom shell是如何处理送一点的。

$ make all > Hake.out &

[1]    1475

$ pr *.e I lpr &

[2]    1490

S    键入回车

[2] + Done    pr *.c I Ipr &

[1] + Done    make all > Make.out &

make是作业编号 1，所启动的进程 ID 是 1475。下一个管道是柞业编号 2，其第一个进程的进程 ID 是 1490。当作业完成而且键入回车时，shell通知作业已经完成。键入回车是为了让 shell 打印其提示 符。shell并不在任意时刻打印后台作业的状态改变一它只在打印其提示符让用户输入新的命令行之 前才这样做<> 如果不这样处理’则当我们正输入一行时，它也可能输出，于是’就会引起混乱。

我们可以键入一个影响前台作业的特殊字符——挂起键（通常采用 Ctrl+Z），与终端驱动程 序进行交互作用。键入此字符使终端驱动程序将信号 SIGTSTP 发送至前台进程组中的所有进程， 后台进程组作业则不受影响。实际上有 3 个特殊字符可使终端驱动程序产生信号，并将它们发送 至前台进程组，它们是：

•中断字符（一般采用 Delete 或 Ctri+C）产生 SIGINT:

•退出字符（一般采用 Ctrl+\）产生 SIGQUIT;

•挂起字符（一般采用 Ctrl+Z）产生 SIGTSTP。

第 18 章中将说明可将这 3 个字符更改为用户选择的任意其他字符，以及如何使终端驱动程 序不处理这些特殊字符。

终端驱动程序必须处理与作业控制有关的另一种情况。我们可以有一个前台作业，若干个后台作

业，这些作业中哪一个接收我们在终端上键入的字符呢？只有前台作业接收终端输入。如果后台作业 试图读终端，这并不是一个错误，但是终端驱动程序将检测这种情况，并且向后台作业发涯一个特定 信号 SIGTTIN。该信号通常会停止此后台作业，而 shell 则向有关用户发出这种情况的通知，然后用 户就可用 shell 命令将此作业转为前台作业运行，于是它就可读终端。下列操作过程显示了这一点：

$ cat > teo^>.foo 6

[1] 1681

$

[1] + Stopped (SIGTTIN)

$ fg %1

cat > temp.foo

hallo, wocld

AD

$ cat tan^. foo

hello, world



在后台启动，但将从标准输入谈

键入回车

cat > temp.foo &

使 I 号作业成为前台作业

shell告诉我们现在哪一个作业在前台

输入一行

键入文件结束符

检査该行已送入文件

j 注意，这个例子在 MacOSX 10.6.8上不起作用。在试图把 cat 命令放到前台时，read返回 1失败，并将 errno 设为 EINTR。Mac OS X是基于 FreeBSD 的，在 FreeBSD 下本例运行良好，

S因此这应该是 Mac OS X的一个 bug。

shell在后台启动 cat 进程，但是当 cat 试图读其标准输入（控制终端）时，终端驱动程序 知道它是个后台作业，于是将 SIGTTIN 信号送至该后台作业。shell检测到其子进程的状态改变 （回忆 8.6节中对 wait 和 waitpid 函数的讨论），并通知我们该作业已被停止。然后，我们用 shell的 fg 命令将此停止的作业送入前台运行（关于作业搜制命令，如 fg 和 bg 的详细情况，以 及标识不同作业的各种方法请参阅有关 shell 的手册页）。这样做使 shell 将此作业转为前台进程组 （tcsetpgrp），并将继续信号（SIGCONT）送给该进程组。因为该作业现在前台进程组中，所 以它可以读控制终端。

如果后台作业输出到控制终端又将发生什么呢？这是一个我们可以允许或禁止的选项。通 常，可以用 stty（l）命令改变这一选项（第 18 章将说明在程序中如何改变这一选项）。下面显示 了这种操作过程：

在后台执行



$ cat teap.foo &

[1]    1719

$ hello, world

[1] + Done    cat

$ stty tostop $ cat tantp. foo &

[1]    1721

$



提示符后出现后台作业的输出 键入回车

temp.foo &

禁止后台作业输出至控制终端 在后台再试一次

键入回车，发现作业已停止

[1] + Stopped(SIGTTOU) $ fg %1 cat temp.foo hello, world



cat temp.foo &

在前台恢复停止的作业

shell告诉我们现在哪一个作业在前台

这是该作业的输出

在用户禁止后台作业向控制终端写时，该作业的 cat 命令试图写其标谁输出，此时，终端驱动程 序识别出孩写操作来自于后台进程，于是向该作业发送 SIGTTOU 信号，cat进程阻塞。与上面 的例子一样，当用户使用 shell 的 fg 命令将该作业转为前台时，该作业继续执行直至完成。

图 9-9总结了前面已说明的作业控制的某些功能。穿过终端驱动程序框的实线表明终端 I/O

和终端产生的信号总是从前台进程组连接到实际终端。对应于 SIGTTOU 信号的虚线表明后台进 程组进程的输出是否出现在终端是可选择的。

init、inetd 或 launchd

会话

图 9-9对于前台、后台作业以及终端驱动程序的作业控制功能总结

是否需要作业控制是一个有争议的问题，作业控制是在窗口终端广泛得到应用之前设计和实现 的，很多人认为设计得好的窗口系统已经免除了对作业控制的需要。某些人抱怨作业控制的实现要求

[302]得到内核、终端驱动程序、shell以及某些应用程序的支持，是吃力不讨好的事情。某些人在窗口系统 中使用作 M 制，他们认为两者都需要。不管你的意见如何，作业控制都是 POSIX.1要求的部分。

##### 9.9 shell执行程序

让我们检验一下 shell 是如何执行程序的，以及这与进程组、控制终端和会话等概念的关系。 为此，再次使用 ps 命令。

首先使用不支持作业控制的、在 Solaris 上运行的经典 Bourne shell。如果执行:

ps -o pid,ppid,pgid,sid,comm 则其输出可能是：

| PID  | PPID | PGID | SID  | COMMAND |
| ---- | ---- | ---- | ---- | ------- |
| 949  | 947  | 949  | 949  | sh      |
| 1774 | 949  | 949  | 949  | ps      |

PS的父进程是 shell，这正是我们所期望的。shell和 ps 命令两者位于同一会话和前台进程组(949) 中。因为我们是用一个不支持作业接制的 shell 执行命令时得到读值的，所以称其为前台进程组。

某些平台支持一个选项，它使 ps(l)命令打印与会话控制终端相关联的进程组 ID。该值在 TPGID列中显示。遣憾的是，ps(l)命令的输出在各个 UNIX 版本中都有所不同。例如，Solaris 10 不支持该选项。在 FreeBSD 8.0、Linux 3.2.0 和 Mac OS X 10.6.8 中，命令

ps -o pid, ppid, pgid, sid, tpgid, comm

准确地打印我们想要的信息。

注意，将进程与终端进程组 ID(TPG【D列)关联起来有点用词不当。进程并没有终端进柱控制组。 进程属于一个进程组，而进程组属于一个会话。合话可能有也可能没有控制终端。如果它确实有 一个控制终瑞，则此终端设备知道其前台进程的进程组 ID。这一值可以用 tcsetpgrp 函数在终 端驱动程序中设置(见图 9-9)。前台进程组 ID 是终端的一个属性，而不是进粗的属性 D 取自终端 设备驱动程序的该值是 ps 在 TPGID 列中打印的值。如果 ps 发现此会话没有控制终端，则它在 该列打印 0 或者-1，具体值因不同平台而异。

如果在后台执行命令:

ps -o pid,ppid,pgid,sid,comm &

则唯一改变的值是命令的进程 ID:

PID PPID PGID SID COMMAND 949 947    949 949 sh

1812    949    949 949 ps    13Q31

因为这种 shell 不知道作业控制，所以没有将后台作业放入自己的进程组，也没有从后台作业处取 走控制终端。

现在看一看 Bourne shell如何处理管道。执行下列命令：

ps -o pid, ppid,pgid, sid, conun 1 catl 其输出是：

| PID  | PPID | PGID | SID  | COMMAND |
| ---- | ---- | ---- | ---- | ------- |
| 949  | 947  | 949  | 949  | sh      |
| 1823 | 949  | 949  | 949  | catl    |
| 1824 | 1823 | 949  | 949  | ps      |

(程序 catl 是标准 cat 程序的一个副本，只是名字不同。本节还将使用 cat 的另一个名为 cat2 的副本。在一个管道中使用两个 cat 副本时，不同的名字可使我们将它们区分开来。)注意，管道 中的最后一个进程是 shell 的子进程，该管道中的第一个进程则是最后一个进程的子进程。从中可 以看出，shell fork—个它自身的副本，然后此副本再为管道中的每条命令各 fork—个进程。

如果在后台执行此管道： ps -o pid,ppid,pgid,sid,comm | catl &

则只改变进程 ID。因为 shell 并不处理作业控制，后台进程的进程组 ID 仍是 949，如同会话的进 程组 ID—样。

如果一个后台进程试图读其控制终端，则会发生什么呢？例如，若执行： cat > terap.foo &

在有作业控制时，后台作业被放在后台进程组，如果后台作业试图读控制终端，则会产生信号 SIGTTIN。在没有作业控制时，其处理方法是：如果该进程自己没有重定向标准输入，则 Shell 自动将后台进程的标准输入重定向到/dev/null»读/dev/null则产生一个文件结束。送就意 味着后台 cat 进程立即读到文件尾，并正常终止。

前面说明了对后台进程通过其标准输入访问控制终端的适当的处理方法，但是，如果一个后 台进程打开/dev/tty并且读该控制终端，又将怎样呢？对此问题的回答是“看情况”。但是这 很可能不是我们所期望的。例如：

crypt < salaries I lpr &

就是这样的一条管道。我们在后台运行它，但是 crypt 程序打开/dev/tty，更改终端的特性（禁 止回显），然后从该设备读，最后重置该终端特性。当执行这条后台管道时，crypt在终端上打印提

13041示符“Password: "，但是 shell 读取了我们所输入的加密口令，并试图执行以加密口令为名称的命 令。我们输送给 shell 的下一行则被 crypt 进程取为口令行，于是 salaries 也就不能正确地被译 码，结果将一堆无用的信息送到了打印机。在这里，我们有了两个进程，它们试图同时读同一设备， 其结果则依赖于系统。前面说明的作业控制以较好的方式处理一个终端在多个进程间的转接。

返回到 Bourne shell实例，在一条管道中执行 3 个进程，我们可以检验 Bourne shell使用的进 程控制方式：

ps -o pid,ppid,pgid,sid,comm I catl I cat2 其输出为：

| PID  | PPID | PGID | SID  | COMMAND |
| ---- | ---- | ---- | ---- | ------- |
| 949  | 947  | 949  | 949  | sh      |
| 198B | 949  | 949  | 949  | cat2    |
| 1989 | 1988 | 949  | 949  | ps      |
| 1990 | 1988 | 949  | 949  | catl    |

如果在你的系统上，输出的命令名不正确，那也不必为此感到惊慌。有时可能会得到类似如

| 下的输出：           |                                                              |      |      |         |
| -------------------- | ------------------------------------------------------------ | ---- | ---- | ------- |
| PID                  | PPID !                                                       | ?GID | SID  | COMMAND |
| 949                  | 947                                                          | 949  | 949  | sh      |
| 1831                 | 949                                                          | 949  | 949  | sh      |
| 1832                 | 1831                                                         | 949  | 949  | ps      |
| 1833                 | 1831                                                         | 949  | 949  | sh      |
| 造成此种结果的原因是 | ,ps进程与 shell 产生竞争条件，shell创建一个子进程并由它执行 cat 命 |      |      |         |

1令。在这种情况下，当 ps 已经获得进稼列表并打印时，shell尚未完成 exec 调用。

再重申一遍，该管道中的最后一个进程是 shell 的子进程，而执行管道中其他命令的进程则是

该最后进程的子进程。图 9-10显示了所发生的情况。因为该管道线中的最后一个进程是登录 shell 的子进程，当该进程（cat2）终止时，shell得到通知。

图 9-10 Bourne shell 执行管道 ps | catl） cat2 时的进程    |305|

现在让我们用一个垣行在 Linux 上的作业控制 shell 来检验同一个例子。这将显示这些 shell

处瑾后台作业的方法。在本例中将使用 Boume-again shell，用其他作业控制 shell 得到的结果几乎 是一样的。

ps -o pid,ppid,pgid,sid,tpgid,comm 其输出为：

PID PFID PGID SID TPGID COMMAND 2837 2818 2837 2837 5796 bash

5796    2837 5796 2837 5796 ps

（从本例开始，以粗体显示前台进程组。）我们立即看到了与 Bourne shell例子的区别。Boume-again shell将前台作业（ps）放入了它自己的进程组（5796）。ps命令是进程组组长进程，也是该进程 组的唯一进程。进一步而言，此进程组具有控制终端，所以它是前台进程组。我们的登录 shell 在执行 ps 命令时是后台进程组。但需要注意的是，这两个进程组 2837 和 5796 都是同一会话的 成员。事实上，在本节的各实例中，会话决不会改变。

在后台执行此进程：

ps -o pid,ppid,pgid,sid,tpgid,comm &

其输出为：

PID PPID PGID SID TPGID COMMAND 2837 2818 2837 2837 2837 bash

5797    2837 5797 2837 2837 ps

再一次，Ps命令被放入它自己的进程组，但是此时进程组（5797）不再是前台进程组，而是一个 后台进程组。TPGID 2837指示前台进程组是登录 shell。

按下列方式在一个管道中执行两个进程： ps -o pid,ppid,pgid,sid,tpgid,comm | catl

其输出为：

| PID  | PPID | PGID | SID  | TPGID | COMMAND |
| ---- | ---- | ---- | ---- | ----- | ------- |
| 2837 | 2818 | 2637 | 2837 | 5799  | bash    |
| 5799 | 2837 | 5799 | 2837 | 5799  | ps      |
| 5800 | 2837 | 5799 | 2837 | 5799  | catl    |

两个进程 ps 和 catl 都在一个新进程组（5799）中，这是一个前台进程组。在本例和类似的 Bourne shell实例之间能看到另一个区别。Bourne shell首先创建将执行管道中最后一条命令的进程，而 此进程是第一个进程的父进程。在这里，Boume-again shell是两个进程的父进程。但是，如果在

[306]后台执行此管道：

ps -o pid, ppid,pgid, sid, tpgid, conun I catl &

其结果是类似的，但是 ps 和 catl 现在都处于同一后台进程组 a

| PID  | PPID | PGID | SID  | TPGID | COMMAND |
| ---- | ---- | ---- | ---- | ----- | ------- |
| 2837 | 2818 | 2837 | 2837 | 2837  | bash    |
| 5801 | 2837 | 5801 | 2837 | 2837  | ps      |
| 5802 | 2837 | 5801 | 2837 | 2837  | catl    |

注意，使用的 shell 不同，创建各个进程的顺序也可能不同。

9.10孤儿进程组

我们曾提及，一个其父进程已终止的进程称为孤儿进程（orphanprocess），这种进程由 init 进程“收养”。现在我们要说明整个进程组也可成为“孤儿”，以及 POSIX.1如何处理它。

、实例

考虑一个进程，它 fork 了一个子进程然后终止。这在系 统中是经常发生的，并无异常之处，但是在父进程终止时， 如果该子进程停止（用作业控制）又将如何呢？子进程如何 继续，以及子进程是否知道它已经是孤儿进程？图 9-11显示 了这种情形：父进程已经 fork 了子进程，该子进程停止，父 进程则将退出。

构成此种情形的程序示于图 9-12中。下面要说明该程序 的某些新特性。这里，假定使用了一个作业控制 shell。回忆 前面所述，shell将前台进程放在它（指前台进程）自己的进

[307]程组中（本例中是 6099），shell则留在自己的进程组内（2837）。 子进程继承其父进程（6099）的进程组。在 fork 之后：

•父进程睡眠 5 秒，这是一种让子进程在父进程终止之 前运行的一种权宜之计。



会话



进程组 2837

进程组 6099



图 9-11将要成为孤儿的进程组实例



•子进程为挂断信号（SIGHUP）建立信号处理程序，这样就能观察到 SIGHUP 信号是否己



发送给子进程。（第 10 章将讨论信号处理程序。）

•子进程用 kill 函数向其自身发送停止信号（SIGTSTP）。这将停止子进程，类似于用终



端挂起字符（Ctrl+Z）停止一个前台作业。

•当父进程终止时，该子进程成为孤儿进程，所以其父进程 ID 成为 1，也就是 init 进程 ID。



•现在，子进程成力一个孤儿进程组的成员。POSIX.1将孤儿进程组(orphaned process group) 定义为：孩组中每个成员的父进程要么是孩组的一个成员，要么不是该组所属会话的成 员。对孤儿进程组的另一种描述可以是：一个进程组不是孤儿进程组的条件是——镇组 中有一个进程，其父进程在属于同一会话的另一个组中。如果进程组不是孤儿进程组， 那么在属于同一会话的另一个组中的父进程就有机会重新启动孩组中停止的进程。在这 里，进程组中每一个进程的父进程(例如，进程 6100 的父进程是进程 1)都属于另一个 会话。所以此进程组是孤儿进程组。

•因为在父进程终止后，进程组包含一个停止的进程，进程组成为孤儿进程组，POSIX.1 要求向新孤儿进程组中处于停止状态的每一个进程发送挂断信号(SIGHUP)，接着又向 其发迭继续信号(SIGCONT)。

•在处理了挂断信号后，子进程继续。对挂断信号的系统默认动作是终止孩进程，为此必 须提供一个信号处理程序以捕捉该信号。因此，我们期望 sig_hUp函数中的 printf 会 在 pr_ids函数中的 printf 之前执行。

\# include "apue.h"

\#include <errno.h>

static void

sig_hup(int signo)

{

printf("SIGHUP received, pid = %ld\n", (long)getpid());

}

static void

pr_ids{char *name)

f

printf("%s： pid = %ld, ppid = %ld, pgrp = %ld, tpgrp = %ld\n", name, (long) getpid{), (long) getppid{), (long)getpgrpt),

{long)tcgetpgrp(STDIN_FILENO));

fflush(stdout)；

int

main(void)

{

char    c;

pid_t    pid;

pr_ids("parent");

if ((pid = fork ()) < 0) {

err_sys("fork error");

} else if (pid >0) { /* parent */

sleep (5);    /* sleep to let child stop itself */

} else {    /* child */

pr_ids("child");

signal(SIGHUP, sig_hup);    /* establish signal handler */

kill(getpid(), SIGTSTP);    /* stop ourself */

pr_ids("child");    /* prints only if we're continued */

if (read(STDIN_FILENO, &c, 1)    != 1)

printf("read error %d on controlling TTY\n", errno);

}

exit(O);

图 9-12创建一个孤儿进程组

下面是图 9-12中的程序的输出：

$ .Za.out

parent: pid = 6099, ppid = 2837, pgrp = 6099, tpgrp = 6099 child: pid = 6100, ppid = 6099, pgrp = 6099, tpgrp = 6099 $ SIGHUP received, pid = 6100

child: pid = 6100, ppid = 1, pgrp = 6099, tpgrp = 2837 read error 5 on controlling TTY

注意，因为两个进程，登录 shell 和子进程都写向终端，所以 shell 提示符和子进程的输出一 起出现。正如我们所期望的那样，子进程的父进程 ID 变成 1。

在子进程中调用 pr_ids后，程序企图读标准输入。如前所述，当后台进程组试图读控制终 端时，对该后台进程组产生 SIGTTIN。但在这里，这是一个孤儿进程组，如果内核用此信号停止 它，则此进程组中的进程就再也不会继续》POSIX.1规定，read返回出错，其 errno 设置为 EIO （在本书所用的系统中其值是 5）。

最后，要注意的是父进程终止时，子进程变成后台进程组，因为父进程是由 shell 作为前台 f 3081业执行的。

3091    在 19.5节的 pty 程序中将会看到孤儿进程组的另一个例子。

##### 9.11 FreeBSD 实现

前面说明了进程、进程组、会话和控制终端的各种属性，值得观察一下所有这些是如何实现 的。下面简要说明 FreeBSD 中的实现。SVR4实现的某些详细情况则请参阅 WiniamS[1989]。 图 9-13显示了 FreeBSD使用的各种有关数据结构，

下面从 session 结构开始说明图中标出的各个字段》每个会话都分配一个 session 结构（例 如，每次调用 setsid 时）。

岡 • S_COUnt是该会话中的进程组数。当此计数器减至 0 时，则可释放此结构。

•    s_leader是指向会话首进程 proc 结构的指针。

•    s_ttyvp是指向接制终端 vnode 结构的指针。

•    s_ttyp是指向控制终端 tty 结构的指针。

•    s_sid是会话 ID。请记住会话 ID 这一概念并非 Single UNIX Specification的组成部分。

在调用 setsid 时，在内核中分配一个新的 session 结构。s_count设置为 1，s_leader

设置为调用进程 proc 结构的指针，s_sid设置为进程 ID，因为新会话没有控制终端，所以 s_ttyvp和 s_ttyp设置为空指针。

接着说明 tty 结构。每个终端设备和每个伪终端设备均在内核中分配这样一种结构（第 19 章将对伪终端做更多说明），

•    t_session指向将此终端作为授制终端的 session 结构（注意，tty结构指向 session 结构，session结构也指向 tty 结构）。终端在失去载波信号时使用此指针将挂起信号 发选给会话首进程（见图 9-7）。

•    t_PgrP指向前台进程组的 pgrp 结构。终端驱动程序用此字段将信号发送给前台进程组。

由输入特殊字符（中断、退出和挂起）而产生的 3 个信号被发送至前台进程组。

•    t_termiOS是包含所有这些特殊字符和与该终端有关信息（如波特率、回显打开或关闭 等）的结掏。第 18 章将再说明此结构。

•    t_winsize是包含终端窗口当前大小的 winsize 型结构。当终端窗口大小改变时，信 号 SIGWINCH 被发送至前台进程组，18.12节将说明如何设置和获取终端当前窗口大小。

为了找到特定会话的前台进程组，内核从 session 结构开始，然后用 S_ttyp得到控制终 端的 tty 结构，再用 t_pgrp得到前台进程组的 pgrp 结构。

pgrp结构包含一个特定进程组的信息。其中各相关字段具体如下。

•    pg_id是进程组 ID。

•    pg_session指向此进程组所属会话的 session 结构。

•    pg_members是指向此进程组 proc 结构表的指针，读 proc 结构代表进程组的成员。

proc结构中 p_pglist结构是双向链表，指向该组中的下一个进程和上一个进程。直到 遇到进程组中的最后一个进程，它的 proc 结构中 p_pglist结构为空指针。    [jH]

proc结钩包含一个进程的所有信息。

•    p_pid包含进程 ID。

•    p_pptr是指向父进程 proc 结构的指针。

•    P_pgrp指向本进程所属的进程组的 pgrp 结构的指针。

•    P_pglist是一个结构，其中包含两个指针，分别指向进程组中上一个和下一个进程。

最后还有一个 vnode 结构。如前所述，在打开控制终端设备时分配此结构。进程对/dev/tty

的所有访问都通过 vnode 结构。

##### 9.12小结

本章说明了进程组之间的关系——会话，它由若干个进程组组成，作业控制是当今很多 UNIX 系统所支持的功能，本章说明了它是如何由支持作业控制的 shell 实现的。在这些进程关系中也涉 及了进程的控制终端/dev/tty。

所有这些进程的关系都使用了很多信号方面的功能。下一章将详细讨论 UNIX 中的信号机制。

习题

9.1    考虑 6.8节中说明的 utmp 和 wtmp 文件，为什么 logout 记录是由 init 进程写的？对于 网络登录的处理与此相同吗？

9.2    编写一段程序调用 fork 并使子进程建立一个新的会话。验证子进程变成了进程组组长且不

[3121    再有控制终端。
